From c4e5cba489c781bd2c231c383e617ae0ac426fda Mon Sep 17 00:00:00 2001
From: Heisenberg <alimirmohammad.1386@gmail.com>
Date: Mon, 1 Apr 2024 23:46:03 -0400
Subject: [PATCH 105/493] Patch

---
 Makefile                                      |   16 +-
 kernelz/include/common/convert.h              |   27 +
 kernelz/include/common/list.h                 |  225 ++++
 kernelz/include/common/memoryoperations.h     |   24 +
 kernelz/include/common/print.h                |   26 +
 kernelz/include/common/random.h               |   22 +
 kernelz/include/common/string.h               |   33 +
 kernelz/include/common/types.h                |   66 +
 kernelz/include/core/cpu.h                    |   22 +
 kernelz/include/core/exceptions.h             |   47 +
 kernelz/include/core/fpu.h                    |   34 +
 kernelz/include/core/gdt.h                    |   38 +
 kernelz/include/core/idt.h                    |   96 ++
 kernelz/include/core/physicalmemory.h         |   73 +
 kernelz/include/core/port.h                   |   65 +
 kernelz/include/core/power.h                  |   20 +
 kernelz/include/core/registers.h              |  124 ++
 kernelz/include/core/tss.h                    |   52 +
 kernelz/include/core/virtualmemory.h          |  109 ++
 kernelz/include/installer/installer.h         |   37 +
 kernelz/include/installer/textgui.h           |   22 +
 kernelz/include/multiboot/multiboot.h         |  274 ++++
 kernelz/include/system/bootconsole.h          |   63 +
 kernelz/include/system/components/apm.h       |   76 ++
 kernelz/include/system/components/bochsvbe.h  |   56 +
 kernelz/include/system/components/dma.h       |  136 ++
 kernelz/include/system/components/edid.h      |   92 ++
 .../system/components/graphicsdevice.h        |   30 +
 kernelz/include/system/components/pci.h       |   69 +
 kernelz/include/system/components/pit.h       |   36 +
 kernelz/include/system/components/rtc.h       |   31 +
 kernelz/include/system/components/smbios.h    |  299 +++++
 .../system/components/systemcomponent.h       |   24 +
 kernelz/include/system/components/vesa.h      |   85 ++
 kernelz/include/system/debugger.h             |   70 +
 kernelz/include/system/disks/disk.h           |   41 +
 kernelz/include/system/disks/diskcontroller.h |   29 +
 kernelz/include/system/disks/diskmanager.h    |   63 +
 .../include/system/disks/partitionmanager.h   |   53 +
 .../system/drivers/disk/ahci/ahcicontroller.h |   56 +
 .../system/drivers/disk/ahci/ahcidefs.h       |  283 ++++
 .../system/drivers/disk/ahci/ahciport.h       |   87 ++
 kernelz/include/system/drivers/disk/ide.h     |  252 ++++
 kernelz/include/system/drivers/driver.h       |   27 +
 .../include/system/drivers/drivermanager.h    |   31 +
 .../system/drivers/integrated/floppy.h        |  234 ++++
 .../system/drivers/integrated/ps2-keyboard.h  |   34 +
 .../system/drivers/integrated/ps2-mouse.h     |   65 +
 kernelz/include/system/drivers/pcidrivers.h   |   30 +
 .../system/drivers/usb/controllers/ehci.h     |  209 +++
 .../system/drivers/usb/controllers/ohci.h     |  152 +++
 .../system/drivers/usb/controllers/uhci.h     |  176 +++
 .../system/drivers/usb/controllers/xhci.h     |  240 ++++
 .../include/system/drivers/usb/mass_storage.h |  168 +++
 .../include/system/drivers/usb/usbcomborecv.h |   42 +
 kernelz/include/system/drivers/usb/usbdefs.h  |  161 +++
 .../include/system/drivers/usb/usbdriver.h    |   32 +
 .../include/system/drivers/usb/usbkeyboard.h  |   40 +
 kernelz/include/system/drivers/usb/usbmouse.h |   42 +
 .../include/system/drivers/video/vmwaresvga.h |   54 +
 kernelz/include/system/initrd.h               |   30 +
 kernelz/include/system/input/keyboard.h       |   55 +
 .../include/system/input/keyboardmanager.h    |   33 +
 kernelz/include/system/interruptmanager.h     |   34 +
 .../system/listings/directorylisting.h        |   37 +
 .../system/listings/listingcontroller.h       |   34 +
 kernelz/include/system/listings/systeminfo.h  |   56 +
 kernelz/include/system/log.h                  |   24 +
 kernelz/include/system/memory/deviceheap.h    |   34 +
 kernelz/include/system/memory/fifostream.h    |   50 +
 kernelz/include/system/memory/heap.h          |   63 +
 kernelz/include/system/memory/new.h           |   48 +
 kernelz/include/system/memory/sharedmem.h     |   42 +
 kernelz/include/system/memory/stream.h        |   38 +
 kernelz/include/system/serialport.h           |   38 +
 .../syscalls/implementations/cactusos.h       |   18 +
 .../system/syscalls/implementations/linux.h   |   18 +
 kernelz/include/system/syscalls/syscalls.h    |   20 +
 kernelz/include/system/system.h               |  142 ++
 kernelz/include/system/tasking/elf.h          |   59 +
 kernelz/include/system/tasking/ipcmanager.h   |   33 +
 kernelz/include/system/tasking/lock.h         |   23 +
 kernelz/include/system/tasking/process.h      |   73 +
 kernelz/include/system/tasking/scheduler.h    |   48 +
 kernelz/include/system/tasking/thread.h       |   62 +
 kernelz/include/system/usb/hidparser.h        |  134 ++
 kernelz/include/system/usb/usbcontroller.h    |  100 ++
 kernelz/include/system/usb/usbdevice.h        |   75 ++
 kernelz/include/system/usb/usbendpoint.h      |   48 +
 kernelz/include/system/usb/usbmanager.h       |   42 +
 kernelz/include/system/vfs/fat.h              |  265 ++++
 kernelz/include/system/vfs/iso9660.h          |  149 +++
 kernelz/include/system/vfs/vfsmanager.h       |   59 +
 .../include/system/vfs/virtualfilesystem.h    |   60 +
 kernelz/include/system/virtual8086/VM86Args.h |   22 +
 .../include/system/virtual8086/VM86Manager.h  |   32 +
 .../include/system/virtual8086/VM86Monitor.h  |   23 +
 kernelz/linker.ld                             |   43 +
 kernelz/obj/boot/loader.o                     |  Bin 0 -> 9260 bytes
 kernelz/obj/core/cpu.o                        |  Bin 0 -> 5092 bytes
 kernelz/obj/core/cpuhelper.o                  |  Bin 0 -> 464 bytes
 kernelz/obj/core/exceptions.o                 |  Bin 0 -> 30032 bytes
 kernelz/obj/core/fpu.o                        |  Bin 0 -> 3840 bytes
 kernelz/obj/core/gdt.o                        |  Bin 0 -> 4584 bytes
 kernelz/obj/core/gdthelper.o                  |  Bin 0 -> 560 bytes
 kernelz/obj/core/idt.o                        |  Bin 0 -> 14400 bytes
 kernelz/obj/core/idthelper.o                  |  Bin 0 -> 2464 bytes
 kernelz/obj/core/physicalmemory.o             |  Bin 0 -> 22560 bytes
 kernelz/obj/core/power.o                      |  Bin 0 -> 17368 bytes
 kernelz/obj/core/tss.o                        |  Bin 0 -> 5596 bytes
 kernelz/obj/core/tsshelper.o                  |  Bin 0 -> 448 bytes
 kernelz/obj/core/virtualmemory.o              |  Bin 0 -> 20200 bytes
 kernelz/obj/gdb/gdbimpl.o                     |  Bin 0 -> 8672 bytes
 kernelz/obj/gdb/i386-stub.o                   |  Bin 0 -> 20808 bytes
 kernelz/obj/kernel.o                          |  Bin 0 -> 68372 bytes
 kernelz/obj/system/virtual8086/VM8086Code.o   |  Bin 0 -> 672 bytes
 kernelz/src/boot/loader.s                     |   91 ++
 kernelz/src/common/convert.cpp                |  163 +++
 kernelz/src/common/memoryoperations.cpp       |   44 +
 kernelz/src/common/print.cpp                  |   59 +
 kernelz/src/common/random.cpp                 |   21 +
 kernelz/src/common/string.cpp                 |  164 +++
 kernelz/src/core/cpu.cpp                      |   55 +
 kernelz/src/core/cpuhelper.asm                |   10 +
 kernelz/src/core/exceptions.cpp               |  211 +++
 kernelz/src/core/fpu.cpp                      |   33 +
 kernelz/src/core/gdt.cpp                      |   48 +
 kernelz/src/core/gdthelper.asm                |   15 +
 kernelz/src/core/idt.cpp                      |  144 ++
 kernelz/src/core/idthelper.s                  |  104 ++
 kernelz/src/core/physicalmemory.cpp           |  226 ++++
 kernelz/src/core/power.cpp                    |  342 +++++
 kernelz/src/core/tss.cpp                      |   42 +
 kernelz/src/core/tsshelper.asm                |    5 +
 kernelz/src/core/virtualmemory.cpp            |  209 +++
 kernelz/src/gdb/gdbimpl.cpp                   |   90 ++
 kernelz/src/gdb/i386-stub.c                   |  964 ++++++++++++++
 kernelz/src/installer/installer.cpp           |  590 +++++++++
 kernelz/src/installer/textgui.cpp             |   61 +
 kernelz/src/kernel.cpp                        |  265 ++++
 kernelz/src/system/bootconsole.cpp            |  137 ++
 kernelz/src/system/components/apm.cpp         |  118 ++
 kernelz/src/system/components/bochsvbe.cpp    |   60 +
 kernelz/src/system/components/dma.cpp         |  126 ++
 kernelz/src/system/components/edid.cpp        |  120 ++
 .../src/system/components/graphicsdevice.cpp  |   46 +
 kernelz/src/system/components/pci.cpp         |  234 ++++
 kernelz/src/system/components/pit.cpp         |   83 ++
 kernelz/src/system/components/rtc.cpp         |   92 ++
 kernelz/src/system/components/smbios.cpp      |  141 ++
 .../system/components/systemcomponents.cpp    |   20 +
 kernelz/src/system/components/vesa.cpp        |  159 +++
 kernelz/src/system/debugger.cpp               |  480 +++++++
 kernelz/src/system/disks/disk.cpp             |   36 +
 kernelz/src/system/disks/diskcontroller.cpp   |   14 +
 kernelz/src/system/disks/diskmanager.cpp      |   51 +
 kernelz/src/system/disks/partitionmanager.cpp |   77 ++
 .../drivers/disk/ahci/ahcicontroller.cpp      |  174 +++
 .../src/system/drivers/disk/ahci/ahciport.cpp |  513 +++++++
 kernelz/src/system/drivers/disk/ide.cpp       |  845 ++++++++++++
 kernelz/src/system/drivers/driver.cpp         |   25 +
 kernelz/src/system/drivers/drivermanager.cpp  |   27 +
 .../src/system/drivers/integrated/floppy.cpp  |  485 +++++++
 .../drivers/integrated/ps2-keyboard.cpp       |  115 ++
 .../system/drivers/integrated/ps2-mouse.cpp   |  220 +++
 kernelz/src/system/drivers/pcidrivers.cpp     |  119 ++
 .../system/drivers/usb/controllers/ehci.cpp   |  816 ++++++++++++
 .../system/drivers/usb/controllers/ohci.cpp   |  811 ++++++++++++
 .../system/drivers/usb/controllers/uhci.cpp   |  776 +++++++++++
 .../system/drivers/usb/controllers/xhci.cpp   |  693 ++++++++++
 .../src/system/drivers/usb/mass_storage.cpp   |  406 ++++++
 .../src/system/drivers/usb/usbcomborecv.cpp   |  186 +++
 kernelz/src/system/drivers/usb/usbdriver.cpp  |   30 +
 .../src/system/drivers/usb/usbkeyboard.cpp    |  107 ++
 kernelz/src/system/drivers/usb/usbmouse.cpp   |  134 ++
 .../src/system/drivers/video/vmwaresvga.cpp   |   70 +
 kernelz/src/system/initrd.cpp                 |   42 +
 kernelz/src/system/input/keyboard.cpp         |   24 +
 kernelz/src/system/input/keyboardmanager.cpp  |  147 ++
 kernelz/src/system/interruptmanager.cpp       |   61 +
 .../src/system/listings/directorylisting.cpp  |   67 +
 .../src/system/listings/listingcontroller.cpp |   22 +
 kernelz/src/system/listings/systeminfo.cpp    |  416 ++++++
 kernelz/src/system/log.cpp                    |  146 ++
 kernelz/src/system/memory/deviceheap.cpp      |   22 +
 kernelz/src/system/memory/fifostream.cpp      |   56 +
 kernelz/src/system/memory/heap.cpp            |  231 ++++
 kernelz/src/system/memory/sharedmem.cpp       |  113 ++
 kernelz/src/system/memory/stream.cpp          |   26 +
 kernelz/src/system/serialport.cpp             |   60 +
 .../syscalls/implementations/cactusos.cpp     |  416 ++++++
 .../system/syscalls/implementations/linux.cpp |   27 +
 kernelz/src/system/syscalls/syscalls.cpp      |   41 +
 kernelz/src/system/system.cpp                 |  162 +++
 kernelz/src/system/tasking/atomic.s           |    9 +
 kernelz/src/system/tasking/ipcmanager.cpp     |  110 ++
 kernelz/src/system/tasking/lock.cpp           |   25 +
 kernelz/src/system/tasking/process.cpp        |  281 ++++
 kernelz/src/system/tasking/scheduler.cpp      |  204 +++
 kernelz/src/system/tasking/thread.cpp         |   70 +
 kernelz/src/system/tasking/userspace.asm      |   28 +
 kernelz/src/system/usb/hidparser.cpp          |  417 ++++++
 kernelz/src/system/usb/usbcontroller.cpp      |  118 ++
 kernelz/src/system/usb/usbdevice.cpp          |  279 ++++
 kernelz/src/system/usb/usbendpoint.cpp        |   25 +
 kernelz/src/system/usb/usbmanager.cpp         |   79 ++
 kernelz/src/system/vfs/fat.cpp                | 1179 +++++++++++++++++
 kernelz/src/system/vfs/iso9660.cpp            |  356 +++++
 kernelz/src/system/vfs/vfsmanager.cpp         |  231 ++++
 kernelz/src/system/vfs/virtualfilesystem.cpp  |   65 +
 kernelz/src/system/virtual8086/VM8086Code.asm |   62 +
 .../src/system/virtual8086/VM8086Helper.asm   |   49 +
 .../src/system/virtual8086/VM8086Manager.cpp  |   89 ++
 .../src/system/virtual8086/VM8086Monitor.cpp  |  221 +++
 214 files changed, 25754 insertions(+), 8 deletions(-)
 create mode 100644 kernelz/include/common/convert.h
 create mode 100644 kernelz/include/common/list.h
 create mode 100644 kernelz/include/common/memoryoperations.h
 create mode 100644 kernelz/include/common/print.h
 create mode 100644 kernelz/include/common/random.h
 create mode 100644 kernelz/include/common/string.h
 create mode 100644 kernelz/include/common/types.h
 create mode 100644 kernelz/include/core/cpu.h
 create mode 100644 kernelz/include/core/exceptions.h
 create mode 100644 kernelz/include/core/fpu.h
 create mode 100644 kernelz/include/core/gdt.h
 create mode 100644 kernelz/include/core/idt.h
 create mode 100644 kernelz/include/core/physicalmemory.h
 create mode 100644 kernelz/include/core/port.h
 create mode 100644 kernelz/include/core/power.h
 create mode 100644 kernelz/include/core/registers.h
 create mode 100644 kernelz/include/core/tss.h
 create mode 100644 kernelz/include/core/virtualmemory.h
 create mode 100644 kernelz/include/installer/installer.h
 create mode 100644 kernelz/include/installer/textgui.h
 create mode 100644 kernelz/include/multiboot/multiboot.h
 create mode 100644 kernelz/include/system/bootconsole.h
 create mode 100644 kernelz/include/system/components/apm.h
 create mode 100644 kernelz/include/system/components/bochsvbe.h
 create mode 100644 kernelz/include/system/components/dma.h
 create mode 100644 kernelz/include/system/components/edid.h
 create mode 100644 kernelz/include/system/components/graphicsdevice.h
 create mode 100644 kernelz/include/system/components/pci.h
 create mode 100644 kernelz/include/system/components/pit.h
 create mode 100644 kernelz/include/system/components/rtc.h
 create mode 100644 kernelz/include/system/components/smbios.h
 create mode 100644 kernelz/include/system/components/systemcomponent.h
 create mode 100644 kernelz/include/system/components/vesa.h
 create mode 100644 kernelz/include/system/debugger.h
 create mode 100644 kernelz/include/system/disks/disk.h
 create mode 100644 kernelz/include/system/disks/diskcontroller.h
 create mode 100644 kernelz/include/system/disks/diskmanager.h
 create mode 100644 kernelz/include/system/disks/partitionmanager.h
 create mode 100644 kernelz/include/system/drivers/disk/ahci/ahcicontroller.h
 create mode 100644 kernelz/include/system/drivers/disk/ahci/ahcidefs.h
 create mode 100644 kernelz/include/system/drivers/disk/ahci/ahciport.h
 create mode 100644 kernelz/include/system/drivers/disk/ide.h
 create mode 100644 kernelz/include/system/drivers/driver.h
 create mode 100644 kernelz/include/system/drivers/drivermanager.h
 create mode 100644 kernelz/include/system/drivers/integrated/floppy.h
 create mode 100644 kernelz/include/system/drivers/integrated/ps2-keyboard.h
 create mode 100644 kernelz/include/system/drivers/integrated/ps2-mouse.h
 create mode 100644 kernelz/include/system/drivers/pcidrivers.h
 create mode 100644 kernelz/include/system/drivers/usb/controllers/ehci.h
 create mode 100644 kernelz/include/system/drivers/usb/controllers/ohci.h
 create mode 100644 kernelz/include/system/drivers/usb/controllers/uhci.h
 create mode 100644 kernelz/include/system/drivers/usb/controllers/xhci.h
 create mode 100644 kernelz/include/system/drivers/usb/mass_storage.h
 create mode 100644 kernelz/include/system/drivers/usb/usbcomborecv.h
 create mode 100644 kernelz/include/system/drivers/usb/usbdefs.h
 create mode 100644 kernelz/include/system/drivers/usb/usbdriver.h
 create mode 100644 kernelz/include/system/drivers/usb/usbkeyboard.h
 create mode 100644 kernelz/include/system/drivers/usb/usbmouse.h
 create mode 100644 kernelz/include/system/drivers/video/vmwaresvga.h
 create mode 100644 kernelz/include/system/initrd.h
 create mode 100644 kernelz/include/system/input/keyboard.h
 create mode 100644 kernelz/include/system/input/keyboardmanager.h
 create mode 100644 kernelz/include/system/interruptmanager.h
 create mode 100644 kernelz/include/system/listings/directorylisting.h
 create mode 100644 kernelz/include/system/listings/listingcontroller.h
 create mode 100644 kernelz/include/system/listings/systeminfo.h
 create mode 100644 kernelz/include/system/log.h
 create mode 100644 kernelz/include/system/memory/deviceheap.h
 create mode 100644 kernelz/include/system/memory/fifostream.h
 create mode 100644 kernelz/include/system/memory/heap.h
 create mode 100644 kernelz/include/system/memory/new.h
 create mode 100644 kernelz/include/system/memory/sharedmem.h
 create mode 100644 kernelz/include/system/memory/stream.h
 create mode 100644 kernelz/include/system/serialport.h
 create mode 100644 kernelz/include/system/syscalls/implementations/cactusos.h
 create mode 100644 kernelz/include/system/syscalls/implementations/linux.h
 create mode 100644 kernelz/include/system/syscalls/syscalls.h
 create mode 100644 kernelz/include/system/system.h
 create mode 100644 kernelz/include/system/tasking/elf.h
 create mode 100644 kernelz/include/system/tasking/ipcmanager.h
 create mode 100644 kernelz/include/system/tasking/lock.h
 create mode 100644 kernelz/include/system/tasking/process.h
 create mode 100644 kernelz/include/system/tasking/scheduler.h
 create mode 100644 kernelz/include/system/tasking/thread.h
 create mode 100644 kernelz/include/system/usb/hidparser.h
 create mode 100644 kernelz/include/system/usb/usbcontroller.h
 create mode 100644 kernelz/include/system/usb/usbdevice.h
 create mode 100644 kernelz/include/system/usb/usbendpoint.h
 create mode 100644 kernelz/include/system/usb/usbmanager.h
 create mode 100644 kernelz/include/system/vfs/fat.h
 create mode 100644 kernelz/include/system/vfs/iso9660.h
 create mode 100644 kernelz/include/system/vfs/vfsmanager.h
 create mode 100644 kernelz/include/system/vfs/virtualfilesystem.h
 create mode 100644 kernelz/include/system/virtual8086/VM86Args.h
 create mode 100644 kernelz/include/system/virtual8086/VM86Manager.h
 create mode 100644 kernelz/include/system/virtual8086/VM86Monitor.h
 create mode 100644 kernelz/linker.ld
 create mode 100644 kernelz/obj/boot/loader.o
 create mode 100644 kernelz/obj/core/cpu.o
 create mode 100644 kernelz/obj/core/cpuhelper.o
 create mode 100644 kernelz/obj/core/exceptions.o
 create mode 100644 kernelz/obj/core/fpu.o
 create mode 100644 kernelz/obj/core/gdt.o
 create mode 100644 kernelz/obj/core/gdthelper.o
 create mode 100644 kernelz/obj/core/idt.o
 create mode 100644 kernelz/obj/core/idthelper.o
 create mode 100644 kernelz/obj/core/physicalmemory.o
 create mode 100644 kernelz/obj/core/power.o
 create mode 100644 kernelz/obj/core/tss.o
 create mode 100644 kernelz/obj/core/tsshelper.o
 create mode 100644 kernelz/obj/core/virtualmemory.o
 create mode 100644 kernelz/obj/gdb/gdbimpl.o
 create mode 100644 kernelz/obj/gdb/i386-stub.o
 create mode 100644 kernelz/obj/kernel.o
 create mode 100644 kernelz/obj/system/virtual8086/VM8086Code.o
 create mode 100644 kernelz/src/boot/loader.s
 create mode 100644 kernelz/src/common/convert.cpp
 create mode 100644 kernelz/src/common/memoryoperations.cpp
 create mode 100644 kernelz/src/common/print.cpp
 create mode 100644 kernelz/src/common/random.cpp
 create mode 100644 kernelz/src/common/string.cpp
 create mode 100644 kernelz/src/core/cpu.cpp
 create mode 100644 kernelz/src/core/cpuhelper.asm
 create mode 100644 kernelz/src/core/exceptions.cpp
 create mode 100644 kernelz/src/core/fpu.cpp
 create mode 100644 kernelz/src/core/gdt.cpp
 create mode 100644 kernelz/src/core/gdthelper.asm
 create mode 100644 kernelz/src/core/idt.cpp
 create mode 100644 kernelz/src/core/idthelper.s
 create mode 100644 kernelz/src/core/physicalmemory.cpp
 create mode 100644 kernelz/src/core/power.cpp
 create mode 100644 kernelz/src/core/tss.cpp
 create mode 100644 kernelz/src/core/tsshelper.asm
 create mode 100644 kernelz/src/core/virtualmemory.cpp
 create mode 100644 kernelz/src/gdb/gdbimpl.cpp
 create mode 100644 kernelz/src/gdb/i386-stub.c
 create mode 100644 kernelz/src/installer/installer.cpp
 create mode 100644 kernelz/src/installer/textgui.cpp
 create mode 100644 kernelz/src/kernel.cpp
 create mode 100644 kernelz/src/system/bootconsole.cpp
 create mode 100644 kernelz/src/system/components/apm.cpp
 create mode 100644 kernelz/src/system/components/bochsvbe.cpp
 create mode 100644 kernelz/src/system/components/dma.cpp
 create mode 100644 kernelz/src/system/components/edid.cpp
 create mode 100644 kernelz/src/system/components/graphicsdevice.cpp
 create mode 100644 kernelz/src/system/components/pci.cpp
 create mode 100644 kernelz/src/system/components/pit.cpp
 create mode 100644 kernelz/src/system/components/rtc.cpp
 create mode 100644 kernelz/src/system/components/smbios.cpp
 create mode 100644 kernelz/src/system/components/systemcomponents.cpp
 create mode 100644 kernelz/src/system/components/vesa.cpp
 create mode 100644 kernelz/src/system/debugger.cpp
 create mode 100644 kernelz/src/system/disks/disk.cpp
 create mode 100644 kernelz/src/system/disks/diskcontroller.cpp
 create mode 100644 kernelz/src/system/disks/diskmanager.cpp
 create mode 100644 kernelz/src/system/disks/partitionmanager.cpp
 create mode 100644 kernelz/src/system/drivers/disk/ahci/ahcicontroller.cpp
 create mode 100644 kernelz/src/system/drivers/disk/ahci/ahciport.cpp
 create mode 100644 kernelz/src/system/drivers/disk/ide.cpp
 create mode 100644 kernelz/src/system/drivers/driver.cpp
 create mode 100644 kernelz/src/system/drivers/drivermanager.cpp
 create mode 100644 kernelz/src/system/drivers/integrated/floppy.cpp
 create mode 100644 kernelz/src/system/drivers/integrated/ps2-keyboard.cpp
 create mode 100644 kernelz/src/system/drivers/integrated/ps2-mouse.cpp
 create mode 100644 kernelz/src/system/drivers/pcidrivers.cpp
 create mode 100644 kernelz/src/system/drivers/usb/controllers/ehci.cpp
 create mode 100644 kernelz/src/system/drivers/usb/controllers/ohci.cpp
 create mode 100644 kernelz/src/system/drivers/usb/controllers/uhci.cpp
 create mode 100644 kernelz/src/system/drivers/usb/controllers/xhci.cpp
 create mode 100644 kernelz/src/system/drivers/usb/mass_storage.cpp
 create mode 100644 kernelz/src/system/drivers/usb/usbcomborecv.cpp
 create mode 100644 kernelz/src/system/drivers/usb/usbdriver.cpp
 create mode 100644 kernelz/src/system/drivers/usb/usbkeyboard.cpp
 create mode 100644 kernelz/src/system/drivers/usb/usbmouse.cpp
 create mode 100644 kernelz/src/system/drivers/video/vmwaresvga.cpp
 create mode 100644 kernelz/src/system/initrd.cpp
 create mode 100644 kernelz/src/system/input/keyboard.cpp
 create mode 100644 kernelz/src/system/input/keyboardmanager.cpp
 create mode 100644 kernelz/src/system/interruptmanager.cpp
 create mode 100644 kernelz/src/system/listings/directorylisting.cpp
 create mode 100644 kernelz/src/system/listings/listingcontroller.cpp
 create mode 100644 kernelz/src/system/listings/systeminfo.cpp
 create mode 100644 kernelz/src/system/log.cpp
 create mode 100644 kernelz/src/system/memory/deviceheap.cpp
 create mode 100644 kernelz/src/system/memory/fifostream.cpp
 create mode 100644 kernelz/src/system/memory/heap.cpp
 create mode 100644 kernelz/src/system/memory/sharedmem.cpp
 create mode 100644 kernelz/src/system/memory/stream.cpp
 create mode 100644 kernelz/src/system/serialport.cpp
 create mode 100644 kernelz/src/system/syscalls/implementations/cactusos.cpp
 create mode 100644 kernelz/src/system/syscalls/implementations/linux.cpp
 create mode 100644 kernelz/src/system/syscalls/syscalls.cpp
 create mode 100644 kernelz/src/system/system.cpp
 create mode 100644 kernelz/src/system/tasking/atomic.s
 create mode 100644 kernelz/src/system/tasking/ipcmanager.cpp
 create mode 100644 kernelz/src/system/tasking/lock.cpp
 create mode 100644 kernelz/src/system/tasking/process.cpp
 create mode 100644 kernelz/src/system/tasking/scheduler.cpp
 create mode 100644 kernelz/src/system/tasking/thread.cpp
 create mode 100644 kernelz/src/system/tasking/userspace.asm
 create mode 100644 kernelz/src/system/usb/hidparser.cpp
 create mode 100644 kernelz/src/system/usb/usbcontroller.cpp
 create mode 100644 kernelz/src/system/usb/usbdevice.cpp
 create mode 100644 kernelz/src/system/usb/usbendpoint.cpp
 create mode 100644 kernelz/src/system/usb/usbmanager.cpp
 create mode 100644 kernelz/src/system/vfs/fat.cpp
 create mode 100644 kernelz/src/system/vfs/iso9660.cpp
 create mode 100644 kernelz/src/system/vfs/vfsmanager.cpp
 create mode 100644 kernelz/src/system/vfs/virtualfilesystem.cpp
 create mode 100644 kernelz/src/system/virtual8086/VM8086Code.asm
 create mode 100644 kernelz/src/system/virtual8086/VM8086Helper.asm
 create mode 100644 kernelz/src/system/virtual8086/VM8086Manager.cpp
 create mode 100644 kernelz/src/system/virtual8086/VM8086Monitor.cpp

diff --git a/Makefile b/Makefile
index a6fa727..647350a 100644
--- a/Makefile
+++ b/Makefile
@@ -23,20 +23,20 @@
 # pci-ohci
 #######################
 
-INCLUDEDIRS := kernel/include
+INCLUDEDIRS := kernelz/include
 QEMUOPTIONS := -boot d -device VGA,edid=on,xres=1024,yres=768 -trace events=../qemuTrace.txt -d cpu_reset #-readconfig qemu-usb-config.cfg -drive if=none,id=stick,file=disk.img -device usb-storage,bus=ehci.0,drive=stick
 
-G++PARAMS := -m32 -g -D CACTUSOSKERNEL -I $(INCLUDEDIRS) -Wall -fno-omit-frame-pointer -fno-use-cxa-atexit -nostdlib -fno-builtin -fno-exceptions -fno-rtti -fno-leading-underscore -Wno-write-strings -fpermissive -Wno-unknown-pragmas
-GCCPARAMS := -m32 -g -D CACTUSOSKERNEL -I $(INCLUDEDIRS) -Wall -fno-omit-frame-pointer -nostdlib -fno-builtin -Wno-unknown-pragmas
+G++PARAMS := -m32 -g -D CACTUSOSKERNELz -I $(INCLUDEDIRS) -Wall -fno-omit-frame-pointer -fno-use-cxa-atexit -nostdlib -fno-builtin -fno-exceptions -fno-rtti -fno-leading-underscore -Wno-write-strings -fpermissive -Wno-unknown-pragmas
+GCCPARAMS := -m32 -g -D CACTUSOSKERNELz -I $(INCLUDEDIRS) -Wall -fno-omit-frame-pointer -nostdlib -fno-builtin -Wno-unknown-pragmas
 ASPARAMS := --32
 LDPARAMS := -m elf_i386
 
-KRNLSRCDIR := kernel/src
-KRNLOBJDIR := kernel/obj
+KRNLSRCDIR := kernelz/src
+KRNLOBJDIR := kernelz/obj
 
 KRNLFILES := $(shell find $(KRNLSRCDIR) -type f \( -name \*.cpp -o -name \*.s -o -name \*.asm -o -name \*.c \)) #Find all the files that end with .cpp/.s/.asm/.c
 KRNLOBJS := $(patsubst %.cpp,%.o,$(patsubst %.s,%.o,$(patsubst %.asm,%.o,$(patsubst %.c,%.o,$(KRNLFILES))))) #Replace the .cpp/.s/.asm/.c extension with .o
-KRNLOBJS := $(subst $(KRNLSRCDIR),$(KRNLOBJDIR),$(KRNLOBJS)) #Replace the kernel/src part with kernel/obj
+KRNLOBJS := $(subst $(KRNLSRCDIR),$(KRNLOBJDIR),$(KRNLOBJS)) #Replace the kernelz/src part with kernelz/obj
 
 
 ####################################
@@ -76,7 +76,7 @@ $(KRNLOBJDIR)/%.o: $(KRNLSRCDIR)/%.asm
 
 
 
-CactusOS.bin: kernel/linker.ld $(KRNLOBJS)
+CactusOS.bin: kernelz/linker.ld $(KRNLOBJS)
 	i686-elf-ld $(LDPARAMS) -T $< -o $@ $(KRNLOBJS)
 
 CactusOS.iso: CactusOS.bin
@@ -127,7 +127,7 @@ kdbg: CactusOS.iso
 grub-core:
 	grub-mkimage -o isofiles/setup/core.img -O i386-pc -p="(hd0,msdos1)/boot/grub" --config=grubcore.cfg -v configfile biosdisk part_msdos fat normal multiboot echo
 
-# Only rebuild LIBCactusOS and the apps without recompiling the kernel
+# Only rebuild LIBCactusOS and the apps without recompiling the kernelz
 fastApps:
 	rm -rf isofiles/apps/*.bin
 	cd lib/ && $(MAKE) clean && $(MAKE)
diff --git a/kernelz/include/common/convert.h b/kernelz/include/common/convert.h
new file mode 100644
index 0000000..a43e705
--- /dev/null
+++ b/kernelz/include/common/convert.h
@@ -0,0 +1,27 @@
+#ifndef CACTUSOS__COMMON__CONVERT_H
+#define CACTUSOS__COMMON__CONVERT_H
+
+#include <common/types.h>
+#include <common/memoryoperations.h>
+
+namespace CactusOS
+{
+    namespace common
+    {
+        class Convert
+        {
+        public:
+            static char* IntToString(int i);
+            static char* IntToString32(uint32_t i);
+
+            static char* IntToHexString(common::uint8_t w);
+            static char* IntToHexString(common::uint16_t w);
+            static char* IntToHexString(common::uint32_t w);
+
+            static int StringToInt(char* string);
+            static uint32_t HexToInt(char* string);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/common/list.h b/kernelz/include/common/list.h
new file mode 100644
index 0000000..bfdb60a
--- /dev/null
+++ b/kernelz/include/common/list.h
@@ -0,0 +1,225 @@
+#ifndef __CACTUSOS__COMMON__LIST_H
+#define __CACTUSOS__COMMON__LIST_H
+
+#include <system/tasking/lock.h>
+
+namespace CactusOS
+{
+    namespace common
+    {
+        template <typename T>
+        struct ListNode
+        {
+            ListNode(const T &e) : data(e), next(0), prev(0)
+            {}
+
+            T data;
+            ListNode<T>* next;
+            ListNode<T>* prev;
+        };
+
+
+        template <typename T>
+        class List
+        {
+        public:
+            List() : head_(0), tail_(0), size_(0)
+            {   }
+            ~List()
+            { this->Clear(); /*Remove all the items from the list*/ }
+
+            int size() { return size_; }
+            void push_back(const T &e);
+            void push_front(const T &e);
+            void Clear();
+
+            T GetAt(int index);
+            T operator[](int index);
+            int IndexOf(const T &e);
+
+            void Remove(int index);
+            void Remove(const T &e);
+        private:
+            ListNode<T>* head_;
+            ListNode<T>* tail_;
+            system::MutexLock lock;
+
+            int size_;
+
+            ListNode<T>* insertInternal(const T &e, ListNode<T>* pos);
+            void removeInternal(ListNode<T> *pos);
+
+        //Iterators
+        public:
+            class iterator
+            {
+            public:
+                iterator(ListNode<T> *p=0) : pos_(p) { }
+                
+                T &operator*()
+                { return pos_->data; }
+    
+                T *operator->()
+                { return &(pos_->data); }
+    
+                bool operator!=(const iterator &rhs)
+                { return this->pos_ != rhs.pos_; }
+    
+                iterator operator++()
+                { pos_ = pos_->next; return *this; }
+    
+                iterator operator--()
+                { pos_ = pos_->prev; return *this; }
+    
+            private:
+                ListNode<T> *pos_;
+            };
+
+            iterator begin()
+            {
+                return iterator(head_);
+            }
+
+            iterator end()
+            {
+                return iterator(0);
+            }
+        };
+    }
+}
+
+using namespace CactusOS::common;
+
+/////////////
+// Implementations
+////////////
+template <typename T>
+ListNode<T>* List<T>::insertInternal(const T &e, ListNode<T>* pos)
+{
+    this->lock.Lock();
+    ListNode<T> *n = new ListNode<T>(e);
+    size_++;
+    // no operation below this should throw
+    // as state of the list has changed and memory allocated
+    n->next = pos;
+    if(pos)
+    {
+        n->prev = pos->prev;
+        pos->prev = n;
+    }
+    else
+    {
+        // pos is null that is at the very end of the list
+        n->prev = tail_;
+        tail_ = n;
+    }
+    if(n->prev)
+    {
+        n->prev->next = n;
+    }
+    else
+    {
+        // at the very begining of the list
+        head_ = n;
+    }
+    this->lock.Unlock();
+    return n;
+}
+template <typename T>
+void List<T>::push_back(const T &e)
+{
+    // inserts before the position, 
+    // 0 is the end() iterator
+    // hence insert at the end
+    insertInternal(e, 0);
+}
+template <typename T>
+void List<T>::push_front(const T &e)
+{
+    // insert before the head
+    insertInternal(e, head_);
+}
+
+template <typename T>
+void List<T>::removeInternal(ListNode<T> *pos)
+{
+    this->lock.Lock();
+	if(pos)
+	{
+		if(pos->prev)
+			pos->prev->next = pos->next;
+		if(pos->next)
+			pos->next->prev = pos->prev;
+		if(pos == head_)
+			head_ = pos->next;
+		if(pos == tail_)
+			tail_ = pos->prev;
+		delete pos;
+		size_--;
+	}
+    this->lock.Unlock();
+}
+
+template <typename T>
+void List<T>::Remove(int index)
+{
+    ListNode<T>* cur = head_;
+    for(int i = 0; i < index; ++i)
+        cur = cur->next;
+    removeInternal(cur);
+}
+
+template <typename T>
+void List<T>::Remove(const T &e)
+{
+    for(int i = 0; i < size_; i++)
+        if(GetAt(i) == e)
+            Remove(i);
+}
+
+template <typename T>
+void List<T>::Clear()
+{
+    this->lock.Lock();
+    ListNode<T>* current( head_ );
+
+    while(current)
+    {
+        ListNode<T>* next( current->next );
+        delete current;
+        current = next;
+    }
+    size_ = 0; //Reset the size to 0
+    head_ = 0;
+    tail_ = 0;
+    this->lock.Unlock();
+}
+
+template <typename T>
+T List<T>::GetAt(int index)
+{
+    this->lock.Lock();
+    ListNode<T>* cur = head_;
+    for(int i = 0; i < index; ++i)
+        cur = cur->next;
+
+    T ret = cur->data;
+    this->lock.Unlock();
+    return ret;
+}
+
+template <typename T>
+T List<T>::operator[](int index)
+{
+    return GetAt(index);
+}
+
+template <typename T>
+int List<T>::IndexOf(const T &e)
+{
+    for(int i = 0; i < size_; i++)
+        if(GetAt(i) == e)
+            return i;
+    return -1;
+}
+#endif
\ No newline at end of file
diff --git a/kernelz/include/common/memoryoperations.h b/kernelz/include/common/memoryoperations.h
new file mode 100644
index 0000000..65b3cf2
--- /dev/null
+++ b/kernelz/include/common/memoryoperations.h
@@ -0,0 +1,24 @@
+#ifndef __CACTUSOS__COMMON__MEMORYOPERATIONS_H
+#define __CACTUSOS__COMMON__MEMORYOPERATIONS_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace common
+    {
+        #define phys2virt(x) ((x) + 3_GB)
+        #define virt2phys(x) ((x) - 3_GB)
+
+        class MemoryOperations
+        {
+        public:
+            static void* memmove(void* dstptr, const void* srcptr, uint32_t size);
+            static int memcmp(const void* aptr, const void* bptr, uint32_t size);
+            static void* memset(void* bufptr, char value, uint32_t size);
+            static void* memcpy(void* dstptr, const void* srcptr, uint32_t size);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/common/print.h b/kernelz/include/common/print.h
new file mode 100644
index 0000000..1b009df
--- /dev/null
+++ b/kernelz/include/common/print.h
@@ -0,0 +1,26 @@
+#ifndef __CACTUSOS__COMMON__PRINTF_H
+#define __CACTUSOS__COMMON__PRINTF_H
+
+#include <common/types.h>
+#include <common/convert.h>
+#include <system/bootconsole.h>
+
+namespace CactusOS
+{
+    namespace common
+    {
+        class Print
+        {
+        public:
+            static void printfHex(uint8_t key);
+            static void printfHex16(uint16_t key);
+            static void printfHex32(uint32_t key);
+            static void printbits(uint8_t key);
+            static void printbits(uint16_t key);
+            static void printbits(uint32_t key);
+            static void printbits(uint64_t key);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/common/random.h b/kernelz/include/common/random.h
new file mode 100644
index 0000000..a6fed3e
--- /dev/null
+++ b/kernelz/include/common/random.h
@@ -0,0 +1,22 @@
+#ifndef __CACTUSOS__COMMON__RANDOM_H
+#define __CACTUSOS__COMMON__RANDOM_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace common
+    {
+        class Random
+        {
+        private:
+            static uint32_t next;
+        public:
+            static int Next(uint32_t max = 32767);
+            static int Next(uint32_t min, uint32_t max);             
+            static void SetSeed(uint32_t seed);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/common/string.h b/kernelz/include/common/string.h
new file mode 100644
index 0000000..b18e660
--- /dev/null
+++ b/kernelz/include/common/string.h
@@ -0,0 +1,33 @@
+#ifndef __CACTUSOS__COMMON__STRING_H
+#define __CACTUSOS__COMMON__STRING_H
+
+#include <common/types.h>
+#include <common/list.h>
+#include <common/memoryoperations.h>
+
+namespace CactusOS
+{
+    namespace common
+    {
+        #define isalpha(c) (((unsigned)c|32)-'a' < 26)
+
+        class String
+        {
+        public:
+            static int strlen(const char* str);
+            static bool strcmp(const char* strA, const char* strB);
+            static bool strncmp(const char* s1, const char* s2, int n);
+            static int IndexOf(const char* str, char c, common::uint32_t skip = 0);
+            static bool Contains(const char* str, char c);
+            static List<char*> Split(const char* str, char d);
+            static char* Uppercase(char* str);
+            static char* Lowercase(char* str);
+            static char Uppercase(char c);
+            static char Lowercase(char c);
+            static char* strcpy(char *s1, const char *s2);
+            static char* strncpy(char *s1, const char *s2, unsigned int n);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/common/types.h b/kernelz/include/common/types.h
new file mode 100644
index 0000000..1445b50
--- /dev/null
+++ b/kernelz/include/common/types.h
@@ -0,0 +1,66 @@
+#ifndef CACTUSOS__COMMON__TYPES_H
+#define CACTUSOS__COMMON__TYPES_H
+
+namespace CactusOS
+{
+    namespace common
+    {
+        typedef char                        int8_t;
+        typedef unsigned char               uint8_t;
+        typedef short                       int16_t;
+        typedef unsigned short              uint16_t;
+        typedef int                         int32_t;
+        typedef unsigned int                uint32_t;
+        typedef long long int               int64_t;
+        typedef unsigned long long int      uint64_t;
+        typedef unsigned long long          uintptr_t;
+
+        constexpr uint64_t divide64(uint64_t n, uint32_t base, uint32_t* r = 0)
+        {
+            uint64_t rem = n;
+            uint64_t b = base;
+            uint64_t res = 0, d = 1;
+            uint32_t high = rem >> 32;
+
+            /* Reduce the thing a bit first */
+            if (high >= base) {
+                    high /= base;
+                    res = (uint64_t) high << 32;
+                    rem -= (uint64_t) (high*base) << 32;
+            }
+
+            while ((int64_t)b > 0 && b < rem) {
+                    b = b+b;
+                    d = d+d;
+            }
+
+            do {
+                    if (rem >= b) {
+                            rem -= b;
+                            res += d;
+                    }
+                    b >>= 1;
+                    d >>= 1;
+            } while (d);
+
+            if(r)
+                *r = rem;
+            
+            return res;
+        }
+    }
+    constexpr common::uint32_t operator"" _KB(unsigned long long no)
+    {
+        return no * 1024;
+    }
+    constexpr common::uint32_t operator"" _MB(unsigned long long no)
+    {
+        return no * (1024_KB);
+    }
+    constexpr common::uint32_t operator"" _GB(unsigned long long no)
+    {
+        return no * (1024_MB);
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/core/cpu.h b/kernelz/include/core/cpu.h
new file mode 100644
index 0000000..27664c1
--- /dev/null
+++ b/kernelz/include/core/cpu.h
@@ -0,0 +1,22 @@
+#ifndef __CACTUSOS__CORE__CPU_H
+#define __CACTUSOS__CORE__CPU_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace core
+    {
+        #define EDX_SSE2 (1 << 26) // Streaming SIMD Extensions 2
+        #define EDX_FXSR (1 << 24) // Can we use the fxsave/fxrstor instructions?
+
+        class CPU
+        {
+        public:
+            static void PrintVendor();
+            static void EnableFeatures();
+        };        
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/core/exceptions.h b/kernelz/include/core/exceptions.h
new file mode 100644
index 0000000..65d9f8c
--- /dev/null
+++ b/kernelz/include/core/exceptions.h
@@ -0,0 +1,47 @@
+#ifndef __CACTUSOS__CORE__EXCEPTIONS_H
+#define __CACTUSOS__CORE__EXCEPTIONS_H
+
+#include <common/types.h>
+#include <system/bootconsole.h>
+#include <common/convert.h>
+#include <core/idt.h>
+
+namespace CactusOS
+{
+    namespace core
+    {
+        struct SelectorErrorCode
+        {
+            common::uint8_t External : 1;
+            common::uint8_t Table : 2;
+            common::uint16_t TableIndex : 13;
+        } __attribute__((packed));
+        
+
+        class Exceptions
+        {
+        private:
+            static common::uint32_t DivideByZero(common::uint32_t esp);
+            static common::uint32_t GeneralProtectionFault(common::uint32_t esp);
+            static common::uint32_t PageFault(common::uint32_t esp);
+            static common::uint32_t TrapException(common::uint32_t esp);
+            static common::uint32_t FloatingPointException(common::uint32_t esp);
+            static common::uint32_t StackSegmentFault(common::uint32_t esp);
+            static void ShowStacktrace(common::uint32_t esp);
+        public:
+            static common::uint32_t HandleException(common::uint32_t number, common::uint32_t esp);
+            
+            /*
+             * Enables the automatic pagefault fix procedure
+             * Warning: Only use when trying to access physical memory with no way to map it.
+            */
+            static void EnablePagefaultAutoFix();
+            /*
+             * Disables the automatic pagefault fix procedure
+            */
+            static void DisablePagefaultAutoFix();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/core/fpu.h b/kernelz/include/core/fpu.h
new file mode 100644
index 0000000..6e9242d
--- /dev/null
+++ b/kernelz/include/core/fpu.h
@@ -0,0 +1,34 @@
+#ifndef __CACTUSOS__CORE__FPU_H
+#define __CACTUSOS__CORE__FPU_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace core
+    {
+        struct FPUControlWord
+        {
+            common::uint8_t InvalidOperand : 1;
+            common::uint8_t DenormalOperand : 1;
+            common::uint8_t ZeroDevide : 1;
+            common::uint8_t Overflow : 1;
+            common::uint8_t Underflow : 1;
+            common::uint8_t Precision : 1;
+            common::uint8_t reserved1 : 1;
+            common::uint8_t reserved2 : 1;
+            common::uint8_t PrecisionControl : 2;
+            common::uint8_t RoundingControl : 2;
+            common::uint8_t InfinityControl : 1;
+            common::uint8_t reserved3 : 3;
+        } __attribute__((packed));
+
+        class FPU
+        {
+        public:
+            static void Enable();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/core/gdt.h b/kernelz/include/core/gdt.h
new file mode 100644
index 0000000..a786403
--- /dev/null
+++ b/kernelz/include/core/gdt.h
@@ -0,0 +1,38 @@
+#ifndef __CACTUSOS__CORE__GDT_H
+#define __CACTUSOS__CORE__GDT_H
+
+#include <common/types.h>
+
+using namespace CactusOS::common;
+
+namespace CactusOS
+{
+    namespace core
+    {
+        struct GDTEntry
+        {
+            common::uint16_t limit_low;           // The lower 16 bits of the limit.
+            common::uint16_t base_low;            // The lower 16 bits of the base.
+            common::uint8_t  base_middle;         // The next 8 bits of the base.
+            common::uint8_t  access;              // Access flags, determine what ring this segment can be used in.
+            common::uint8_t  granularity;
+            common::uint8_t  base_high;           // The last 8 bits of the base.
+        } __attribute__((packed));
+
+        struct GDTPointer
+        {
+            common::uint16_t limit;               // The upper 16 bits of all selector limits.
+            common::uint32_t base;                // The address of the first gdt_entry_t struct.
+        } __attribute__((packed));
+
+        class GlobalDescriptorTable
+        {        
+        public:
+            static void SetDescriptor(int number, common::uint32_t base, common::uint32_t limit, common::uint8_t access, common::uint8_t gran);
+            static GDTEntry* GetDescriptor(int number);
+            static void Init();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/core/idt.h b/kernelz/include/core/idt.h
new file mode 100644
index 0000000..26e184a
--- /dev/null
+++ b/kernelz/include/core/idt.h
@@ -0,0 +1,96 @@
+#ifndef __CACTUSOS__CORE__IDT_H
+#define __CACTUSOS__CORE__IDT_H
+
+#include <common/types.h>
+#include <core/port.h>
+#include <core/registers.h>
+#include <core/exceptions.h>
+#include <system/bootconsole.h>
+#include <common/convert.h>
+#include <common/memoryoperations.h>
+#include <system/interruptmanager.h>
+
+namespace CactusOS
+{
+    namespace core
+    {
+        #define IDT_ENTRY_SIZE 256
+        #define IDT_PRESENT 0x80
+        #define IDT_INTERRUPT 0xE
+        #define IDT_INTERRUPT_OFFSET 0x20
+
+        struct IDTEntry
+        {
+            common::uint16_t handlerLowBits;
+            common::uint16_t selector;
+            common::uint8_t reserved;
+            common::uint8_t access;
+            common::uint16_t handlerHighBits;
+        } __attribute__((packed));
+
+        struct IDTPointer
+        {
+            common::uint16_t size;
+            common::uint32_t base;
+        } __attribute__((packed));
+
+        extern "C" void IgnoreInterrupt();
+        extern "C" void HandleInterruptRequest0x00();
+        extern "C" void HandleInterruptRequest0x01();
+        extern "C" void HandleInterruptRequest0x02();
+        extern "C" void HandleInterruptRequest0x03();
+        extern "C" void HandleInterruptRequest0x04();
+        extern "C" void HandleInterruptRequest0x05();
+        extern "C" void HandleInterruptRequest0x06();
+        extern "C" void HandleInterruptRequest0x07();
+        extern "C" void HandleInterruptRequest0x08();
+        extern "C" void HandleInterruptRequest0x09();
+        extern "C" void HandleInterruptRequest0x0A();
+        extern "C" void HandleInterruptRequest0x0B();
+        extern "C" void HandleInterruptRequest0x0C();
+        extern "C" void HandleInterruptRequest0x0D();
+        extern "C" void HandleInterruptRequest0x0E();
+        extern "C" void HandleInterruptRequest0x0F();
+        extern "C" void HandleInterruptRequest0x31();
+
+        extern "C" void HandleInterruptRequest0xDD();
+        extern "C" void HandleInterruptRequest0x60();
+
+        extern "C" void HandleException0x00();
+        extern "C" void HandleException0x01();
+        extern "C" void HandleException0x02();
+        extern "C" void HandleException0x03();
+        extern "C" void HandleException0x04();
+        extern "C" void HandleException0x05();
+        extern "C" void HandleException0x06();
+        extern "C" void HandleException0x07();
+        extern "C" void HandleException0x08();
+        extern "C" void HandleException0x09();
+        extern "C" void HandleException0x0A();
+        extern "C" void HandleException0x0B();
+        extern "C" void HandleException0x0C();
+        extern "C" void HandleException0x0D();
+        extern "C" void HandleException0x0E();
+        extern "C" void HandleException0x0F();
+        extern "C" void HandleException0x10();
+        extern "C" void HandleException0x11();
+        extern "C" void HandleException0x12();
+        extern "C" void HandleException0x13();        
+
+        class InterruptDescriptorTable
+        {
+        private:
+            static void SetDescriptor(common::uint32_t number,  void (*handler)(), int accesLevel = 0);
+
+            static common::uint32_t HandleInterrupt(CPUState* state);
+        public:
+            static void Install();
+
+            static void EnableInterrupts();
+            static void DisableInterrupts();
+            static bool AreEnabled();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/core/physicalmemory.h b/kernelz/include/core/physicalmemory.h
new file mode 100644
index 0000000..4f19f9b
--- /dev/null
+++ b/kernelz/include/core/physicalmemory.h
@@ -0,0 +1,73 @@
+#ifndef __CACTUSOS__CORE__PHYSICALMEMORY_H
+#define __CACTUSOS__CORE__PHYSICALMEMORY_H
+
+#include <common/types.h>
+#include <common/convert.h>
+#include <common/memoryoperations.h>
+#include <system/bootconsole.h>
+#include <multiboot/multiboot.h>
+
+namespace CactusOS
+{
+    namespace core
+    {
+        #define BLOCK_SIZE 4_KB
+        #define BLOCKS_PER_BYTE 8 //Every byte describes 8 blocks
+
+        typedef struct multiboot_memory_map {
+            unsigned int size;
+            unsigned long base_addr_low;
+            unsigned long base_addr_high;
+            unsigned long length_low;
+            unsigned long length_high;
+            unsigned int type;
+        }  __attribute__((packed)) grub_multiboot_memory_map_t;
+
+        class PhysicalMemoryManager
+        {
+        private:
+            static common::uint32_t memorySize;
+            static common::uint32_t usedBlocks;
+            static common::uint32_t maximumBlocks;
+            static common::uint32_t* memoryArray;
+
+            static inline void SetBit (common::uint32_t bit)
+            {
+                memoryArray[bit / 32] |= (1 << (bit % 32));
+            }
+            static inline void UnsetBit (common::uint32_t bit)
+            {
+                memoryArray[bit / 32] &= ~ (1 << (bit % 32));
+            }
+            static inline bool TestBit (common::uint32_t bit)
+            {
+                return memoryArray[bit / 32] &  (1 << (bit % 32));
+            }
+
+            static common::uint32_t FirstFree ();
+            static common::uint32_t FirstFreeSize (common::uint32_t size);
+        public:
+            static void Initialize(common::uint32_t size, common::uint32_t bitmap);
+            static void SetRegionFree(common::uint32_t base, common::uint32_t size);
+            static void SetRegionUsed(common::uint32_t base, common::uint32_t size);
+            static void ParseMemoryMap(const multiboot_info_t* mbi);
+            
+            static void* AllocateBlock();
+            static void FreeBlock(void* ptr);
+            static void* AllocateBlocks(common::uint32_t size);
+            static void FreeBlocks(void* ptr, common::uint32_t size);
+
+            static common::uint32_t AmountOfMemory();
+            static common::uint32_t UsedBlocks();
+            static common::uint32_t FreeBlocks();
+            static common::uint32_t TotalBlocks();
+            static common::uint32_t GetBitmapSize();
+        };
+
+        //Helper functions
+        common::uint32_t pageRoundUp(common::uint32_t address);
+        common::uint32_t pageRoundDown(common::uint32_t address);
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/core/port.h b/kernelz/include/core/port.h
new file mode 100644
index 0000000..f2d7b99
--- /dev/null
+++ b/kernelz/include/core/port.h
@@ -0,0 +1,65 @@
+#ifndef __CACTUSOS__CORE__PORT_H
+#define __CACTUSOS__CORE__PORT_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace core
+    {
+        #define insl(port, buffer, count) asm volatile("cld; rep; insl" :: "D" (buffer), "d" (port), "c" (count))
+
+        inline static unsigned char inportb (unsigned short _port)
+        {
+            unsigned char rv;
+            __asm__ __volatile__ ("inb %1, %0" : "=a" (rv) : "dN" (_port));
+            return rv;
+        }
+
+        inline static void outportb (unsigned short _port, unsigned char _data)
+        {
+            __asm__ __volatile__ ("outb %1, %0" : : "dN" (_port), "a" (_data));
+        }
+
+        inline static unsigned short inportw(unsigned short _port)
+        {
+            unsigned short rv;
+            __asm__ __volatile__ ("inw %1, %0" : "=a" (rv) : "dN" (_port));
+            return rv;
+        }
+
+        inline static void outportw(unsigned short _port, unsigned short _data)
+        {
+            __asm__ __volatile__ ("outw %1, %0" : : "dN" (_port), "a" (_data));
+        }
+        inline static unsigned int inportl(unsigned short _port)
+        {
+            unsigned int val;
+            __asm__ __volatile__ ("inl %%dx, %%eax" : "=a" (val) : "d" (_port));
+            return( val );
+        }
+        inline static void outportl(unsigned short _port, unsigned int _data)
+        {
+            __asm__ __volatile__ ("outl %%eax, %%dx" : : "d" (_port), "a" (_data));
+        }
+
+        inline static void inportsm(unsigned short port, unsigned char * data, unsigned long size)
+        {
+            asm volatile ("rep insw" : "+D" (data), "+c" (size) : "d" (port) : "memory");
+        }
+
+        inline static void outportsm(unsigned short port, unsigned char * data, unsigned long size) {
+	        asm volatile ("rep outsw" : "+S" (data), "+c" (size) : "d" (port));
+        }
+
+        inline static void writeMemReg(const common::uint32_t addr, const common::uint32_t val) {
+            *(volatile common::uint32_t*)addr = val;
+        }
+
+        inline static common::uint32_t readMemReg(const common::uint32_t addr) {
+            return *(volatile common::uint32_t*)addr;
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/core/power.h b/kernelz/include/core/power.h
new file mode 100644
index 0000000..1225eab
--- /dev/null
+++ b/kernelz/include/core/power.h
@@ -0,0 +1,20 @@
+#ifndef __CACTUSOS__CORE__POWER_H
+#define __CACTUSOS__CORE__POWER_H
+
+#include <core/port.h>
+
+namespace CactusOS
+{
+    namespace core
+    {
+        class Power
+        {
+        public:
+            static void Initialize();
+            static void Reboot();
+            static void Poweroff();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/core/registers.h b/kernelz/include/core/registers.h
new file mode 100644
index 0000000..20e3fb2
--- /dev/null
+++ b/kernelz/include/core/registers.h
@@ -0,0 +1,124 @@
+#ifndef __CACTUSOS__CORE__REGISTERS_H
+#define __CACTUSOS__CORE__REGISTERS_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace core
+    {
+        struct CPUState
+        {
+            struct //sGS
+            {
+                common::uint16_t GS;
+                common::uint16_t hGS;
+            };
+            struct //sFS
+            {
+                common::uint16_t FS;
+                common::uint16_t hFS;
+            };
+            struct //sES
+            {
+                common::uint16_t ES;
+                common::uint16_t hES;
+            };
+            struct //sDS
+            {
+                common::uint16_t DS;
+                common::uint16_t hDS;
+            };
+            union //sEDI
+            {
+                common::uint32_t EDI;
+                common::uint16_t DI;
+            };
+            union //sESI
+            {
+                common::uint32_t ESI;
+                common::uint16_t SI;
+            };
+            union //sEBP
+            {
+                common::uint32_t EBP;
+                common::uint16_t BP;
+            };
+            union //sESP
+            {
+                common::uint32_t ESP;
+                common::uint16_t SP;
+            };
+            union //sEBX
+            {
+                common::uint32_t EBX;
+                common::uint16_t BX;
+                struct
+                {
+                    common::uint8_t BL;
+                    common::uint8_t BH;
+                };
+            };
+            union //sEDX
+            {
+                common::uint32_t EDX;
+                common::uint16_t DX;
+                struct
+                {
+                    common::uint8_t DL;
+                    common::uint8_t DH;
+                };
+            };
+            union //sECX
+            {
+                common::uint32_t ECX;
+                common::uint16_t CX;
+                struct
+                {
+                    common::uint8_t CL;
+                    common::uint8_t CH;
+                };
+            };
+            union //sEAX
+            {
+                common::uint32_t EAX;
+                common::uint16_t AX;
+                struct
+                {
+                    common::uint8_t AL;
+                    common::uint8_t AH;
+                };
+            };
+            common::uint32_t InterruptNumber;
+            common::uint32_t ErrorCode;
+
+            union //sEIP
+            {
+                common::uint32_t EIP;
+                common::uint16_t IP;
+            };
+            struct //sCS
+            {
+                common::uint16_t CS;
+                common::uint16_t hCS;
+            };
+            union //sEFLAGS
+            {
+                common::uint32_t EFLAGS;
+                common::uint16_t FLAGS;
+            };
+            union //sUserESP
+            {
+                common::uint32_t UserESP;
+                common::uint16_t UserSP;
+            };
+            union //sUserSS
+            {
+                common::uint16_t UserSS;
+                common::uint16_t hUserSS;
+            };
+        } __attribute__((packed));
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/core/tss.h b/kernelz/include/core/tss.h
new file mode 100644
index 0000000..3a63ff7
--- /dev/null
+++ b/kernelz/include/core/tss.h
@@ -0,0 +1,52 @@
+#ifndef __CACTUSOS__CORE__TSS_H
+#define __CACTUSOS__CORE__TSS_H
+
+#include <common/types.h>
+#include <common/memoryoperations.h>
+#include <core/gdt.h>
+
+namespace CactusOS
+{
+    namespace core
+    {
+        struct TSSEntry {
+            common::uint32_t prevTss;
+            common::uint32_t esp0;
+            common::uint32_t ss0;
+            common::uint32_t esp1;
+            common::uint32_t ss1;
+            common::uint32_t esp2;
+            common::uint32_t ss2;
+            common::uint32_t cr3;
+            common::uint32_t eip;
+            common::uint32_t eflags;
+            common::uint32_t eax;
+            common::uint32_t ecx;
+            common::uint32_t edx;
+            common::uint32_t ebx;
+            common::uint32_t esp;
+            common::uint32_t ebp;
+            common::uint32_t esi;
+            common::uint32_t edi;
+            common::uint32_t es;
+            common::uint32_t cs;
+            common::uint32_t ss;
+            common::uint32_t ds;
+            common::uint32_t fs;
+            common::uint32_t gs;
+            common::uint32_t ldt;
+            common::uint16_t trap;
+            common::uint16_t iomap;
+        };
+
+        class TSS
+        {
+        public:
+            static void Install(common::uint32_t idx, common::uint32_t kernelSS, common::uint32_t kernelESP);
+            static void SetStack(common::uint32_t kernelSS, common::uint32_t kernelESP);
+            static TSSEntry* GetCurrent();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/core/virtualmemory.h b/kernelz/include/core/virtualmemory.h
new file mode 100644
index 0000000..7d74cf0
--- /dev/null
+++ b/kernelz/include/core/virtualmemory.h
@@ -0,0 +1,109 @@
+/*
+*   Structs from: https://wiki.osdev.org/Paging
+*/
+
+#ifndef __CACTUSOS__CORE__VIRTUALMEMORY_H
+#define __CACTUSOS__CORE__VIRTUALMEMORY_H
+
+#include <core/physicalmemory.h>
+#include <common/types.h>
+#include <system/memory/heap.h>
+
+namespace CactusOS
+{
+    namespace core
+    {
+        extern "C" void* BootPageDirectory;
+
+        enum PAGE_ENTRY_SIZE
+        {
+            FOUR_KB = 0,
+            FOUR_MB = 1
+        };
+
+        #define KERNEL_VIRT_ADDR 3_GB
+        #define USER_STACK_SIZE 32_KB
+        #define USER_STACK_TOP (KERNEL_VIRT_ADDR)
+        #define USER_STACK (USER_STACK_TOP - USER_STACK_SIZE)
+
+        #define PAGE_SIZE 4_KB
+        #define KERNEL_PTNUM 768 //The kernel is in the 768th entry
+        #define PAGE_TABLE_ADDRESS 0xFFC00000
+        #define PAGE_DIRECTORY_ADDRESS 0xFFFFF000
+
+        #define PAGE_OFFSET_BITS 12
+
+        #define PAGEDIR_INDEX(addr) (((uint32_t)addr) >> 22)
+        #define PAGETBL_INDEX(addr) ((((uint32_t)addr) >> 12) & 0x3ff)
+        #define PAGEFRAME_INDEX(addr) (((uint32_t)addr) & 0xfff)
+
+        struct PageDirectoryEntry
+        {
+            common::uint32_t present        : 1;    //Is this page present in physical memory or perhaps on the disk.
+            common::uint32_t readWrite      : 1;    //If set the page is r/w otherwise read only.
+            common::uint32_t isUser         : 1;    //If set the page can be accessed by all levels.
+            common::uint32_t writeThrough   : 1;    //If set write through caching is enabled.
+            common::uint32_t canCache       : 1;    //If the bit is set, the page will not be cached.
+            common::uint32_t accessed       : 1;    //Has this page been accesed, set by cpu.
+            common::uint32_t reserved       : 1;    //Reserved.
+            common::uint32_t pageSize       : 1;    //If the bit is set, then pages are 4 MiB in size. Otherwise, they are 4 KiB.
+            common::uint32_t ignored        : 1;
+            common::uint32_t unused         : 3;    //Unused by the cpu so we can use them perhaps for additional page information.
+            common::uint32_t frame          : 20;   //Page Table 4-kb aligned address.
+        } __attribute__((packed));
+
+        struct PageTableEntry
+        {
+            common::uint32_t present        : 1;    //Is this page present in physical memory or perhaps on the disk.
+            common::uint32_t readWrite      : 1;    //If set the page is r/w otherwise read only.
+            common::uint32_t isUser         : 1;    //If set the page can be accessed by all levels.
+            common::uint32_t writeThrough   : 1;    //If set write through caching is enabled.
+            common::uint32_t canCache       : 1;    //If the bit is set, the page will not be cached.
+            common::uint32_t accessed       : 1;    //Has this page been accesed, set by cpu.
+            common::uint32_t dirty          : 1;    //Indicates that the page has been written to.
+            common::uint32_t reserved       : 1;
+            common::uint32_t global         : 1;    //if set, prevents the TLB from updating the address in its cache if CR3 is reset. Note, that the page global enable bit in CR4 must be set to enable this feature. 
+            common::uint32_t unused         : 3;    //Unused by the cpu so we can use them perhaps for additional page information.
+            common::uint32_t frame          : 20;   //Target memory 4kb block
+        } __attribute__((packed));
+
+        struct PageTable
+        {
+            PageTableEntry entries[1024];
+        }   __attribute__((packed));
+
+        struct PageDirectory
+        {
+            PageDirectoryEntry entries[1024];
+        }   __attribute__((packed));
+
+        // Invalidate TLB Entries
+        static inline void invlpg(void* addr)
+        {
+            asm volatile("invlpg (%0)" ::"r" (addr) : "memory");
+        }
+
+        class VirtualMemoryManager
+        {
+        public:      
+            static void ReloadCR3();  
+            static void Initialize();
+            static void AllocatePage(PageTableEntry* page, bool kernel, bool writeable);
+            static void FreePage(PageTableEntry* page);
+
+            static PageTableEntry* GetPageForAddress(common::uint32_t virtualAddress, bool shouldCreate, bool readWrite = true, bool userPages = false);
+            
+            static void* GetPageTableAddress(common::uint16_t pageTableNumber);
+            
+            static void* virtualToPhysical(void* virtAddress);
+            
+            static void mapVirtualToPhysical(void* physAddress, void* virtAddress, bool kernel = true, bool writeable = true);
+            static void mapVirtualToPhysical(void* physAddress, void* virtAddress, common::uint32_t size, bool kernel = true, bool writeable = true);
+            
+            static void SwitchPageDirectory(common::uint32_t physAddr);
+            static common::uint32_t GetPageDirectoryAddress();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/installer/installer.h b/kernelz/include/installer/installer.h
new file mode 100644
index 0000000..17a2679
--- /dev/null
+++ b/kernelz/include/installer/installer.h
@@ -0,0 +1,37 @@
+#ifndef __CACTUSOS__INSTALLER__INSTALLER_H
+#define __CACTUSOS__INSTALLER__INSTALLER_H
+
+#include <system/disks/partitionmanager.h>
+#include <system/vfs/fat.h>
+
+namespace CactusOS
+{
+    // Class responsible for installing CactusOS on a hard drive
+    class Installer
+    {
+    public:
+        static void SetupError();
+        static void Run();
+        static char GetKey();
+
+        // Installer Steps
+        static void ShowWelcomeMessage();
+        static void ShowWarningMessage();
+        static void ShowDiskSelection();
+        static void ShowDiskEraseMenu();
+        static void ShowInstallScreen();
+        static void ShowSystemCopyScreen(system::FAT* fatFS);
+        static void CreateFatPartition(system::PartitionTableEntry* pEntry);
+    };
+
+    #define KEY_ENTER       0x1C
+    #define KEY_ARROW_UP    0x48
+    #define KEY_ARROW_DOWN  0x50
+    #define KEY_LEFT_ARROW  0x33
+    #define KEY_RIGHT_ARROW 0x34
+    #define KEY_MINUS       0x0C
+    #define KEY_PLUS        0x0D
+    #define KEY_A           0x1E
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/installer/textgui.h b/kernelz/include/installer/textgui.h
new file mode 100644
index 0000000..6f5a1e6
--- /dev/null
+++ b/kernelz/include/installer/textgui.h
@@ -0,0 +1,22 @@
+#ifndef __CACTUSOS__INSTALLER__TEXTGUI_H
+#define __CACTUSOS__INSTALLER__TEXTGUI_H
+
+#include <system/bootconsole.h>
+
+namespace CactusOS
+{
+    #define TEXT_COLOR system::VGA_COLOR_WHITE
+
+    //Draw a simple gui using the VGA text mode
+    class TextGUI
+    {
+    public:
+        static void DisableCursor();
+        static void SetPixel(int x, int y, char color, common::uint16_t character = ' ', char background = system::VGA_COLOR_BLUE);
+        static void ClearScreen(char color = system::VGA_COLOR_BLACK);
+        static void StatusBar(char* text, int percentage = 0);
+        static void DrawString(char* text, int x, int y, char color = TEXT_COLOR, char background = system::VGA_COLOR_BLUE);
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/multiboot/multiboot.h b/kernelz/include/multiboot/multiboot.h
new file mode 100644
index 0000000..bd14c03
--- /dev/null
+++ b/kernelz/include/multiboot/multiboot.h
@@ -0,0 +1,274 @@
+/* multiboot.h - Multiboot header file. */
+     /* Copyright (C) 1999,2003,2007,2008,2009,2010  Free Software Foundation, Inc.
+      *
+      *  Permission is hereby granted, free of charge, to any person obtaining a copy
+      *  of this software and associated documentation files (the "Software"), to
+      *  deal in the Software without restriction, including without limitation the
+      *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+      *  sell copies of the Software, and to permit persons to whom the Software is
+      *  furnished to do so, subject to the following conditions:
+      *
+      *  The above copyright notice and this permission notice shall be included in
+      *  all copies or substantial portions of the Software.
+      *
+      *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+      *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+      *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL ANY
+      *  DEVELOPER OR DISTRIBUTOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+      *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+      *  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+      */
+     
+     #ifndef MULTIBOOT_HEADER
+     #define MULTIBOOT_HEADER 1
+     
+     /* How many bytes from the start of the file we search for the header. */
+     #define MULTIBOOT_SEARCH                        8192
+     #define MULTIBOOT_HEADER_ALIGN                  4
+     
+     /* The magic field should contain this. */
+     #define MULTIBOOT_HEADER_MAGIC                  0x1BADB002
+     
+     /* This should be in %eax. */
+     #define MULTIBOOT_BOOTLOADER_MAGIC              0x2BADB002
+     
+     /* Alignment of multiboot modules. */
+     #define MULTIBOOT_MOD_ALIGN                     0x00001000
+     
+     /* Alignment of the multiboot info structure. */
+     #define MULTIBOOT_INFO_ALIGN                    0x00000004
+     
+     /* Flags set in the 'flags' member of the multiboot header. */
+     
+     /* Align all boot modules on i386 page (4KB) boundaries. */
+     #define MULTIBOOT_PAGE_ALIGN                    0x00000001
+     
+     /* Must pass memory information to OS. */
+     #define MULTIBOOT_MEMORY_INFO                   0x00000002
+     
+     /* Must pass video information to OS. */
+     #define MULTIBOOT_VIDEO_MODE                    0x00000004
+     
+     /* This flag indicates the use of the address fields in the header. */
+     #define MULTIBOOT_AOUT_KLUDGE                   0x00010000
+     
+     /* Flags to be set in the 'flags' member of the multiboot info structure. */
+     
+     /* is there basic lower/upper memory information? */
+     #define MULTIBOOT_INFO_MEMORY                   0x00000001
+     /* is there a boot device set? */
+     #define MULTIBOOT_INFO_BOOTDEV                  0x00000002
+     /* is the command-line defined? */
+     #define MULTIBOOT_INFO_CMDLINE                  0x00000004
+     /* are there modules to do something with? */
+     #define MULTIBOOT_INFO_MODS                     0x00000008
+     
+     /* These next two are mutually exclusive */
+     
+     /* is there a symbol table loaded? */
+     #define MULTIBOOT_INFO_AOUT_SYMS                0x00000010
+     /* is there an ELF section header table? */
+     #define MULTIBOOT_INFO_ELF_SHDR                 0X00000020
+     
+     /* is there a full memory map? */
+     #define MULTIBOOT_INFO_MEM_MAP                  0x00000040
+     
+     /* Is there drive info? */
+     #define MULTIBOOT_INFO_DRIVE_INFO               0x00000080
+     
+     /* Is there a config table? */
+     #define MULTIBOOT_INFO_CONFIG_TABLE             0x00000100
+     
+     /* Is there a boot loader name? */
+     #define MULTIBOOT_INFO_BOOT_LOADER_NAME         0x00000200
+     
+     /* Is there a APM table? */
+     #define MULTIBOOT_INFO_APM_TABLE                0x00000400
+     
+     /* Is there video information? */
+     #define MULTIBOOT_INFO_VBE_INFO                 0x00000800
+     #define MULTIBOOT_INFO_FRAMEBUFFER_INFO         0x00001000
+     
+     #ifndef ASM_FILE
+     
+     typedef unsigned char           multiboot_uint8_t;
+     typedef unsigned short          multiboot_uint16_t;
+     typedef unsigned int            multiboot_uint32_t;
+     typedef unsigned long long      multiboot_uint64_t;
+     
+     struct multiboot_header
+     {
+       /* Must be MULTIBOOT_MAGIC - see above. */
+       multiboot_uint32_t magic;
+     
+       /* Feature flags. */
+       multiboot_uint32_t flags;
+     
+       /* The above fields plus this one must equal 0 mod 2^32. */
+       multiboot_uint32_t checksum;
+     
+       /* These are only valid if MULTIBOOT_AOUT_KLUDGE is set. */
+       multiboot_uint32_t header_addr;
+       multiboot_uint32_t load_addr;
+       multiboot_uint32_t load_end_addr;
+       multiboot_uint32_t bss_end_addr;
+       multiboot_uint32_t entry_addr;
+     
+       /* These are only valid if MULTIBOOT_VIDEO_MODE is set. */
+       multiboot_uint32_t mode_type;
+       multiboot_uint32_t width;
+       multiboot_uint32_t height;
+       multiboot_uint32_t depth;
+     };
+     
+     /* The symbol table for a.out. */
+     struct multiboot_aout_symbol_table
+     {
+       multiboot_uint32_t tabsize;
+       multiboot_uint32_t strsize;
+       multiboot_uint32_t addr;
+       multiboot_uint32_t reserved;
+     };
+     typedef struct multiboot_aout_symbol_table multiboot_aout_symbol_table_t;
+     
+     /* The section header table for ELF. */
+     struct multiboot_elf_section_header_table
+     {
+       multiboot_uint32_t num;
+       multiboot_uint32_t size;
+       multiboot_uint32_t addr;
+       multiboot_uint32_t shndx;
+     };
+     typedef struct multiboot_elf_section_header_table multiboot_elf_section_header_table_t;
+     
+     struct multiboot_info
+     {
+       /* Multiboot info version number */
+       multiboot_uint32_t flags;
+     
+       /* Available memory from BIOS */
+       multiboot_uint32_t mem_lower;
+       multiboot_uint32_t mem_upper;
+     
+       /* "root" partition */
+       multiboot_uint32_t boot_device;
+     
+       /* Kernel command line */
+       multiboot_uint32_t cmdline;
+     
+       /* Boot-Module list */
+       multiboot_uint32_t mods_count;
+       multiboot_uint32_t mods_addr;
+     
+       union
+       {
+         multiboot_aout_symbol_table_t aout_sym;
+         multiboot_elf_section_header_table_t elf_sec;
+       } u;
+     
+       /* Memory Mapping buffer */
+       multiboot_uint32_t mmap_length;
+       multiboot_uint32_t mmap_addr;
+     
+       /* Drive Info buffer */
+       multiboot_uint32_t drives_length;
+       multiboot_uint32_t drives_addr;
+     
+       /* ROM configuration table */
+       multiboot_uint32_t config_table;
+     
+       /* Boot Loader Name */
+       multiboot_uint32_t boot_loader_name;
+     
+       /* APM table */
+       multiboot_uint32_t apm_table;
+     
+       /* Video */
+       multiboot_uint32_t vbe_control_info;
+       multiboot_uint32_t vbe_mode_info;
+       multiboot_uint16_t vbe_mode;
+       multiboot_uint16_t vbe_interface_seg;
+       multiboot_uint16_t vbe_interface_off;
+       multiboot_uint16_t vbe_interface_len;
+     
+       multiboot_uint64_t framebuffer_addr;
+       multiboot_uint32_t framebuffer_pitch;
+       multiboot_uint32_t framebuffer_width;
+       multiboot_uint32_t framebuffer_height;
+       multiboot_uint8_t framebuffer_bpp;
+     #define MULTIBOOT_FRAMEBUFFER_TYPE_INDEXED 0
+     #define MULTIBOOT_FRAMEBUFFER_TYPE_RGB     1
+     #define MULTIBOOT_FRAMEBUFFER_TYPE_EGA_TEXT     2
+       multiboot_uint8_t framebuffer_type;
+       union
+       {
+         struct
+         {
+           multiboot_uint32_t framebuffer_palette_addr;
+           multiboot_uint16_t framebuffer_palette_num_colors;
+         };
+         struct
+         {
+           multiboot_uint8_t framebuffer_red_field_position;
+           multiboot_uint8_t framebuffer_red_mask_size;
+           multiboot_uint8_t framebuffer_green_field_position;
+           multiboot_uint8_t framebuffer_green_mask_size;
+           multiboot_uint8_t framebuffer_blue_field_position;
+           multiboot_uint8_t framebuffer_blue_mask_size;
+         };
+       };
+     };
+     typedef struct multiboot_info multiboot_info_t;
+     
+     struct multiboot_color
+     {
+       multiboot_uint8_t red;
+       multiboot_uint8_t green;
+       multiboot_uint8_t blue;
+     };
+     
+     struct multiboot_mmap_entry
+     {
+       multiboot_uint32_t size;
+       multiboot_uint64_t addr;
+       multiboot_uint64_t len;
+     #define MULTIBOOT_MEMORY_AVAILABLE              1
+     #define MULTIBOOT_MEMORY_RESERVED               2
+     #define MULTIBOOT_MEMORY_ACPI_RECLAIMABLE       3
+     #define MULTIBOOT_MEMORY_NVS                    4
+     #define MULTIBOOT_MEMORY_BADRAM                 5
+       multiboot_uint32_t type;
+     } __attribute__((packed));
+     typedef struct multiboot_mmap_entry multiboot_memory_map_t;
+     
+     struct multiboot_mod_list
+     {
+       /* the memory used goes from bytes 'mod_start' to 'mod_end-1' inclusive */
+       multiboot_uint32_t mod_start;
+       multiboot_uint32_t mod_end;
+     
+       /* Module command line */
+       multiboot_uint32_t cmdline;
+     
+       /* padding to take it to 16 bytes (must be zero) */
+       multiboot_uint32_t pad;
+     };
+     typedef struct multiboot_mod_list multiboot_module_t;
+     
+     /* APM BIOS info. */
+     struct multiboot_apm_info
+     {
+       multiboot_uint16_t version;
+       multiboot_uint16_t cseg;
+       multiboot_uint32_t offset;
+       multiboot_uint16_t cseg_16;
+       multiboot_uint16_t dseg;
+       multiboot_uint16_t flags;
+       multiboot_uint16_t cseg_len;
+       multiboot_uint16_t cseg_16_len;
+       multiboot_uint16_t dseg_len;
+     };
+     
+     #endif /* ! ASM_FILE */
+     
+#endif /* ! MULTIBOOT_HEADER */
\ No newline at end of file
diff --git a/kernelz/include/system/bootconsole.h b/kernelz/include/system/bootconsole.h
new file mode 100644
index 0000000..2340131
--- /dev/null
+++ b/kernelz/include/system/bootconsole.h
@@ -0,0 +1,63 @@
+#ifndef __CACTUSOS__SYSTEM__BOOTCONSOLE_H
+#define __CACTUSOS__SYSTEM__BOOTCONSOLE_H
+
+#include <common/types.h>
+#include <system/serialport.h>
+
+#include <stdarg.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        #define VGA_WIDTH 80
+        #define VGA_HEIGHT 25
+
+        enum vga_color {
+            VGA_COLOR_BLACK = 0,
+            VGA_COLOR_BLUE = 1,
+            VGA_COLOR_GREEN = 2,
+            VGA_COLOR_CYAN = 3,
+            VGA_COLOR_RED = 4,
+            VGA_COLOR_MAGENTA = 5,
+            VGA_COLOR_BROWN = 6,
+            VGA_COLOR_LIGHT_GREY = 7,
+            VGA_COLOR_DARK_GREY = 8,
+            VGA_COLOR_LIGHT_BLUE = 9,
+            VGA_COLOR_LIGHT_GREEN = 10,
+            VGA_COLOR_LIGHT_CYAN = 11,
+            VGA_COLOR_LIGHT_RED = 12,
+            VGA_COLOR_LIGHT_MAGENTA = 13,
+            VGA_COLOR_LIGHT_BROWN = 14,
+            VGA_COLOR_WHITE = 15
+        };
+
+        class BootConsole
+        {
+        private:
+            static int XOffset;
+            static int YOffset;
+            static bool writeToSerial;
+
+            static void Scroll();
+        public:
+            static common::uint8_t ForegroundColor;
+            static common::uint8_t BackgroundColor;
+
+            static void Init(bool enableSerial = false);
+
+            static void Write(char c);
+            static void Write(char* str);
+            static void WriteLine(char* str);
+            static void WriteLine();
+
+            static void Clear();
+            static void SetX(int x);
+            static void SetY(int y);
+
+            static common::uint16_t* GetBuffer();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/components/apm.h b/kernelz/include/system/components/apm.h
new file mode 100644
index 0000000..681e39b
--- /dev/null
+++ b/kernelz/include/system/components/apm.h
@@ -0,0 +1,76 @@
+#ifndef __CACTUSOS__SYSTEM__COMPONENTS__APM_H
+#define __CACTUSOS__SYSTEM__COMPONENTS__APM_H
+
+#include <system/components/systemcomponent.h>
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        #define APM_SIGNATURE           0x504D //"PM"
+        #define APM_ALL_DEVICE          ((uint16_t) 0x0001)
+        #define APM_DEVICE_DISPLAY      ((uint16_t) 0x0100)
+        #define APM_DEVICE_STORAGE      ((uint16_t) 0x0200)
+        #define APM_DEVICE_PARRALEL     ((uint16_t) 0x0300)
+        #define APM_DEVICE_SERIAL       ((uint16_t) 0x0400)
+        #define APM_DEVICE_NETWORK      ((uint16_t) 0x0500)
+        #define APM_DEVICE_PCMCIA       ((uint16_t) 0x0600)
+        #define APM_DEVICE_ALL          ((uint16_t) 0x00FF)
+
+        #define APM_POWER_STANDBY       0x01
+        #define APM_POWER_SUSPEND       0x02
+        #define APM_POWER_OFF           0x03
+        #define APM_POWER_PROCESSING    0x04
+        #define APM_POWER_REJECT        0x05
+
+        #define APM_FUNC_INSTALL_CHECK                      0x00
+        #define APM_FUNC_CONNECT_REALMODE                   0x01
+        #define APM_FUNC_CONNECT_16                         0x02
+        #define APM_FUNC_CONNECT_32                         0x03
+        #define APM_FUNC_DISCONNECT                         0x04
+        #define APM_FUNC_CPU_IDLE                           0x05
+        #define APM_FUNC_CPU_BUSY                           0x06
+        #define APM_FUNC_SET_POWER_STATE                    0x07
+        #define APM_FUNC_ENABLE_POWER_MANAGEMENT            0x08
+        #define APM_FUNC_RESTORE_DEFAULTS                   0x09
+        #define APM_FUNC_GET_POWER_STATUS                   0x0A
+        #define APM_FUNC_GET_PM_EVENT                       0x0B
+        #define APM_FUNC_GET_POWER_STATE                    0x0C
+        #define APM_FUNC_SET_DEV_POWER_MANAGEMENT           0x0D
+        #define APM_FUNC_DRIVER_VERSION                     0x0E
+        #define APM_FUNC_ENGAGE_DISENGAGE_POWER_MANAGEMENT  0x0F
+        #define APM_FUNC_GET_CABABILITIES                   0x10
+        #define APM_FUNC_SET_RESUME_TIMER                   0x11
+        #define APM_FUNC_SET_RESUME_RING                    0x12
+        #define APM_FUNC_SET_TIMER_BASED_REQ                0x13
+        #define APM_FUNC_OEM                                0x80
+
+
+        // Class that controls APM via bios
+        // APM: Advanced Power Management
+        class APMController : public SystemComponent
+        {
+        public:
+            bool Enabled = false;
+        public:
+            //Create new APM instance
+            //Only one allowed
+            APMController();
+
+            //Check for APM events to handle
+            void CheckAndHandleEvents();
+
+            //Set power state for a device
+            void SetPowerState(common::uint16_t device, common::uint8_t state);
+
+            //Disable automatic resume on suspend by timer
+            void DisableResumeTimer();
+
+            //Disables the systems resume on ring indicator functionality
+            void DisableRingIndicator();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/components/bochsvbe.h b/kernelz/include/system/components/bochsvbe.h
new file mode 100644
index 0000000..097a13f
--- /dev/null
+++ b/kernelz/include/system/components/bochsvbe.h
@@ -0,0 +1,56 @@
+#ifndef __CACTUSOS__SYSTEM__COMPONENTS__BOCHSVBE_H
+#define __CACTUSOS__SYSTEM__COMPONENTS__BOCHSVBE_H
+
+#include <system/components/graphicsdevice.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        #define VBE_DISPI_BANK_ADDRESS          0xA0000
+        #define VBE_DISPI_BANK_SIZE_KB          64
+
+        #define VBE_DISPI_MAX_XRES              1024
+        #define VBE_DISPI_MAX_YRES              768
+
+        #define VBE_DISPI_IOPORT_INDEX          0x01CE
+        #define VBE_DISPI_IOPORT_DATA           0x01CF
+
+        #define VBE_DISPI_INDEX_ID              0x0
+        #define VBE_DISPI_INDEX_XRES            0x1
+        #define VBE_DISPI_INDEX_YRES            0x2
+        #define VBE_DISPI_INDEX_BPP             0x3
+        #define VBE_DISPI_INDEX_ENABLE          0x4
+        #define VBE_DISPI_INDEX_BANK            0x5
+        #define VBE_DISPI_INDEX_VIRT_WIDTH      0x6
+        #define VBE_DISPI_INDEX_VIRT_HEIGHT     0x7
+        #define VBE_DISPI_INDEX_X_OFFSET        0x8
+        #define VBE_DISPI_INDEX_Y_OFFSET        0x9
+
+        #define VBE_DISPI_ID0                   0xB0C0
+        #define VBE_DISPI_ID1                   0xB0C1
+        #define VBE_DISPI_ID2                   0xB0C2
+        #define VBE_DISPI_ID3                   0xB0C3
+        #define VBE_DISPI_ID4                   0xB0C4
+        #define VBE_DISPI_ID5                   0xB0C5
+
+        #define VBE_DISPI_DISABLED              0x00
+        #define VBE_DISPI_ENABLED               0x01
+        #define VBE_DISPI_VBE_ENABLED           0x40
+        #define VBE_DISPI_LFB_ENABLED           0x40
+        #define VBE_DISPI_NOCLEARMEM            0x80
+
+        #define VBE_DISPI_LFB_PHYSICAL_ADDRESS  0xE0000000
+
+        class BochsVBE :  public GraphicsDevice, public SystemComponent
+        {
+        public:
+            BochsVBE();
+            
+            static bool IsAvailable();
+            bool SelectBestVideoMode();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/components/dma.h b/kernelz/include/system/components/dma.h
new file mode 100644
index 0000000..07f0eb1
--- /dev/null
+++ b/kernelz/include/system/components/dma.h
@@ -0,0 +1,136 @@
+#ifndef __CACTUSOS__SYSTEM__COMPONENTS__DMA_H
+#define __CACTUSOS__SYSTEM__COMPONENTS__DMA_H
+
+// Main source: http://www.brokenthorn.com/Resources/OSDev21.html
+
+#include <system/components/systemcomponent.h>
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        // Slave Registers
+        enum DMA0_IO {
+            DMA0_STATUS_REG = 0x08,
+            DMA0_COMMAND_REG = 0x08,
+            DMA0_REQUEST_REG = 0x09,
+            DMA0_CHANMASK_REG = 0x0a,
+            DMA0_MODE_REG = 0x0b,
+            DMA0_CLEARBYTE_FLIPFLOP_REG = 0x0c,
+            DMA0_TEMP_REG = 0x0d,
+            DMA0_MASTER_CLEAR_REG = 0x0d,
+            DMA0_CLEAR_MASK_REG = 0x0e,
+            DMA0_MASK_REG = 0x0f
+        };
+
+        // Master Registers
+        enum DMA1_IO {
+            DMA1_STATUS_REG = 0xd0,
+            DMA1_COMMAND_REG = 0xd0,
+            DMA1_REQUEST_REG = 0xd2,
+            DMA1_CHANMASK_REG = 0xd4,
+            DMA1_MODE_REG = 0xd6,
+            DMA1_CLEARBYTE_FLIPFLOP_REG = 0xd8,
+            DMA1_INTER_REG = 0xda,
+            DMA1_UNMASK_ALL_REG = 0xdc,
+            DMA1_MASK_REG = 0xde
+        };
+
+        // Slave Channel Registers
+        enum DMA0_CHANNEL_IO {
+            DMA0_CHAN0_ADDR_REG = 0,
+            DMA0_CHAN0_COUNT_REG = 1,
+            DMA0_CHAN1_ADDR_REG = 2,
+            DMA0_CHAN1_COUNT_REG = 3,
+            DMA0_CHAN2_ADDR_REG = 4,
+            DMA0_CHAN2_COUNT_REG = 5,
+            DMA0_CHAN3_ADDR_REG = 6,
+            DMA0_CHAN3_COUNT_REG = 7,
+        };
+
+        // Master Channel Registers
+        enum DMA1_CHANNEL_IO {
+            DMA1_CHAN4_ADDR_REG = 0xc0,
+            DMA1_CHAN4_COUNT_REG = 0xc2,
+            DMA1_CHAN5_ADDR_REG = 0xc4,
+            DMA1_CHAN5_COUNT_REG = 0xc6,
+            DMA1_CHAN6_ADDR_REG = 0xc8,
+            DMA1_CHAN6_COUNT_REG = 0xca,
+            DMA1_CHAN7_ADDR_REG = 0xcc,
+            DMA1_CHAN7_COUNT_REG = 0xce,
+        };
+
+        // Extended Page Address Registers
+        enum DMA0_PAGE_REG {
+
+            DMA_PAGE_EXTRA0 = 0x80,
+            DMA_PAGE_CHAN2_ADDRBYTE2 = 0x81,
+            DMA_PAGE_CHAN3_ADDRBYTE2 = 0x82,
+            DMA_PAGE_CHAN1_ADDRBYTE2 = 0x83,
+            DMA_PAGE_EXTRA1 = 0x84,
+            DMA_PAGE_EXTRA2 = 0x85,
+            DMA_PAGE_EXTRA3 = 0x86,
+            DMA_PAGE_CHAN6_ADDRBYTE2 = 0x87,
+            DMA_PAGE_CHAN7_ADDRBYTE2 = 0x88,
+            DMA_PAGE_CHAN5_ADDRBYTE2 = 0x89,
+            DMA_PAGE_EXTRA4 = 0x8c,
+            DMA_PAGE_EXTRA5 = 0x8d,
+            DMA_PAGE_EXTRA6 = 0x8e,
+            DMA_PAGE_DRAM_REFRESH = 0x8f
+        };
+
+        enum DMA_CMD_REG_MASK {
+
+            DMA_CMD_MASK_MEMTOMEM = 1,
+            DMA_CMD_MASK_CHAN0ADDRHOLD = 2,
+            DMA_CMD_MASK_ENABLE = 4,
+            DMA_CMD_MASK_TIMING = 8,
+            DMA_CMD_MASK_PRIORITY = 0x10,
+            DMA_CMD_MASK_WRITESEL = 0x20,
+            DMA_CMD_MASK_DREQ = 0x40,
+            DMA_CMD_MASK_DACK = 0x80
+        };
+
+        enum DMA_MODE_REG_MASK {
+
+            DMA_MODE_MASK_SEL = 3,
+
+            DMA_MODE_MASK_TRA = 0xc,
+            DMA_MODE_SELF_TEST = 0,
+            DMA_MODE_READ_TRANSFER =4,
+            DMA_MODE_WRITE_TRANSFER = 8,
+
+            DMA_MODE_MASK_AUTO = 0x10,
+            DMA_MODE_MASK_IDEC = 0x20,
+
+            DMA_MODE_MASK = 0xc0,
+            DMA_MODE_TRANSFER_ON_DEMAND= 0,
+            DMA_MODE_TRANSFER_SINGLE = 0x40,
+            DMA_MODE_TRANSFER_BLOCK = 0x80,
+            DMA_MODE_TRANSFER_CASCADE = 0xC0
+        };
+
+        // Controls the DMA Controller chip
+        // Only used for legacy floppy disks
+        class DMAController : public SystemComponent
+        {
+        public:
+            void SetChannelAddress(common::uint8_t channel, common::uint8_t low, common::uint8_t high);
+            void SetChannelCounter(common::uint8_t channel, common::uint8_t low, common::uint8_t high);
+            void SetExternalPageRegister(common::uint8_t reg, common::uint8_t val);
+            void SetChannelMode(common::uint8_t channel, common::uint8_t mode);
+            void ChannelPrepareRead(common::uint8_t channel);
+            void ChannelPrepareWrite(common::uint8_t channel);
+            void MaskChannel(common::uint8_t channel);
+            void UnmaskChannel(common::uint8_t channel);
+            void ResetFlipFlop(int dma);
+            void Reset(int dma);
+            void UnmaskAll(int dma);
+        public:
+            DMAController();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/components/edid.h b/kernelz/include/system/components/edid.h
new file mode 100644
index 0000000..9a29f36
--- /dev/null
+++ b/kernelz/include/system/components/edid.h
@@ -0,0 +1,92 @@
+#ifndef __CACTUSOS__SYSTEM__COMPONENTS__EDID_H
+#define __CACTUSOS__SYSTEM__COMPONENTS__EDID_H
+
+#include <system/components/systemcomponent.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        struct EDIDInfoBlock
+        {
+            common::uint8_t header[8];
+            common::uint16_t manufacturer_id;
+            common::uint16_t product_id;
+            common::uint32_t serial_number;
+            common::uint8_t week_of_manufacture;
+            common::uint8_t year_of_manufacture;
+            common::uint8_t version;
+            common::uint8_t revision;
+
+            common::uint8_t video_input_definition;
+            common::uint8_t max_horizontal_image_size;
+            common::uint8_t max_vertical_image_size;
+            common::uint8_t display_gamma;
+            common::uint8_t feature_support;
+
+            common::uint8_t red_green_lo;
+            common::uint8_t blue_white_lo;
+            common::uint8_t red_x_hi;
+            common::uint8_t red_y_hi;
+            common::uint8_t green_x_hi;
+            common::uint8_t green_y_hi;
+            common::uint8_t blue_x_hi;
+            common::uint8_t blue_y_hi;
+            common::uint8_t white_x_hi;
+            common::uint8_t white_y_hi;
+
+            common::uint8_t established_timings_1;
+            common::uint8_t established_timings_2;
+            common::uint8_t manufacturer_reserved_timings;
+
+            common::uint16_t standard_timings[8];
+
+            struct {
+                common::uint16_t flag; //0 when used as discriptor, otherwise timing
+                common::uint8_t flag2;
+                common::uint8_t dataType;
+                common::uint8_t flag3;
+                common::uint8_t descriptorData[13];
+            } detailed_timings[4];
+
+            common::uint8_t extension_flag;
+            common::uint8_t checksum;
+        } __attribute__((packed));
+
+        struct TimingsInfoBlock
+        {
+            common::uint16_t pixel_clock;
+            /* Only valid if the pixel clock is non-null.  */
+            common::uint8_t horizontal_active_lo;
+            common::uint8_t horizontal_blanking_lo;
+            common::uint8_t horizontal_hi;
+            common::uint8_t vertical_active_lo;
+            common::uint8_t vertical_blanking_lo;
+            common::uint8_t vertical_hi;
+            common::uint8_t horizontal_sync_offset_lo;
+            common::uint8_t horizontal_sync_pulse_width_lo;
+            common::uint8_t vertical_sync_lo;
+            common::uint8_t sync_hi;
+            common::uint8_t horizontal_image_size_lo;
+            common::uint8_t vertical_image_size_lo;
+            common::uint8_t image_size_hi;
+            common::uint8_t horizontal_border;
+            common::uint8_t vertical_border;
+            common::uint8_t flags;
+        } __attribute__((packed));
+
+
+        #define EDID_SUCCES 0x004F
+        
+        class EDID : public SystemComponent
+        {
+        public:
+            EDID();
+
+            void AcquireEDID();
+            void PreferedMode(int* widthPtr, int* heightPtr);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/components/graphicsdevice.h b/kernelz/include/system/components/graphicsdevice.h
new file mode 100644
index 0000000..429aab3
--- /dev/null
+++ b/kernelz/include/system/components/graphicsdevice.h
@@ -0,0 +1,30 @@
+#ifndef __CACTUSOS__SYSTEM__COMPONENTS__GRAPHICSDEVICE_H
+#define __CACTUSOS__SYSTEM__COMPONENTS__GRAPHICSDEVICE_H
+
+#include <system/components/systemcomponent.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class GraphicsDevice
+        {
+        public:
+            common::uint32_t width;
+            common::uint32_t height;
+            common::uint8_t bpp;
+            common::uint32_t framebufferPhys;
+            char* identifier = 0;
+
+            GraphicsDevice(char* name);
+            virtual ~GraphicsDevice();
+            virtual bool SelectBestVideoMode();
+            
+            common::uint32_t GetBufferSize();
+            
+            static GraphicsDevice* GetBestDevice();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/components/pci.h b/kernelz/include/system/components/pci.h
new file mode 100644
index 0000000..c250315
--- /dev/null
+++ b/kernelz/include/system/components/pci.h
@@ -0,0 +1,69 @@
+#ifndef __CACTUSOS__SYSTEM__COMPONENTS__PCI_H
+#define __CACTUSOS__SYSTEM__COMPONENTS__PCI_H
+
+#include <core/port.h>
+#include <common/list.h>
+#include <system/components/systemcomponent.h>
+#include <system/bootconsole.h>
+#include <system/initrd.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        #define PCI_CMDREG_IO   (1<<0)
+        #define PCI_CMDREG_MEM  (1<<1)
+        #define PCI_CMDREG_BM   (1<<2)
+
+        struct PCIDevice
+        {
+            common::uint8_t interrupt;
+            common::uint32_t portBase;
+            
+            common::uint16_t bus;
+            common::uint16_t device;
+            common::uint16_t function;
+
+            common::uint16_t deviceID;
+            common::uint16_t vendorID;
+
+            common::uint8_t classID;
+            common::uint8_t subclassID;
+            common::uint8_t programmingInterfaceID;
+            common::uint8_t revisionID;
+        } __attribute__((packed));
+
+        enum BaseAddressRegisterType
+        {
+            MemoryMapping = 0,
+            InputOutput = 1
+        };
+
+        struct BaseAddressRegister
+        {
+            bool prefetchable;
+            BaseAddressRegisterType type;
+            CactusOS::common::uint32_t size;
+            CactusOS::common::uint64_t address;
+        };
+
+        class PCIController : public SystemComponent
+        {
+        private:
+            bool DeviceHasFunctions(common::uint16_t bus, common::uint16_t device);
+            char* GetClassCodeString(common::uint8_t classID, common::uint8_t subClassID);
+        public:
+            common::uint32_t Read(common::uint16_t bus, common::uint16_t device, common::uint16_t function, common::uint32_t registeroffset);
+            void Write(common::uint16_t bus, common::uint16_t device, common::uint16_t function, common::uint32_t registeroffset, common::uint32_t value);
+            BaseAddressRegister GetBaseAddressRegister(common::uint16_t bus, common::uint16_t device, common::uint16_t function, common::uint16_t bar);
+        public:
+            List<PCIDevice*> deviceList;
+
+            PCIController();
+
+            void PopulateDeviceList();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/components/pit.h b/kernelz/include/system/components/pit.h
new file mode 100644
index 0000000..4941253
--- /dev/null
+++ b/kernelz/include/system/components/pit.h
@@ -0,0 +1,36 @@
+#ifndef __CACTUSOS__CORE__PIT_H
+#define __CACTUSOS__CORE__PIT_H
+
+#include <system/interruptmanager.h>
+#include <system/components/systemcomponent.h>
+#include <core/port.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        #define PIT_FREQUENCY 1000
+
+        class PIT : public SystemComponent, public InterruptHandler
+        {
+        private:
+            volatile common::uint64_t timer_ticks;
+        public:
+            PIT();
+
+            common::uint32_t HandleInterrupt(common::uint32_t esp);
+            void Sleep(common::uint32_t ms);
+
+            //PCSpeaker
+            void PlaySound(common::uint32_t nFrequence);
+            void NoSound();
+            void Beep();
+            void Beep(common::uint32_t freq);
+            void Beep(common::uint32_t freq, common::uint32_t duration);
+
+            common::uint64_t Ticks();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/components/rtc.h b/kernelz/include/system/components/rtc.h
new file mode 100644
index 0000000..fb172c7
--- /dev/null
+++ b/kernelz/include/system/components/rtc.h
@@ -0,0 +1,31 @@
+#ifndef __CACTUSOS__SYSTEM__COMPONENTS__RTC_H
+#define __CACTUSOS__SYSTEM__COMPONENTS__RTC_H
+
+#include <core/port.h>
+#include <system/components/systemcomponent.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        #define CURRENT_YEAR 2020
+
+        class RTC : public SystemComponent
+        {
+        private:
+            bool UpdateInProgress();
+            common::uint8_t ReadRegister(int reg);
+        public:
+            RTC();
+
+            common::uint32_t GetSecond();
+            common::uint32_t GetMinute();
+            common::uint32_t GetHour();
+            common::uint32_t GetDay();
+            common::uint32_t GetMonth();
+            common::uint32_t GetYear();
+        };  
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/components/smbios.h b/kernelz/include/system/components/smbios.h
new file mode 100644
index 0000000..f54dbff
--- /dev/null
+++ b/kernelz/include/system/components/smbios.h
@@ -0,0 +1,299 @@
+#ifndef __CACTUSOS__SYSTEM__SMBIOS_H
+#define __CACTUSOS__SYSTEM__SMBIOS_H
+
+#include <system/components/systemcomponent.h>
+#include <system/bootconsole.h>
+#include <common/string.h>
+#include <common/list.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        enum SMBIOSTableType 
+        {
+            BIOSInformation = 0,
+            SystemInformation = 1,
+            BaseBoardInformation = 2,
+            EnclosureInformation = 3,
+            ProcessorInformation = 4,
+            MemoryControllerInformation = 5,
+            MemoryModuleInformation = 6,
+            CacheInformation = 7,
+            PortConnectorInformation = 8,
+            SystemSlotsInformation = 9,
+            OnBoardDevicesInformation = 10,
+            OEMStrings = 11,
+            SystemConfigurationOptions = 12,
+            BIOSLanguageInformation = 13,
+            GroupAssociations = 14,
+            SystemEventLog = 15,
+            PhysicalMemoryArray = 16,
+            MemoryDevice = 17,
+            MemoryErrorInformation = 18,
+            MemoryArrayMappedAddress = 19,
+            MemoryDeviceMappedAddress = 20,
+            SystemBootInformation = 32,
+            EndOfTable = 127
+        };
+
+        struct SMBIOSTag
+        {
+            common::uint8_t type;
+            common::uint8_t length;
+            common::uint16_t handle;
+        } __attribute__((packed));
+
+        struct SMBIOSBiosInfo : public SMBIOSTag
+        {
+            common::uint8_t vendor;
+            common::uint8_t version;
+            common::uint16_t startSegment;
+            common::uint8_t releaseDate;
+            common::uint8_t romSize;
+            common::uint64_t characteristics;
+            // for 2.4+
+            common::uint8_t extensionChar1;
+            common::uint8_t extensionChar2;
+            common::uint8_t biosMajorRelease;
+            common::uint8_t biosMinorRelease;
+            common::uint8_t controllerMajorRelease;
+            common::uint8_t controllerMinorRelease;
+        } __attribute__((packed));
+
+        struct SMBIOSSystemInfo : public SMBIOSTag
+        {
+            common::uint8_t manufacturer;
+            common::uint8_t productName;
+            common::uint8_t version;
+            common::uint8_t serialNumber;
+
+            struct
+            {
+                common::uint32_t time_low;
+                common::uint16_t time_mid;
+                common::uint16_t timeHiAndVersion;
+                common::uint8_t clockSeqHiAndReserved;
+                common::uint8_t clockSeqLow;
+                common::uint8_t node[6];
+            } uuid;
+
+            common::uint8_t wakeupType;
+
+            common::uint8_t sku;
+            common::uint8_t family;
+        } __attribute__((packed));
+
+        struct SMBIOSBaseBoardInformation : public SMBIOSTag
+        {
+            common::uint8_t manufacturer;
+            common::uint8_t product;
+            common::uint8_t version;
+            common::uint8_t serial;
+            common::uint8_t assertTag;
+            common::uint8_t features;
+            common::uint8_t locationInChassis;
+            common::uint16_t chassisHandle;
+            common::uint8_t boardType;
+            common::uint8_t numObjHandles;
+            common::uint16_t objectHandles[1]; 
+        } __attribute__((packed));
+
+        struct SMBIOSSystemEnclosureInformation : public SMBIOSTag
+        {
+            common::uint8_t manufacturer;
+            common::uint8_t type;
+            common::uint8_t version;
+            common::uint8_t serialNumber;
+            common::uint8_t assetTag;
+            common::uint8_t bootupState;
+            common::uint8_t psuState;
+            common::uint8_t thermalState;
+            common::uint8_t securityStatus;
+            common::uint8_t oemSpecific[4];
+            common::uint8_t height;
+            common::uint8_t numOfPowerCords;
+            common::uint8_t numOfElements;
+            common::uint8_t elementRecordLength;
+
+            struct element
+            {
+                common::uint8_t type;
+                common::uint8_t minimum;
+                common::uint8_t maximum;
+            } elements[1];
+        } __attribute__((packed));
+
+        struct SMBIOSProcessorInformation : public SMBIOSTag
+        {
+            common::uint8_t socketDesignation;
+            common::uint8_t processorType;
+            common::uint8_t processorFamily;
+            common::uint8_t manufacturer;
+            common::uint64_t processorID;
+            common::uint8_t version;
+            common::uint8_t voltage;
+            common::uint16_t clock;
+            common::uint16_t maxSpeed;
+            common::uint16_t currentSpeed;
+            common::uint8_t status;
+            common::uint8_t upgrade;
+            common::uint16_t L1;
+            common::uint16_t L2;
+            common::uint16_t L3;
+
+            //2.3
+            common::uint8_t serialNumber;
+            common::uint8_t assertTag;
+            common::uint8_t partNumber;
+
+            //2.5
+            common::uint8_t totalCores;
+            common::uint8_t activeCores;
+            common::uint8_t threads;
+            common::uint16_t characteristics;
+        } __attribute__((packed));
+
+        struct SMBIOSCacheInformation : public SMBIOSTag
+        {
+            common::uint8_t socketDesignation;
+            common::uint16_t cacheConfiguration;
+            common::uint16_t maximumCacheSize;
+            common::uint16_t installedSize;
+            common::uint16_t supportedSRAMType;
+            common::uint16_t currentSRAMType;
+
+            //2.1+
+            common::uint8_t cacheSpeed;
+            common::uint8_t errorCorrectionType;
+            common::uint8_t systemCacheType;
+            common::uint8_t associativity;
+
+            //3.1+
+            common::uint32_t maximumCacheSize2;
+            common::uint32_t installedSize2;
+        } __attribute__((packed));
+
+        struct SMBIOSSystemSlotInformation : public SMBIOSTag
+        {
+            common::uint8_t slotDesignation;
+            common::uint8_t slotType;
+            common::uint8_t slotDataBusWidth;
+            common::uint8_t currentUsage;
+            common::uint8_t slotLength;
+            common::uint16_t slotID;
+            common::uint8_t slotCharacteristics1;
+
+            //2.1+
+            common::uint8_t slotCharacteristics2;
+
+            //2.6+
+            common::uint16_t segmentGroupNumber;
+            common::uint8_t busNumber;
+            common::uint8_t deviceFunctionNumber;
+
+            //3.2
+            common::uint8_t dataBusWidth;
+        } __attribute__((packed));
+
+        struct SMBIOSPhysicalMemoryArray : public SMBIOSTag
+        {
+            //2.1+
+            common::uint8_t location;
+            common::uint8_t use;
+            common::uint8_t memoryErrorCorrection;
+            common::uint32_t maximumCapacity;
+            common::uint16_t memoryErrorInformationHandle;
+            common::uint16_t numberOfMemoryDevices;
+
+            //2.7+
+            common::uint64_t extendedMaximumCapacity;
+        } __attribute__((packed));
+
+        struct SMBIOSMemoryDevice : public SMBIOSTag
+        {
+            //2.1+
+            common::uint16_t memoryArrayHandle;
+            common::uint16_t memoryErrorInformationHandle;
+            common::uint16_t totalWidth;
+            common::uint16_t dataWidth;
+            common::uint16_t size;
+            common::uint8_t formFactor;
+            common::uint8_t deviceSet;
+            common::uint8_t deviceLocator;
+            common::uint8_t bankLocator;
+            common::uint8_t memoryType;
+            common::uint16_t typeDetail;
+
+            //2.3+
+            common::uint16_t speed;
+            common::uint8_t manufacturer;
+            common::uint8_t serialNumber;
+            common::uint8_t assetTag;
+            common::uint8_t partNumber;
+
+            //2.6+
+            common::uint8_t attributes;
+
+            //2.7+
+            common::uint32_t extendedSize;
+            common::uint16_t configuredMemorySpeed;
+
+            //2.8+
+            common::uint16_t minimumVoltage;
+            common::uint16_t maximumVoltage;
+            common::uint16_t configuredVoltage;
+
+            //3.2+
+            common::uint8_t memoryTechnology;
+            common::uint16_t memoryOperatingModeCapability;
+            common::uint8_t firwareVersion;
+            common::uint16_t moduleManufacturerID;
+            common::uint16_t moduleProductID;
+            common::uint16_t memorySubsystemControllerManufacturerID;
+            common::uint16_t memorySubsystemControllerProductID;
+            common::uint64_t nonVolatileSize;
+            common::uint64_t volatileSize;
+            common::uint64_t cacheSize;
+            common::uint64_t logicalSize;
+        } __attribute__((packed));
+
+        struct SMBIOSBootInformation : public SMBIOSTag
+        {
+            common::uint8_t reserved[6];
+            common::uint8_t bootStatus;
+        } __attribute__((packed));
+
+        struct SMBIOSEntryPoint
+        {
+            char EntryPointString[4];               //This is _SM_
+            common::uint8_t Checksum;               //This value summed with all the values of the table, should be 0 (overflow)
+            common::uint8_t Length;                 //Length of the Entry Point Table. Since version 2.1 of SMBIOS, this is 0x1F
+            common::uint8_t MajorVersion;           //Major Version of SMBIOS
+            common::uint8_t MinorVersion;           //Minor Version of SMBIOS
+            common::uint16_t MaxStructureSize;      //Maximum size of a SMBIOS Structure (we will se later)
+            common::uint8_t EntryPointRevision;     //...
+            char FormattedArea[5];                  //...
+            char EntryPointString2[5];              //This is _DMI_
+            common::uint8_t Checksum2;              //Checksum for values from EntryPointString2 to the end of table
+            common::uint16_t TableLength;           //Length of the Table containing all the structures
+            common::uint32_t TableAddress;	        //Address of the Table
+            common::uint16_t NumberOfStructures;    //Number of structures in the table
+            common::uint8_t BCDRevision;            //Unused
+        } __attribute__((packed));
+
+        class SMBIOS : public SystemComponent
+        {
+        private:
+            void* TableAddress = 0;
+
+            List<char*> ExtractStrings(SMBIOSTag* header);
+
+            char* CopyString(char* src);
+        public:
+            SMBIOS();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/components/systemcomponent.h b/kernelz/include/system/components/systemcomponent.h
new file mode 100644
index 0000000..93c5369
--- /dev/null
+++ b/kernelz/include/system/components/systemcomponent.h
@@ -0,0 +1,24 @@
+#ifndef __CACTUSOS__SYSTEM__COMPONENTS_H
+#define __CACTUSOS__SYSTEM__COMPONENTS_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class SystemComponent
+        {
+        private:
+            char* Name;
+            char* Description;
+        public:
+            SystemComponent(char* name = 0, char* description = 0);
+
+            char* GetComponentName();
+            char* GetComponentDescription();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/components/vesa.h b/kernelz/include/system/components/vesa.h
new file mode 100644
index 0000000..3cbfb81
--- /dev/null
+++ b/kernelz/include/system/components/vesa.h
@@ -0,0 +1,85 @@
+#ifndef __CACTUSOS__SYSTEM__COMPONENTS__VESA_H
+#define __CACTUSOS__SYSTEM__COMPONENTS__VESA_H
+
+#include <common/types.h>
+#include <system/virtual8086/VM86Manager.h>
+#include <system/components/graphicsdevice.h>
+#include <core/virtualmemory.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        typedef struct
+        {
+            uint16_t A;
+            uint16_t B;
+        } __attribute__((packed)) Real_Pointer;
+
+        struct VESAControllerInfo
+        {
+            char Signature[4];
+            common::uint16_t Version;
+            Real_Pointer OemStringPtr;
+            common::uint32_t Capabilities;
+            Real_Pointer VideoModePtr;
+            common::uint16_t TotalMemory;
+            common::uint16_t OemSoftwareRev;
+            Real_Pointer OemVendorNamePtr;
+            Real_Pointer OemProductNamePtr;
+            Real_Pointer OemProductRevPtr;
+        } __attribute__((packed));
+
+        struct VESAModeInfo
+        {
+            common::uint16_t    ModeAttributes;
+            common::uint8_t     WinAAttributes;
+            common::uint8_t     WinBAttributes;
+            common::uint16_t    WinGranularity;
+            common::uint16_t    WinSize;
+            common::uint16_t    WinASegment;
+            common::uint16_t    WinBSegment;
+            common::uint32_t    WinFuncPtr;
+            common::uint16_t    BytesPerScanLine;
+            common::uint16_t    XResolution;
+            common::uint16_t    YResolution;
+            common::uint8_t     XCharSize;
+            common::uint8_t     YCharSize;
+            common::uint8_t     NumberOfPlanes;
+            common::uint8_t     BitsPerPixel;
+            common::uint8_t     NumberOfBanks;
+            common::uint8_t     MemoryModel;
+            common::uint8_t     BankSize;
+            common::uint8_t     NumberOfImagePages;
+            common::uint8_t     Reserved_page;
+            common::uint8_t     RedMaskSize;
+            common::uint8_t     RedMaskPos;
+            common::uint8_t     GreenMaskSize;
+            common::uint8_t     GreenMaskPos;
+            common::uint8_t     BlueMaskSize;
+            common::uint8_t     BlueMaskPos;
+            common::uint8_t     ReservedMaskSize;
+            common::uint8_t     ReservedMaskPos;
+            common::uint8_t     DirectColorModeInfo;
+            common::uint32_t    PhysBasePtr;
+            common::uint32_t    OffScreenMemOffset;
+            common::uint16_t    OffScreenMemSize;
+            common::uint8_t     Reserved[206];
+        } __attribute__ ((packed));
+
+        class VESA : public GraphicsDevice, public SystemComponent
+        {
+        private:
+            Virtual8086Manager* virtual8086Manager;
+        public:
+            VESAModeInfo currentVideoMode;
+            VESA(Virtual8086Manager* vm86);
+
+            VESAModeInfo* GetModeInfo(common::uint16_t mode);
+            void SetVideoMode(common::uint16_t mode);
+            bool SelectBestVideoMode();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/debugger.h b/kernelz/include/system/debugger.h
new file mode 100644
index 0000000..7ee9bcf
--- /dev/null
+++ b/kernelz/include/system/debugger.h
@@ -0,0 +1,70 @@
+#ifndef __CACTUSOS__SYSTEM__DEBUGGER_H
+#define __CACTUSOS__SYSTEM__DEBUGGER_H
+
+#include <core/registers.h>
+#include <common/types.h>
+#include <common/list.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        // Entry in a symbol dump
+        typedef struct
+        {
+            char*               name;
+            common::uint32_t    address;
+            char                type;
+        } GenericSymbol_t;
+
+        // Entry in a stacktrace
+        typedef struct StackFrame {
+            struct StackFrame*  next;
+            common::uint32_t    addr;
+        } __attribute__((packed)) StackFrame_t;
+
+
+        // A debugging class that works of a file with symbol definitions
+        // Keeping this a class makes it possible to use this for userspace processes as well (if the symbol file is generated of course)
+        class SymbolDebugger
+        {
+        private:
+            // List of all known symbols
+            List<GenericSymbol_t> symbolTable;
+
+            // Buffer to store debug commands
+            char messageBuffer[200] = {0};
+
+            // Address which we can map to physical regions
+            uint32_t pageAccessAddress = 0;
+
+            bool isKernel = false;
+            int serialIndex = 0;
+
+            const char* FindSymbol(uint32_t address, uint32_t* offset);
+
+            void HandleDebugCommand(int size);
+            void PrintPageItem(void* item, bool table, uint16_t pdIndex, uint16_t ptIndex);
+        public:
+            // Initialize debugger by loading symbol file from disk
+            SymbolDebugger(char* symFile, bool kernel = false);
+
+            // Print a stacktrace to console of given cpu state
+            void Stacktrace(core::CPUState* esp);
+            
+            // Perform a update on statistics and send info to debugger via serial
+            void Update();
+
+            // Send a update on stats to debugging host
+            void SendUpdateToHost();
+
+            // Print a memory dump to the console
+            void PrintMemoryDump(uint32_t address, uint32_t size, bool virtMemory);
+
+            // Print all page tables to the console
+            void PrintPageTables(int pid = -1);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/disks/disk.h b/kernelz/include/system/disks/disk.h
new file mode 100644
index 0000000..d461639
--- /dev/null
+++ b/kernelz/include/system/disks/disk.h
@@ -0,0 +1,41 @@
+#ifndef __CACTUSOS__SYSTEM__DISKS__DISK_H
+#define __CACTUSOS__SYSTEM__DISKS__DISK_H
+
+#include <common/types.h>
+
+#include <system/disks/diskcontroller.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class DiskController;
+
+        enum DiskType
+        {
+            HardDisk,
+            USBDisk,
+            Floppy,
+            CDROM
+        };
+
+        class Disk
+        {
+        public:
+            DiskController* controller;         // Which controller is controling this disk device
+            common::uint32_t controllerIndex;   // The real number for the disk on the controller
+            char* identifier = 0;               // Disk Identifier
+            DiskType type;              // Type of disk
+            common::uint64_t size;      // Size of disk in bytes
+            common::uint32_t numBlocks; // Number of data blocks
+            common::uint32_t blockSize; // Size of one block of data
+
+            Disk(common::uint32_t controllerIndex, DiskController* controller, DiskType type, common::uint64_t size, common::uint32_t blocks, common::uint32_t blocksize);
+            
+            virtual char ReadSector(common::uint32_t lba, common::uint8_t* buf);          
+            virtual char WriteSector(common::uint32_t lba, common::uint8_t* buf);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/disks/diskcontroller.h b/kernelz/include/system/disks/diskcontroller.h
new file mode 100644
index 0000000..16436bf
--- /dev/null
+++ b/kernelz/include/system/disks/diskcontroller.h
@@ -0,0 +1,29 @@
+#ifndef __CACTUSOS__SYSTEM__DISKS__DISKCONTROLLER_H
+#define __CACTUSOS__SYSTEM__DISKS__DISKCONTROLLER_H
+
+
+#include <common/types.h>
+#include <common/convert.h>
+#include <common/memoryoperations.h>
+
+#include <system/disks/disk.h>
+#include <system/disks/diskmanager.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class DiskController
+        {       
+        public:
+            DiskController();
+
+            virtual char ReadSector(common::uint16_t drive, common::uint32_t lba, common::uint8_t* buf);
+            virtual char WriteSector(common::uint16_t drive, common::uint32_t lba, common::uint8_t* buf);   
+            virtual bool EjectDrive(common::uint8_t drive);         
+        };
+    }
+}
+
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/disks/diskmanager.h b/kernelz/include/system/disks/diskmanager.h
new file mode 100644
index 0000000..595bd79
--- /dev/null
+++ b/kernelz/include/system/disks/diskmanager.h
@@ -0,0 +1,63 @@
+#ifndef __CACTUSOS__SYSTEM__DISKS__DISKMANAGER_H
+#define __CACTUSOS__SYSTEM__DISKS__DISKMANAGER_H
+
+
+#include <common/types.h>
+#include <common/convert.h>
+#include <common/string.h>
+#include <common/memoryoperations.h>
+#include <common/list.h>
+
+#include <system/bootconsole.h>
+#include <system/disks/disk.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        struct BiosDriveParameters
+        {
+            common::uint16_t bufLen;
+            common::uint16_t infoFlags;
+            common::uint32_t cilinders;
+            common::uint32_t heads;
+            common::uint32_t sectorsPerTrack;
+            common::uint64_t totalSectors;
+            common::uint16_t bytesPerSector;
+
+            common::uint32_t eddParameters;
+
+            common::uint16_t signature;
+            common::uint8_t  devPathLen;
+            common::uint8_t  reserved1[3];
+            char             hostBusName[4];
+            char             interfaceName[8];
+            common::uint8_t  interfacePath[8];
+            common::uint8_t  devicePath[8];
+            common::uint8_t  reserved2;
+            common::uint8_t  checksum;
+        } __attribute__((packed));
+
+        class Disk;
+        class DiskManager
+        {
+        public:
+            List<Disk*> allDisks;
+
+            DiskManager();
+
+            //Add disk to system and check for filesystems
+            void AddDisk(Disk* disk);
+            //Remove disk from system and unmount filesystems
+            void RemoveDisk(Disk* disk);
+
+            char ReadSector(common::uint16_t drive, common::uint32_t lba, common::uint8_t* buf);
+            char WriteSector(common::uint16_t drive, common::uint32_t lba, common::uint8_t* buf);
+
+            BiosDriveParameters* GetDriveInfoBios(common::uint8_t drive);
+        };
+    }
+}
+
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/disks/partitionmanager.h b/kernelz/include/system/disks/partitionmanager.h
new file mode 100644
index 0000000..f078c31
--- /dev/null
+++ b/kernelz/include/system/disks/partitionmanager.h
@@ -0,0 +1,53 @@
+#ifndef __CACTUSOS__SYSTEM__DISKS__PARTITIONMANAGER_H
+#define __CACTUSOS__SYSTEM__DISKS__PARTITIONMANAGER_H
+
+#include <system/disks/diskmanager.h>
+#include <system/vfs/vfsmanager.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        struct PartitionTableEntry
+        {
+            common::uint8_t bootable;
+
+            common::uint8_t start_head;
+            common::uint8_t start_sector : 6;
+            common::uint16_t start_cylinder : 10;
+
+            common::uint8_t partition_id;
+
+            common::uint8_t end_head;
+            common::uint8_t end_sector : 6;
+            common::uint16_t end_cylinder : 10;
+            
+            common::uint32_t start_lba;
+            common::uint32_t length;
+        } __attribute__((packed));
+        
+
+        struct MasterBootRecord
+        {
+            common::uint8_t bootloader[440];
+            common::uint32_t signature;
+            common::uint16_t unused;
+            
+            PartitionTableEntry primaryPartitions[4];
+            
+            common::uint16_t magicnumber;
+        } __attribute__((packed));
+
+        class PartitionManager
+        {
+        private:
+            //Check partition type and assign filesystem driver if available
+            static void AssignVFS(PartitionTableEntry partition, Disk* disk);
+        public:
+            //Read partition descriptor of disk and assign fileysysem if possible
+            static void DetectAndLoadFilesystem(Disk* disk);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/disk/ahci/ahcicontroller.h b/kernelz/include/system/drivers/disk/ahci/ahcicontroller.h
new file mode 100644
index 0000000..c055ef3
--- /dev/null
+++ b/kernelz/include/system/drivers/disk/ahci/ahcicontroller.h
@@ -0,0 +1,56 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__DISK_CONTROLLERS__AHCI_H
+#define __CACTUSOS__SYSTEM__DRIVERS__DISK_CONTROLLERS__AHCI_H
+
+#include <system/drivers/driver.h>
+#include <system/components/pci.h>
+#include <system/interruptmanager.h>
+#include <system/drivers/disk/ahci/ahciport.h>
+
+#include <system/disks/diskcontroller.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            class AHCIController : public Driver, public InterruptHandler, public DiskController
+            {
+            private:
+                // Array of ports that are present on this controller
+                AHCIPort* ports[32];
+
+                PCIDevice* pciDevice = 0;
+
+                uint32_t regBase = 0;
+                int32_t  portCount = 0;
+
+                // Read AHCI Register from memory location
+                inline uint32_t readRegister(uint32_t offset);
+
+                // Write a value to an AHCI Register
+                inline void writeRegister(uint32_t offset, uint32_t value);
+            
+                // Wait for a specific bit to be clear in a register
+                inline bool waitForClear(uint32_t reg, uint32_t bits, uint32_t timeout);
+
+                // Wait for a specific bit to be set in a register
+                inline bool waitForSet(uint32_t reg, uint32_t bits, uint32_t timeout);
+            public:
+                AHCIController(PCIDevice* device);
+
+                bool Initialize() override;
+                bool Reset();
+
+                common::uint32_t HandleInterrupt(common::uint32_t esp) override;
+
+                // DiskController Functions
+                char ReadSector(common::uint16_t drive, common::uint32_t lba, common::uint8_t* buf) override;
+                char WriteSector(common::uint16_t drive, common::uint32_t lba, common::uint8_t* buf) override;
+                bool EjectDrive(common::uint8_t drive) override;
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/disk/ahci/ahcidefs.h b/kernelz/include/system/drivers/disk/ahci/ahcidefs.h
new file mode 100644
index 0000000..ac0483d
--- /dev/null
+++ b/kernelz/include/system/drivers/disk/ahci/ahcidefs.h
@@ -0,0 +1,283 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__AHCIDEFS_H
+#define __CACTUSOS__SYSTEM__DRIVERS__AHCIDEFS_H
+
+#include <system/drivers/driver.h>
+#include <system/components/pci.h>
+#include <system/interruptmanager.h>
+
+#include <system/disks/diskcontroller.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            /////////////////////
+            // AHCI Port registers
+            /////////////////////
+
+            #define AHCI_PORTREG_CMDLISTBASE    0x00    // 0x00, command list base address, 1K-byte aligned               
+            #define AHCI_PORTREG_CMDLISTBASE2   0x04    // 0x04, command list base address upper 32 bits              
+            #define AHCI_PORTREG_FISLISTBASE    0x08    // 0x08, FIS base address, 256-byte aligned               
+            #define AHCI_PORTREG_FISLISTBASE2   0x0C    // 0x0C, FIS base address upper 32 bits              
+            #define AHCI_PORTREG_INTSTATUS      0x10    // 0x10, interrupt status         
+            #define AHCI_PORTREG_INTENABLE      0x14    // 0x14, interrupt enable         
+            #define AHCI_PORTREG_CMDANDSTATUS   0x18    // 0x18, command and status              
+            #define AHCI_PORTREG_RESERVED0      0x1C    // 0x1C, Reserved         
+            #define AHCI_PORTREG_TASKFILE       0x20    // 0x20, task file data          
+            #define AHCI_PORTREG_SIGNATURE      0x24    // 0x24, signature         
+            #define AHCI_PORTREG_SATASTATUS     0x28    // 0x28, SATA status (SCR0:SStatus)            
+            #define AHCI_PORTREG_SATACTRL       0x2C    // 0x2C, SATA control (SCR2:SControl)          
+            #define AHCI_PORTREG_SATAERROR      0x30    // 0x30, SATA error (SCR1:SError)         
+            #define AHCI_PORTREG_SATAACTIVE     0x34    // 0x34, SATA active (SCR3:SActive)            
+            #define AHCI_PORTREG_COMMANDISSUE   0x38    // 0x38, command issue              
+            #define AHCI_PORTREG_SATANOTIFY     0x3C    // 0x3C, SATA notification (SCR4:SNotification)            
+            #define AHCI_PORTREG_FISSWITCHCTRL  0x40    // 0x40, FIS-based switch control
+            #define AHCI_PORTREG_SIZE           0x80    // Size of port registers in total             
+
+            /////////////////////
+            // AHCI General registers
+            /////////////////////
+
+            #define AHCI_REG_HOSTCAP            0x00    // 0x00, Host capability     
+            #define AHCI_REG_GLOBALCONTROL      0x04    // 0x04, Global host control    
+            #define AHCI_REG_INTSTATUS          0x08    // 0x08, Interrupt status    
+            #define AHCI_REG_PORTIMPLEMENTED    0x0C    // 0x0C, Port implemented    
+            #define AHCI_REG_VERSION            0x10    // 0x10, Version    
+            #define AHCI_REG_CCC_CTL            0x14    // 0x14, Command completion coalescing control    
+            #define AHCI_REG_CCC_PTS            0x18    // 0x18, Command completion coalescing ports    
+            #define AHCI_REG_ENCLOSURE_LOC      0x1C    // 0x1C, Enclosure management location    
+            #define AHCI_REG_ENCLOSURE_CTRL     0x20    // 0x20, Enclosure management control    
+            #define AHCI_REG_HOSTCAP2           0x24    // 0x24, Host capabilities extended    
+            #define AHCI_REG_BIOSHANDOFF        0x28    // 0x28, BIOS/OS handoff control and status    
+            #define AHCI_REG_PORTBASE           0x100   // 0x100 - 0x10FF, Port control registers
+
+            #define HBA_PORT_DET_MASK		0x0000000f	// Device Detection
+            #define SSTS_PORT_DET_NODEV		0x00000000	// no device detected
+            #define SSTS_PORT_DET_NOPHY		0x00000001	// device present but PHY not est.
+            #define SSTS_PORT_DET_PRESENT	0x00000003	// device present and PHY est.
+            #define SSTS_PORT_DET_OFFLINE	0x00000004	// device offline due to disabled
+            #define SCTL_PORT_DET_NOINIT	0x00000000	// no initalization request
+            #define SCTL_PORT_DET_INIT		0x00000001	// perform interface initalization
+            #define SCTL_PORT_DET_DISABLE	0x00000004	// disable phy
+
+            // Serial ATA Status and control
+            #define HBA_PORT_IPM_MASK		0x00000f00	// Interface Power Management
+            #define SSTS_PORT_IPM_ACTIVE	0x00000100	// active state
+            #define SSTS_PORT_IPM_PARTIAL	0x00000200	// partial state
+            #define SSTS_PORT_IPM_SLUMBER	0x00000600	// slumber power management state
+            #define SSTS_PORT_IPM_DEVSLEEP	0x00000800	// devsleep power management state
+            #define SCTL_PORT_IPM_NORES		0x00000000	// no power restrictions
+            #define SCTL_PORT_IPM_NOPART	0x00000100	// no transitions to partial
+            #define SCTL_PORT_IPM_NOSLUM	0x00000200	// no transitions to slumber
+
+            #define	SATA_SIG_ATA	0x00000101	// SATA drive
+            #define	SATA_SIG_ATAPI	0xEB140101	// SATAPI drive
+            #define	SATA_SIG_SEMB	0xC33C0101	// Enclosure management bridge
+            #define	SATA_SIG_PM	    0x96690101	// Port multiplier
+
+            #define AHCI_DEV_NULL 0
+            #define AHCI_DEV_SATA 1
+            #define AHCI_DEV_SEMB 2
+            #define AHCI_DEV_PM 3
+            #define AHCI_DEV_SATAPI 4
+
+            #define AHCI_PORT_DET_NODEV		0x00000000	// no device detected
+            #define AHCI_PORT_DET_NOPHY		0x00000001	// device present but PHY not est.
+            #define AHCI_PORT_DET_PRESENT	0x00000003	// device present and PHY est.
+            #define AHCI_PORT_DET_OFFLINE	0x00000004	// device offline due to disabled
+            #define AHCI_PORT_DET_NOINIT	0x00000000	// no initalization request
+            #define AHCI_PORT_DET_INIT		0x00000001	// perform interface initalization
+            #define AHCI_PORT_DET_DISABLE	0x00000004	// disable phy
+
+            #define HBA_PORT_IPM_ACTIVE 1
+        
+            enum {
+                CAP_S64A		= (1U << 31),	// Supports 64-bit Addressing
+                CAP_SNCQ		= (1 << 30),	// Supports Native Command Queuing
+                CAP_SSNTF		= (1 << 29),	// Supports SNotification Register
+                CAP_SMPS		= (1 << 28),	// Supports Mechanical Presence Switch
+                CAP_SSS			= (1 << 27),	// Supports Staggered Spin-up
+                CAP_SALP		= (1 << 26),	// Supports Aggressive Link Power Management
+                CAP_SAL			= (1 << 25),	// Supports Activity LED
+                CAP_SCLO		= (1 << 24),	// Supports Command List Override
+                CAP_ISS_MASK	= 0xf,			// Interface Speed Support
+                CAP_ISS_SHIFT	= 20,
+                CAP_SNZO		= (1 << 19),	// Supports Non-Zero DMA Offsets
+                CAP_SAM			= (1 << 18),	// Supports AHCI mode only
+                CAP_SPM			= (1 << 17),	// Supports Port Multiplier
+                CAP_FBSS		= (1 << 16),	// FIS-based Switching Supported
+                CAP_PMD			= (1 << 15),	// PIO Multiple DRQ Block
+                CAP_SSC			= (1 << 14),	// Slumber State Capable
+                CAP_PSC			= (1 << 13),	// Partial State Capable
+                CAP_NCS_MASK	= 0x1f,			// Number of Command Slots
+                                                // (zero-based number)
+                CAP_NCS_SHIFT	= 8,
+                CAP_CCCS		= (1 << 7),		// Command Completion Coalescing Supported
+                CAP_EMS			= (1 << 6),		// Enclosure Management Supported
+                CAP_SXS			= (1 << 5),		// Supports External SATA
+                CAP_NP_MASK		= 0x1f,			// Number of Ports (zero-based number)
+                CAP_NP_SHIFT	= 0,
+            };
+
+            enum {
+                CAP2_DESO		= (1 << 5),		// DevSleep Entrance from Slumber Only
+                CAP2_SADM		= (1 << 4),		// Supports Aggressive Device Sleep
+                                                // Management
+                CAP2_SDS		= (1 << 3),		// Supports Device Sleep
+                CAP2_APST		= (1 << 2),		// Automatic Partial to Slumber Transitions
+                CAP2_NVMP		= (1 << 1),		// NVMHCI Present
+                CAP2_BOH		= (1 << 0),		// BIOS/OS Handoff
+            };
+
+            typedef enum
+            {
+                FIS_TYPE_REG_H2D	= 0x27,	// Register FIS - host to device
+                FIS_TYPE_REG_D2H	= 0x34,	// Register FIS - device to host
+                FIS_TYPE_DMA_ACT	= 0x39,	// DMA activate FIS - device to host
+                FIS_TYPE_DMA_SETUP	= 0x41,	// DMA setup FIS - bidirectional
+                FIS_TYPE_DATA		= 0x46,	// Data FIS - bidirectional
+                FIS_TYPE_BIST		= 0x58,	// BIST activate FIS - bidirectional
+                FIS_TYPE_PIO_SETUP	= 0x5F,	// PIO setup FIS - device to host
+                FIS_TYPE_DEV_BITS	= 0xA1,	// Set device bits FIS - device to host
+            } FIS_TYPE;
+
+            enum {
+                PORT_CMD_ICC_ACTIVE		= (1 << 28),	// Interface Communication control
+                PORT_CMD_ICC_SLUMBER	= (6 << 28),	// Interface Communication control
+                PORT_CMD_ICC_MASK		= (0xf<<28),	// Interface Communication control
+                PORT_CMD_ATAPI	= (1 << 24),	// Device is ATAPI
+                PORT_CMD_CR		= (1 << 15),	// Command List Running (DMA active)
+                PORT_CMD_FR		= (1 << 14),	// FIS Receive Running
+                PORT_CMD_FRE	= (1 << 4),		// FIS Receive Enable
+                PORT_CMD_CLO	= (1 << 3),		// Command List Override
+                PORT_CMD_POD	= (1 << 2),		// Power On Device
+                PORT_CMD_SUD	= (1 << 1),		// Spin-up Device
+                PORT_CMD_ST		= (1 << 0),		// Start DMA
+            };
+
+
+            enum {
+                PORT_INT_CPD	= (1 << 31),	// Cold Presence Detect Status/Enable
+                PORT_INT_TFE	= (1 << 30),	// Task File Error Status/Enable
+                PORT_INT_HBF	= (1 << 29),	// Host Bus Fatal Error Status/Enable
+                PORT_INT_HBD	= (1 << 28),	// Host Bus Data Error Status/Enable
+                PORT_INT_IF		= (1 << 27),	// Interface Fatal Error Status/Enable
+                PORT_INT_INF	= (1 << 26),	// Interface Non-fatal Error Status/Enable
+                PORT_INT_OF		= (1 << 24),	// Overflow Status/Enable
+                PORT_INT_IPM	= (1 << 23),	// Incorrect Port Multiplier Status/Enable
+                PORT_INT_PRC	= (1 << 22),	// PhyRdy Change Status/Enable
+                PORT_INT_DI		= (1 << 7),		// Device Interlock Status/Enable
+                PORT_INT_PC		= (1 << 6),		// Port Change Status/Enable
+                PORT_INT_DP		= (1 << 5),		// Descriptor Processed Interrupt
+                PORT_INT_UF		= (1 << 4),		// Unknown FIS Interrupt
+                PORT_INT_SDB	= (1 << 3),		// Set Device Bits FIS Interrupt
+                PORT_INT_DS		= (1 << 2),		// DMA Setup FIS Interrupt
+                PORT_INT_PS		= (1 << 1),		// PIO Setup FIS Interrupt
+                PORT_INT_DHR	= (1 << 0),		// Device to Host Register FIS Interrupt
+            };
+
+            #define PORT_INT_ERROR	(PORT_INT_TFE | PORT_INT_HBF | PORT_INT_HBD \
+                                        | PORT_INT_IF | PORT_INT_INF | PORT_INT_OF \
+                                        | PORT_INT_IPM | PORT_INT_PRC | PORT_INT_PC \
+                                        | PORT_INT_UF)
+
+            #define PORT_INT_MASK	(PORT_INT_ERROR | PORT_INT_DP | PORT_INT_SDB \
+                                        | PORT_INT_DS | PORT_INT_PS | PORT_INT_DHR)
+
+            typedef struct {
+                uint32_t flags;
+                uint32_t byteCount;             // Physical Region Descriptor Byte Count (PRDBC)
+                uint32_t cmdTableAddress;       // Command Table Descriptor Base Address
+                uint32_t cmdTableAddressHigh;   // Command Table Descriptor Base Address Upper 32-bits
+                uint32_t resv[4];               // Reserved
+            } __attribute__((packed)) a_commandHeader_t;
+
+            typedef struct
+            {
+                uint32_t dataBase;		    // Data base address
+                uint32_t dataBaseHigh;		// Data base address upper 32 bits
+                uint32_t rsv0;		        // Reserved
+            
+                // DW3
+                uint32_t byteCount  : 22;   // Byte count, 4M max
+                uint32_t rsv1       : 9;	// Reserved
+                uint32_t ioc        : 1;	// Interrupt on completion
+            } __attribute__((packed)) a_prdtEntry_t;
+
+            typedef struct
+            {
+                // 0x00
+                uint8_t fis[64];	// Command FIS
+            
+                // 0x40
+                uint8_t cmd[16];	// ATAPI command, 12 or 16 bytes
+            
+                // 0x50
+                uint8_t rsv[48];	// Reserved
+            
+                // 0x80
+                a_prdtEntry_t prdt_entry[1]; // Physical region descriptor table entries, 0 ~ 65535
+            } __attribute__((packed)) a_commandTable_t;
+
+            typedef struct
+            {
+                // DWORD 0
+                uint8_t  fis_type;	// FIS_TYPE_REG_H2D
+            
+                uint8_t  pmport:4;	// Port multiplier
+                uint8_t  rsv0:3;	// Reserved
+                uint8_t  c:1;		// 1: Command, 0: Control
+            
+                uint8_t  command;	// Command register
+                uint8_t  featurel;	// Feature register, 7:0
+            
+                // DWORD 1
+                uint8_t  lba0;		// LBA low register, 7:0
+                uint8_t  lba1;		// LBA mid register, 15:8
+                uint8_t  lba2;		// LBA high register, 23:16
+                uint8_t  device;		// Device register
+            
+                // DWORD 2
+                uint8_t  lba3;		// LBA register, 31:24
+                uint8_t  lba4;		// LBA register, 39:32
+                uint8_t  lba5;		// LBA register, 47:40
+                uint8_t  featureh;	// Feature register, 15:8
+            
+                // DWORD 3
+                uint8_t  countl;		// Count register, 7:0
+                uint8_t  counth;		// Count register, 15:8
+                uint8_t  icc;		// Isochronous command completion
+                uint8_t  control;	// Control register
+            
+                // DWORD 4
+                uint8_t  rsv1[4];	// Reserved
+            } __attribute__((packed)) FIS_REG_H2D;
+
+            typedef struct {
+                uint8_t	dmaSetup[0x1c];	    // DMA Setup FIS
+                
+                uint8_t	res1[0x04];
+                
+                uint8_t	pioSetup[0x14];	    // PIO Setup FIS
+                
+                uint8_t	res2[0x0c];
+                
+                uint8_t	d2hRegister[0x14];	// D2H Register FIS
+                
+                uint8_t	res3[0x04];
+                
+                uint8_t	devBits[0x08];	    // Set Device Bits FIS
+                uint8_t	unknown[0x40];		// Unknown FIS
+                
+                uint8_t	res4[0x60];
+            }  __attribute__((packed)) a_fis_t;
+
+            #define PRD_TABLE_ENTRY_COUNT 168
+            #define COMMAND_LIST_COUNT 32
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/disk/ahci/ahciport.h b/kernelz/include/system/drivers/disk/ahci/ahciport.h
new file mode 100644
index 0000000..81f98da
--- /dev/null
+++ b/kernelz/include/system/drivers/disk/ahci/ahciport.h
@@ -0,0 +1,87 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__DISK_CONTROLLERS__AHCIPORT_H
+#define __CACTUSOS__SYSTEM__DRIVERS__DISK_CONTROLLERS__AHCIPORT_H
+
+#include <system/drivers/driver.h>
+#include <system/components/pci.h>
+#include <system/interruptmanager.h>
+#include <system/drivers/disk/ahci/ahcicontroller.h>
+#include <system/drivers/disk/ahci/ahcidefs.h>
+
+#include <system/disks/diskcontroller.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            class AHCIController;
+            class AHCIPort
+            {
+            private:
+                // Memory base of this specific port
+                uint32_t portBase = 0;
+
+                // Controller to which the port belongs
+                AHCIController* parent = 0;
+
+                a_commandHeader_t* commandList = 0;
+                uint32_t commandListPhys = 0;
+
+                a_fis_t* fis = 0;
+                uint32_t fisPhys = 0;
+
+                int index = -1;
+                bool isATATPI = false;
+                bool useLBA48 = false;
+            private:
+                // Read Port Register from memory location
+                inline uint32_t readRegister(uint32_t offset);
+
+                // Write a value to an Port Register
+                inline void writeRegister(uint32_t offset, uint32_t value);
+
+                // Wait for a specific bit to be clear in a register
+                inline bool waitForClear(uint32_t reg, uint32_t bits, uint32_t timeout);
+
+                // Wait for a specific bit to be set in a register
+                inline bool waitForSet(uint32_t reg, uint32_t bits, uint32_t timeout);
+
+                // Find a CMD slot which is ready for commands
+                int FindFreeCMDSlot();
+            public:
+                AHCIPort(AHCIController* parent, uint32_t regBase, int index);
+                ~AHCIPort();
+
+                // Prepare port to be enabled
+                bool PreparePort();
+
+                // Enable Port for the first time
+                bool StartupPort();
+
+                // Get the type of device attached to this port
+                uint32_t GetType();
+
+                // Enable port
+                bool Enable();
+                
+                // Disable port
+                bool Disable();
+
+                // Handle a interrupt event received from controller
+                void HandleExternalInterrupt();
+
+                // Send Identify command to port
+                bool Identify(uint8_t* buffer);
+
+                // Read or write sectors to device
+                bool TransferData(bool dirIn, uint32_t lba, uint8_t* buffer, uint32_t count = 1);
+
+                // Eject drive if it is a ATAPI device
+                bool Eject();
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/disk/ide.h b/kernelz/include/system/drivers/disk/ide.h
new file mode 100644
index 0000000..4fc5f38
--- /dev/null
+++ b/kernelz/include/system/drivers/disk/ide.h
@@ -0,0 +1,252 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__DISK_CONTROLLERS__IDE_H
+#define __CACTUSOS__SYSTEM__DRIVERS__DISK_CONTROLLERS__IDE_H
+
+/*//// Source /////
+https://wiki.osdev.org/PCI_IDE_Controller
+/////////////////*/
+
+#include <system/drivers/driver.h>
+#include <system/components/pci.h>
+#include <system/interruptmanager.h>
+
+#include <system/disks/diskcontroller.h>
+#include <system/tasking/lock.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            #define IDE_SR_BSY     0x80    // Busy
+            #define IDE_SR_DRDY    0x40    // Drive ready
+            #define IDE_SR_DF      0x20    // Drive write fault
+            #define IDE_SR_DSC     0x10    // Drive seek complete
+            #define IDE_SR_DRQ     0x08    // Data request ready
+            #define IDE_SR_CORR    0x04    // Corrected data
+            #define IDE_SR_IDX     0x02    // Index
+            #define IDE_SR_ERR     0x01    // Error
+
+            #define IDE_ER_BBK      0x80    // Bad block
+            #define IDE_ER_UNC      0x40    // Uncorrectable data
+            #define IDE_ER_MC       0x20    // Media changed
+            #define IDE_ER_IDNF     0x10    // ID mark not found
+            #define IDE_ER_MCR      0x08    // Media change request
+            #define IDE_ER_ABRT     0x04    // Command aborted
+            #define IDE_ER_TK0NF    0x02    // Track 0 not found
+            #define IDE_ER_AMNF     0x01    // No address mark
+
+            #define IDE_CTRL_IE  (0<<1)
+            #define IDE_CTRL_ID  (1<<1)
+
+            #define ATA_CMD_READ_PIO          0x20
+            #define ATA_CMD_READ_PIO_EXT      0x24
+            #define ATA_CMD_READ_DMA          0xC8
+            #define ATA_CMD_READ_DMA_EXT      0x25
+            #define ATA_CMD_WRITE_PIO         0x30
+            #define ATA_CMD_WRITE_PIO_EXT     0x34
+            #define ATA_CMD_WRITE_DMA         0xCA
+            #define ATA_CMD_WRITE_DMA_EXT     0x35
+            #define ATA_CMD_CACHE_FLUSH       0xE7
+            #define ATA_CMD_CACHE_FLUSH_EXT   0xEA
+            #define ATA_CMD_PACKET            0xA0
+            #define ATA_CMD_IDENTIFY_PACKET   0xA1
+            #define ATA_CMD_IDENTIFY          0xEC
+            #define ATA_CMD_SETFEATURE        0xEF
+
+            #define ATA_FEATURE_TRANSFER_MODE 0x03
+
+            #define ATAPI_CMD_READ           0xA8
+            #define ATAPI_CMD_EJECT          0x1B
+
+            #define ATA_IDENT_CAPABILITIES 49
+            #define ATA_IDENT_MODEL        54
+            #define ATA_IDENT_MAX_LBA      60
+            #define ATA_IDENT_COMMANDSETS  83
+            #define ATA_IDENT_MAX_LBA_EXT  100
+
+            #define IDE_ATA        0x00
+            #define IDE_ATAPI      0x01
+            
+            #define ATA_MASTER     0x00
+            #define ATA_SLAVE      0x01
+
+            #define ATA_SECTOR_SIZE     512
+            #define ATAPI_SECTOR_SIZE   2048
+
+            #define IDE_REG_DATA       0x00
+            #define IDE_REG_ERROR      0x01
+            #define IDE_REG_FEATURES   0x01
+            #define IDE_REG_SECCOUNT0  0x02
+            #define IDE_REG_LBA0       0x03
+            #define IDE_REG_LBA1       0x04
+            #define IDE_REG_LBA2       0x05
+            #define IDE_REG_HDDEVSEL   0x06
+            #define IDE_REG_COMMAND    0x07
+            #define IDE_REG_STATUS     0x07
+            #define IDE_REG_SECCOUNT1  0x08
+            #define IDE_REG_LBA3       0x09
+            #define IDE_REG_LBA4       0x0A
+            #define IDE_REG_LBA5       0x0B
+            #define IDE_REG_CONTROL    0x0C
+            #define IDE_REG_ALTSTATUS  0x0C
+            #define IDE_REG_DEVADDRESS 0x0D
+
+            // Busmaster stuff
+            #define IDE_REG_BMI_CMD    0x0E
+            #define IDE_REG_BMI_STS    0x10
+            #define IDE_REG_BMI_PRDT   0x12
+
+            #define IDE_CHANNEL_PRIMARY     0x00
+            #define IDE_CHANNEL_SECONDARY   0x01
+
+            #define IDE_TIMEOUT 1000
+            #define IDE_LOG Log(Info, "IDE %s On line %d", __FILE__, __LINE__);
+
+            struct IDEPhysRegionDescriptor
+            {
+                uint32_t bufferPtrPhys;
+                uint16_t byteCount;
+                uint16_t flags; 
+            } __attribute__((packed));
+
+            // Forward declare the used IDEController class
+            class IDEController;
+            class IDEInterruptHandler : InterruptHandler
+            {
+            private:
+                // To which IDEController is this interrupt handler bound
+                IDEController* target = 0;
+            public:
+                // Create new IDE Interrupt handler
+                IDEInterruptHandler(IDEController* parent, uint8_t interrupt);
+
+                // Function called by interrupt
+                uint32_t HandleInterrupt(uint32_t esp) override;
+            };
+
+            // Holds information about each IDE-Channel
+            struct IDEChannel {
+                uint16_t commandReg;  // I/O Base.
+                uint16_t controlReg;  // Control Base
+                uint16_t bmideReg;    // Bus Master IDE
+            };
+
+            // Holds information about each IDE-Device
+            struct IDEDevice {
+                uint8_t  Channel;      // 0 (Primary Channel) or 1 (Secondary Channel).
+                uint8_t  Drive;        // 0 (Master Drive) or 1 (Slave Drive).
+                uint16_t Type;         // 0: ATA, 1:ATAPI.
+                uint32_t Size;         // Size in Sectors.
+                char     Model[41];    // Model in string.
+
+                struct 
+                {
+                    bool IO_Ready;         // Does the drive use the ready bit for data transfers?
+                    bool use48_Bit;        // Does the drive use 48-bit addressing for LBA
+                    bool legacyDMA;        // Are we using legacy DMA for this device MWDMA?
+                    int8_t dmaLevel;      // DMA Type of this drive
+                } specs;
+
+                IDEPhysRegionDescriptor* prdt;              // Physical Region Descriptor Table for this channel
+                uint32_t                 prdtPhys;          // Physical address of PRDT
+                uint8_t*                 prdtBuffer;        // Buffer for reading and writing with DMA commands
+                uint32_t                 prdtBufferPhys;    // Physical address of memory pointed to by prdtBuffer
+            };
+
+            // Does device support DMA Commands?
+            #define IDE_DEV_DMA(x) (x->specs.dmaLevel >= 0)
+
+            class IDEController : public Driver, public DiskController
+            {
+            private:
+                // To which pci device is this IDE controller connected?
+                PCIDevice* pciDevice = 0;
+
+                // Array of all interrupt handlers (maximum 2)
+                IDEInterruptHandler* interruptHandlers[2] = {0,0};
+
+                // Channels present on this IDE Controller
+                IDEChannel channels[2];
+
+                // Connected devices to this controller
+                List<IDEDevice*> devices;
+
+                // SCSI Command Packet
+                uint8_t atapiPacket[12];
+
+                // Generic mutex for complete controller
+                MutexLock ideLock;
+
+                // Flag used for waiting for IRQ
+                volatile bool irqState = 0;
+            private:
+                uint8_t ReadRegister(uint8_t channel, uint8_t reg);
+                void WriteRegister(uint8_t channel, uint8_t reg, uint8_t data);
+                inline const void Wait400NS(uint8_t channel); // Wait 400 ns
+
+                // Enable or disable interrupt for specific channel
+                inline const void SetChannelInterruptEnable(uint8_t channel, bool enable);
+
+                // Enable a specific feature for this device
+                inline const void SetDeviceFeature(uint8_t channel, uint8_t feature, uint8_t arg1 = 0, uint8_t arg2 = 0, uint8_t arg3 = 0, uint8_t arg4 = 0);
+
+                // Set IDE registers for a count of sectors and LBA
+                inline const void SetCountAndLBA(uint8_t channel, uint16_t count, uint32_t lba, bool extended);
+
+                // Prepare the ATAPI SCSI Packet
+                inline const void PrepareSCSI(uint8_t command, uint32_t lba, uint16_t count, bool dma);
+
+                // Perform a polling operation (for PIO commands) and check for errors if needed
+                inline const bool Polling(uint8_t channel, bool checkError);
+
+                // Read DATA port into buffer
+                inline const void PIOReadData(uint8_t channel, bool withIORDY, uint8_t* buffer, uint32_t bytes);
+
+                // Write DATA port into buffer
+                inline const void PIOWriteData(uint8_t channel, bool withIORDY, uint8_t* buffer, uint32_t bytes);
+
+                // Send a SCSI packet to the drive using PIO
+                inline const bool SendPacketCommand(uint8_t channel, uint8_t cmd, uint32_t lba, uint16_t count, bool dma, bool iordy);
+
+                // Wait for IRQ to be fired
+                inline const void WaitForIRQ();
+
+                bool WaitForClear(uint8_t channel, uint8_t reg, uint8_t bits, uint32_t timeout, bool yield = false); // Wait for register to clear specific bit
+                bool WaitForSet(uint8_t channel, uint8_t reg, uint8_t bits, uint32_t timeout, bool yield = false);   // Wait for register to set specific bit
+            public:
+                // Construct new class in memory and pass though connected PCI device
+                IDEController(PCIDevice* device);
+
+                // Called from IDEInterrupt handler class
+                void HandleIRQ(uint32_t esp);
+
+                // Initialize IDE controller and setup connected devices
+                bool Initialize() override;
+
+                // DiskController Functions
+                char ReadSector(uint16_t drive, uint32_t lba, uint8_t* buf) override;
+                char WriteSector(uint16_t drive, uint32_t lba, uint8_t* buf) override;
+                bool EjectDrive(uint8_t drive) override;
+
+                // Read/Write functions for ATA/ATAPI using DMA
+
+                // Transfer sectors via DMA to a ATA device
+                char ATA_DMA_TransferSector(uint16_t drive, uint32_t lba, uint8_t* buf, bool read);
+                
+                // Transfer sectors via DMA to a ATAPI device (only read is supported)
+                char ATAPI_DMA_TransferSector(uint16_t drive, uint16_t lba, uint8_t* buf);
+            
+                // Read/Write functions for ATA/ATAPI using PIO
+
+                // Transfer sectors via PIO to a ATA device
+                char ATA_PIO_TransferSector(uint16_t drive, uint32_t lba, uint8_t* buf, bool read);
+                
+                // Transfer sectors via PIO to a ATAPI device (only read is supported)
+                char ATAPI_PIO_TransferSector(uint16_t drive, uint16_t lba, uint8_t* buf);
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/driver.h b/kernelz/include/system/drivers/driver.h
new file mode 100644
index 0000000..923624a
--- /dev/null
+++ b/kernelz/include/system/drivers/driver.h
@@ -0,0 +1,27 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVER_H
+#define __CACTUSOS__SYSTEM__DRIVER_H
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            class Driver
+            {
+            private:
+                char* Name;
+                char* Description;
+            public:
+                Driver(char* name = 0, char* description = 0);
+
+                char* GetDriverName();
+                char* GetDriverDescription();
+
+                virtual bool Initialize();
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/drivermanager.h b/kernelz/include/system/drivers/drivermanager.h
new file mode 100644
index 0000000..8e9efbb
--- /dev/null
+++ b/kernelz/include/system/drivers/drivermanager.h
@@ -0,0 +1,31 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERMANAGER__DRIVER_H
+#define __CACTUSOS__SYSTEM__DRIVERMANAGER__DRIVER_H
+
+#include <common/types.h>
+#include <common/list.h>
+
+#include <system/drivers/driver.h>
+#include <system/bootconsole.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            class DriverManager
+            {
+            private:
+                List<Driver*> driverList;
+            public:
+                DriverManager();
+
+                void AddDriver(Driver* drv);
+
+                void ActivateAll();
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/integrated/floppy.h b/kernelz/include/system/drivers/integrated/floppy.h
new file mode 100644
index 0000000..c9eec1c
--- /dev/null
+++ b/kernelz/include/system/drivers/integrated/floppy.h
@@ -0,0 +1,234 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__FLOPPY_H
+#define __CACTUSOS__SYSTEM__DRIVERS__FLOPPY_H
+
+#include <system/drivers/driver.h>
+#include <system/interruptmanager.h>
+#include <system/disks/diskcontroller.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            /*
+            **	Controller I/O Ports. Please see chapter for additional ports
+            */
+
+            enum FLPYDSK_IO
+            {
+                FLPYDSK_DOR		=	0x3f2,
+                FLPYDSK_MSR		=	0x3f4,
+                FLPYDSK_FIFO	=	0x3f5,
+                FLPYDSK_CTRL	=	0x3f7
+            };
+
+            /**
+            *	Bits 0-4 of command byte. Please see chapter for additional commands
+            */
+
+            enum FLPYDSK_CMD 
+            {
+                FDC_CMD_READ_TRACK	=	2,
+                FDC_CMD_SPECIFY		=	3,
+                FDC_CMD_CHECK_STAT	=	4,
+                FDC_CMD_WRITE_SECT	=	5,
+                FDC_CMD_READ_SECT	=	6,
+                FDC_CMD_CALIBRATE	=	7,
+                FDC_CMD_CHECK_INT	=	8,
+                FDC_CMD_FORMAT_TRACK=	0xd,
+                FDC_CMD_SEEK		=	0xf
+            };
+
+            /**
+            *	Additional command masks. Can be masked with above commands
+            */
+
+            enum FLPYDSK_CMD_EXT 
+            {
+                FDC_CMD_EXT_SKIP		=	0x20,	//00100000
+                FDC_CMD_EXT_DENSITY		=	0x40,	//01000000
+                FDC_CMD_EXT_MULTITRACK	=	0x80	//10000000
+            };
+
+            /*
+            **	Digital Output Register
+            */
+
+            enum FLPYDSK_DOR_MASK 
+            {
+                FLPYDSK_DOR_MASK_DRIVE0			=	0,	//00000000	= here for completeness sake
+                FLPYDSK_DOR_MASK_DRIVE1			=	1,	//00000001
+                FLPYDSK_DOR_MASK_DRIVE2			=	2,	//00000010
+                FLPYDSK_DOR_MASK_DRIVE3			=	3,	//00000011
+                FLPYDSK_DOR_MASK_RESET			=	4,	//00000100
+                FLPYDSK_DOR_MASK_DMA			=	8,	//00001000
+                FLPYDSK_DOR_MASK_DRIVE0_MOTOR	=	16,	//00010000
+                FLPYDSK_DOR_MASK_DRIVE1_MOTOR	=	32,	//00100000
+                FLPYDSK_DOR_MASK_DRIVE2_MOTOR	=	64,	//01000000
+                FLPYDSK_DOR_MASK_DRIVE3_MOTOR	=	128	//10000000
+            };
+
+            /**
+            *	Main Status Register
+            */
+
+            enum FLPYDSK_MSR_MASK 
+            {
+                FLPYDSK_MSR_MASK_DRIVE1_POS_MODE	=	1,	//00000001
+                FLPYDSK_MSR_MASK_DRIVE2_POS_MODE	=	2,	//00000010
+                FLPYDSK_MSR_MASK_DRIVE3_POS_MODE	=	4,	//00000100
+                FLPYDSK_MSR_MASK_DRIVE4_POS_MODE	=	8,	//00001000
+                FLPYDSK_MSR_MASK_BUSY				=	16,	//00010000
+                FLPYDSK_MSR_MASK_DMA				=	32,	//00100000
+                FLPYDSK_MSR_MASK_DATAIO				=	64, //01000000
+                FLPYDSK_MSR_MASK_DATAREG			=	128	//10000000
+            };
+
+            /**
+            *	Controller Status Port 0
+            */
+
+            enum FLPYDSK_ST0_MASK 
+            {
+                FLPYDSK_ST0_MASK_DRIVE0		=	0,		//00000000	=	for completness sake
+                FLPYDSK_ST0_MASK_DRIVE1		=	1,		//00000001
+                FLPYDSK_ST0_MASK_DRIVE2		=	2,		//00000010
+                FLPYDSK_ST0_MASK_DRIVE3		=	3,		//00000011
+                FLPYDSK_ST0_MASK_HEADACTIVE	=	4,		//00000100
+                FLPYDSK_ST0_MASK_NOTREADY	=	8,		//00001000
+                FLPYDSK_ST0_MASK_UNITCHECK	=	16,		//00010000
+                FLPYDSK_ST0_MASK_SEEKEND	=	32,		//00100000
+                FLPYDSK_ST0_MASK_INTCODE	=	64		//11000000
+            };
+
+            /*
+            ** LPYDSK_ST0_MASK_INTCODE types
+            */
+
+            enum FLPYDSK_ST0_INTCODE_TYP 
+            {
+                FLPYDSK_ST0_TYP_NORMAL		=	0,
+                FLPYDSK_ST0_TYP_ABNORMAL_ERR=	1,
+                FLPYDSK_ST0_TYP_INVALID_ERR	=	2,
+                FLPYDSK_ST0_TYP_NOTREADY	=	3
+            };
+
+            /**
+            *	GAP 3 sizes
+            */
+
+            enum FLPYDSK_GAP3_LENGTH 
+            {
+                FLPYDSK_GAP3_LENGTH_STD     = 42,
+                FLPYDSK_GAP3_LENGTH_5_14    = 32,
+                FLPYDSK_GAP3_LENGTH_3_5     = 27
+            };
+
+            /*
+            **	Formula: 2^sector_number * 128, where ^ denotes "to the power of"
+            */
+
+            enum FLPYDSK_SECTOR_DTL 
+            {
+                FLPYDSK_SECTOR_DTL_128	=	0,
+                FLPYDSK_SECTOR_DTL_256	=	1,
+                FLPYDSK_SECTOR_DTL_512	=	2,
+                FLPYDSK_SECTOR_DTL_1024	=	4
+            };
+
+            typedef enum {
+                FloppyDirectionRead = 1,
+                FloppyDirectionWrite = 2
+            } FloppyDirection;
+
+            //! sectors per track
+            #define FLPY_SECTORS_PER_TRACK 18
+
+            //! FDC uses DMA channel 2
+            #define FDC_DMA_CHANNEL 2
+
+            #define BYTES_PER_SECT 512
+
+            // A class that manages the floppies on this system
+            class FloppyDriver : public InterruptHandler, public Driver, public DiskController
+            {
+            private:
+                // Used for waiting for command completion
+                volatile bool IrqHasFired = false;
+
+                // Buffer used by the DMA Controller, must be bellow 16MB
+                uint32_t bufferPhys = 0;
+
+                // Virtual address of buffer
+                uint8_t* bufferVirt = 0;
+
+                // Floppies on this controller
+                uint8_t flpy1 = 0;
+	            uint8_t flpy2 = 0;
+            private:
+                // Prepare DMA for read/write operation
+                bool InitializeDMA(FloppyDirection dir);
+
+                // Wait for a irq to be fired
+                void WaitForIRQ();
+
+                // Write val to DOR Register
+                void WriteDOR(common::uint8_t val);
+
+                // Write val to Configuation Control Register
+                void WriteCCR(common::uint8_t val);
+
+                // Read status register and return value
+                common::uint8_t ReadStatus();
+
+                // Get status of interrup register
+                void CheckIntStatus(uint32_t* st0, uint32_t* cyl);
+
+                // Send Command to controller
+                void SendCommand(common::uint8_t cmd);
+
+                // Read Data from controller
+                common::uint8_t ReadData();
+
+                // Turn motor on or off for currentDrive
+                void ControlMotor(common::uint8_t drive, bool on);
+
+                // Set drive parameters
+                void ConfigureDrive(common::uint8_t stepr, common::uint8_t loadt, common::uint8_t unloadt, bool dma);
+
+                // Calibrate drive
+                int Calibrate(common::uint8_t drive);
+
+                // Seek current drive
+                int Seek(common::uint8_t drive, common::uint8_t cyl, common::uint8_t head);
+
+                // Disable Controller
+                void DisableController();
+
+                // Enable Controller
+                void EnableController();
+
+                // Reset Controller
+                void ResetController();
+
+                // Core function to read sector
+                int TransferSectorCHS(common::uint8_t drive, FloppyDirection dir, common::uint8_t head, common::uint8_t track, common::uint8_t sector);
+            public:
+                FloppyDriver();
+
+                //////////////
+                // Functions for sub-components
+                //////////////
+
+                bool Initialize() override;
+                char ReadSector(common::uint16_t drive, common::uint32_t lba, common::uint8_t* buf) override;
+                char WriteSector(common::uint16_t drive, common::uint32_t lba, common::uint8_t* buf) override;
+                bool EjectDrive(common::uint8_t drive) override;
+                common::uint32_t HandleInterrupt(common::uint32_t esp) override;
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/integrated/ps2-keyboard.h b/kernelz/include/system/drivers/integrated/ps2-keyboard.h
new file mode 100644
index 0000000..30f1d80
--- /dev/null
+++ b/kernelz/include/system/drivers/integrated/ps2-keyboard.h
@@ -0,0 +1,34 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__PS2KEYBOARD_H
+#define __CACTUSOS__SYSTEM__DRIVERS__PS2KEYBOARD_H
+
+#include <system/drivers/driver.h>
+#include <system/interruptmanager.h>
+#include <system/memory/fifostream.h>
+#include <system/input/keyboard.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            #define PS2_DATA 0x60
+            #define PS2_STATUS 0x64
+            #define PS2_COMMAND 0x64
+
+            class PS2KeyboardDriver : public InterruptHandler, public Keyboard, public Driver, public FIFOStream
+            {
+            public:
+                PS2KeyboardDriver();
+
+                bool Initialize();
+                common::uint32_t HandleInterrupt(common::uint32_t esp);
+
+                // Update LED's on a keyboard device
+                void UpdateLEDS() override;
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/integrated/ps2-mouse.h b/kernelz/include/system/drivers/integrated/ps2-mouse.h
new file mode 100644
index 0000000..76cc485
--- /dev/null
+++ b/kernelz/include/system/drivers/integrated/ps2-mouse.h
@@ -0,0 +1,65 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__PS2MOUSE_H
+#define __CACTUSOS__SYSTEM__DRIVERS__PS2MOUSE_H
+
+#include <system/drivers/driver.h>
+#include <system/interruptmanager.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            struct MousePacket
+            {
+                unsigned char LeftBTN : 1;
+                unsigned char RightBTN : 1;
+                unsigned char MiddleBTN : 1;
+                unsigned char Always1 : 1;
+                unsigned char Xsign : 1;
+                unsigned char Ysign : 1;
+                unsigned char Xoverflow : 1;
+                unsigned char Yoverflow : 1;
+
+                signed char XMovement;
+                signed char YMovement;
+                signed char ZMovement; //if MouseID == 3
+            };
+            
+
+            class PS2MouseDriver : public InterruptHandler, public Driver
+            {
+            private:
+                #define MOUSE_DATA 0x60
+                #define MOUSE_COMMAND 0x64
+                #define MOUSE_ACK 0xFA
+
+                common::uint8_t MouseID = 0;
+                common::uint8_t MouseCycle = 0;
+                signed char* packetBuffer;
+
+                bool ready = false;
+            public:
+                PS2MouseDriver();
+
+                bool Initialize();
+                common::uint32_t HandleInterrupt(common::uint32_t esp);
+
+                /**
+                 * Enable the scrollwheel for this mouse, returns true when succeeded
+                */
+                bool EnableScrollWheel();
+                /**
+                 * Valid values: 10,20,40,60,80,100,200 
+                */
+                bool SetSampleRate(common::uint8_t value);
+                /**
+                 * Handle a packet send by the mouse
+                */
+                void ProcessPacket();
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/pcidrivers.h b/kernelz/include/system/drivers/pcidrivers.h
new file mode 100644
index 0000000..39d1569
--- /dev/null
+++ b/kernelz/include/system/drivers/pcidrivers.h
@@ -0,0 +1,30 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__PCIDRIVERS_H
+#define __CACTUSOS__SYSTEM__DRIVERS__PCIDRIVERS_H
+
+#include <system/components/pci.h>
+#include <system/drivers/drivermanager.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            struct PCIAttachedDriverEntry
+            {
+                common::uint16_t vendorID;
+                common::uint16_t deviceID;
+                char* driverString;
+            } __attribute__((packed));
+
+            class PCIDrivers
+            {
+            public:
+                static void AssignDriversFromPCI(PCIController* pci, DriverManager* driverManager);
+            };
+        }
+    }
+}
+
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/usb/controllers/ehci.h b/kernelz/include/system/drivers/usb/controllers/ehci.h
new file mode 100644
index 0000000..c304acd
--- /dev/null
+++ b/kernelz/include/system/drivers/usb/controllers/ehci.h
@@ -0,0 +1,209 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__USB__CONTROLLERS__EHCI_H
+#define __CACTUSOS__SYSTEM__DRIVERS__USB__CONTROLLERS__EHCI_H
+
+
+#include <system/drivers/driver.h>
+#include <system/components/pci.h>
+#include <system/interruptmanager.h>
+#include <system/usb/usbcontroller.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            #define EHCI_CAPS_CapLength      0x00
+            #define EHCI_CAPS_Reserved       0x01
+            #define EHCI_CAPS_IVersion       0x02
+            #define EHCI_CAPS_HCSParams      0x04
+            #define EHCI_CAPS_HCCParams      0x08
+            #define EHCI_CAPS_HCSPPortRoute  0x0C
+
+            #define EHCI_OPS_USBCommand       0x00
+            #define EHCI_OPS_USBStatus        0x04
+            #define EHCI_OPS_USBInterrupt     0x08
+            #define EHCI_OPS_FrameIndex       0x0C
+            #define EHCI_OPS_CtrlDSSegment    0x10
+            #define EHCI_OPS_PeriodicListBase 0x14
+            #define EHCI_OPS_AsyncListBase    0x18
+            #define EHCI_OPS_ConfigFlag       0x40
+            #define EHCI_OPS_PortStatus       0x44  // first port
+
+            #define EHCI_PORT_CCS            (1<<0)
+            #define EHCI_PORT_CSC            (1<<1)
+            #define EHCI_PORT_ENABLED        (1<<2)
+            #define EHCI_PORT_ENABLE_C       (1<<3)
+            #define EHCI_PORT_OVER_CUR_C     (1<<5)
+            #define EHCI_PORT_RESET          (1<<8)
+            #define EHCI_PORT_LINE_STATUS    (3<<10)
+            #define EHCI_PORT_PP             (1<<12)
+            #define EHCI_PORT_OWNER          (1<<13)
+
+            #define EHCI_LEGACY_USBLEGSUP     0x00
+            #define EHCI_LEGACY_USBLEGCTLSTS  0x04
+
+            #define EHCI_LEGACY_TIMEOUT     100  // 100 milliseconds
+            #define EHCI_LEGACY_BIOS_OWNED  (1<<16)
+            #define EHCI_LEGACY_OS_OWNED    (1<<24)
+            #define EHCI_LEGACY_OWNED_MASK  (EHCI_LEGACY_BIOS_OWNED | EHCI_LEGACY_OS_OWNED)
+
+            #define EHCI_PORT_WRITE_MASK     0x007FF1EE
+
+            #define EHCI_QUEUE_HEAD_PTR_MASK  0x1F
+
+            #define QH_HS_T0         (0<<0)  // pointer is valid
+            #define QH_HS_T1         (1<<0)  // pointer is not valid
+
+            #define QH_HS_TYPE_QH    (1<<1)  // Queue Head
+
+            #define QH_HS_EPS_FS     0 // Full speed endpoint
+            #define QH_HS_EPS_LS     1 // Low  speed endpoint
+            #define QH_HS_EPS_HS     2 // High speed endpoint
+
+            #define EHCI_MPS 64 // Max Packet Speed
+
+            #define EHCI_TD_PID_OUT    0
+            #define EHCI_TD_PID_IN     1
+            #define EHCI_TD_PID_SETUP  2
+
+            #define E_QUEUE_Q128      0
+            #define E_QUEUE_Q64       1
+            #define E_QUEUE_Q32       2
+            #define E_QUEUE_Q16       3
+            #define E_QUEUE_Q8        4
+            #define E_QUEUE_Q4        5
+            #define E_QUEUE_Q2        6
+            #define E_QUEUE_Q1        7
+
+            #define NUM_EHCI_QUEUES 8
+
+            typedef struct e_transferDescriptor e_transferDescriptor_t;
+            typedef struct e_queueHead e_queueHead_t;
+
+            struct e_transferDescriptor
+            {
+                uint32_t nextQTD;       // Next Transfer descriptor pointer 31:5 is physical address, 1:4 is reserved, 0 is if the link is valid
+                uint32_t altNextQTD;    // Alternative Transfer descriptor on short packet pointer 31:5 is physical address, 1:4 is reserved, 0 is if the link is valid
+                uint32_t flags;         // Flags of this transfer descriptor
+                uint32_t bufPtr[5];     // Low address of buffer pointer
+                uint32_t bufPtrHi[5];   // High address of buffer pointer
+                
+                // Internal fields
+                e_transferDescriptor_t* nextQTDVirt;
+                e_transferDescriptor_t* altNextQTDVirt;
+
+                uint32_t pad[1];
+            } __attribute__((packed));
+
+            struct e_queueHead
+            {
+                uint32_t horzPointer;   // Points to next queue head 31:5 is physical address, 4:3 is reserved. 2:1 is type, 0 is if the link is valid
+                uint32_t flags;         // Flags of this queue, includes device specific information
+                uint32_t hubFlags;      // Flags needed when device is on a external hub
+                uint32_t curQTD;        // Current transfer descriptor that is excecuted by the controller
+                e_transferDescriptor_t transferDescriptor; // Transfer descriptor overlay
+
+                // Internal fields
+                uint32_t prevPointerPhys; // Physical address of previous transfer descriptor
+                e_queueHead_t* prevPointerVirt; // Virtual pointer to previous queue head, 0 if invallid
+                e_queueHead_t* horzPointerVirt; // Virtual pointer to next queue head, 0 if invallid
+                uint32_t pad[1];
+            } __attribute__((packed));
+
+            class EHCIController : public USBController, public Driver, public InterruptHandler
+            {
+            private:
+                PCIDevice*      pciDevice;
+                int             newDeviceAddress = 1;
+                uint32_t        regBase = 0;
+                uint8_t         operRegsOffset = 0;
+
+                e_queueHead_t*  asyncList = 0;
+                uint32_t        asyncListPhys = 0;
+
+                uint32_t*       periodicList = 0;
+                uint32_t        periodicListPhys = 0;
+                e_queueHead_t*  queueStackList = 0;
+
+                uint8_t         numPorts = 0;
+
+                uint32_t ReadOpReg(uint32_t reg);
+                void WriteOpReg(uint32_t reg, uint32_t val);
+                void DisplayRegisters();
+                void PrintTransferDescriptors(e_transferDescriptor_t* td);
+                void PrintQueueHead(e_queueHead_t* qh);
+                void PrintAsyncQueue();
+            public:
+                EHCIController(PCIDevice* device);
+
+                bool Initialize() override;
+                void Setup() override;
+
+                // Reset port of this controller, returns true when successful
+                bool ResetPort(uint8_t port);
+
+                // Reset the controller to its default settings
+                bool ResetController();
+
+                // Release BIOS ownership of controller
+                // On Entry:
+                //   params: the dword value of the capability register
+                // On Return:
+                //   true if ownership released
+                // 
+                // Set bit 24 to indicate to the BIOS to release ownership
+                // The BIOS should clear bit 16 indicating that it has successfully done so
+                // Ownership is released when bit 24 is set *and* bit 16 is clear.
+                // This will wait EHC_LEGACY_TIMEOUT ms for the BIOS to release ownership.
+                //   (It is unknown the exact time limit that the BIOS has to release ownership.)
+                // 
+                bool StopLegacy(const uint32_t params);
+
+                void InitializeAsyncList();
+                void InitializePeriodicList();
+
+                uint32_t HandleInterrupt(uint32_t esp);
+                
+                bool WaitForRegister(const uint32_t reg, const uint32_t mask, const uint32_t result, unsigned ms);
+                bool SetupNewDevice(const int port);
+
+                void MakeSetupTransferDesc(e_transferDescriptor_t* tdVirt, const uint32_t tdPhys, uint32_t bufPhys);
+                void MakeTransferDesc(e_transferDescriptor_t* currentTD, uint32_t physAddr, e_transferDescriptor_t* status_qtd, const uint32_t status_qtdPhys, uint32_t bufferPhys, int size, const bool last, uint8_t data0, const uint8_t dir, const uint16_t mps);
+                
+                void InsertIntoQueue(e_queueHead_t* item, uint32_t itemPhys, const uint8_t type);
+                bool RemoveFromQueue(e_queueHead_t* item);
+                
+                int WaitForTransferComplete(e_transferDescriptor_t* td, const uint32_t timeout, bool* spd);
+                
+                bool ControlOut(const int devAddress, const int packetSize, const int len = 0, const uint8_t requestType = 0, const uint8_t request = 0, const uint16_t valueHigh = 0, const uint16_t valueLow = 0, const uint16_t index = 0);
+                bool ControlIn(void* targ, const int devAddress, const int packetSize, const int len = 0, const uint8_t requestType = 0, const uint8_t request = 0, const uint16_t valueHigh = 0, const uint16_t valueLow = 0, const uint16_t index = 0);
+                
+                bool BulkOut(USBEndpoint* toggleSrc, const int devAddress, const int packetSize, const int endP, void* bufPtr, const int len = 0);
+                bool BulkIn(USBEndpoint* toggleSrc, const int devAddress, const int packetSize, const int endP, void* bufPtr, const int len = 0);
+
+                //////////
+                // USB Controller Common Functions
+                //////////
+
+                // Function that will get called on a periodic interval in which the controller can perform specific kinds of things.
+                void ControllerChecksThread() override;
+
+                // Perform a bulk in operation
+                bool BulkIn(USBDevice* device, void* retBuffer, int len, int endP) override;
+                // Perform a bulk out operation
+                bool BulkOut(USBDevice* device, void* sendBuffer, int len, int endP) override;
+
+                // Perform a control in operation
+                bool ControlIn(USBDevice* device, void* target = 0, const int len = 0, const uint8_t requestType = 0, const uint8_t request = 0, const uint16_t valueHigh = 0, const uint16_t valueLow = 0, const uint16_t index = 0) override;
+                // Perform a control out operation
+                bool ControlOut(USBDevice* device, const int len = 0, const uint8_t requestType = 0, const uint8_t request = 0, const uint16_t valueHigh = 0, const uint16_t valueLow = 0, const uint16_t index = 0) override;
+            
+                // Place a interrupt in transfer in the dedicated queue, handler will get called on completion
+                void InterruptIn(USBDevice* device, int len, int endP) override;
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/usb/controllers/ohci.h b/kernelz/include/system/drivers/usb/controllers/ohci.h
new file mode 100644
index 0000000..9103009
--- /dev/null
+++ b/kernelz/include/system/drivers/usb/controllers/ohci.h
@@ -0,0 +1,152 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__USB__CONTROLLERS__OHCI_H
+#define __CACTUSOS__SYSTEM__DRIVERS__USB__CONTROLLERS__OHCI_H
+
+
+#include <system/drivers/driver.h>
+#include <system/components/pci.h>
+#include <system/interruptmanager.h>
+#include <system/usb/usbcontroller.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            #define OHCRevision          0x00
+            #define OHCControl           0x04
+            #define OHCCommandStatus     0x08
+            #define OHCInterruptStatus   0x0C
+            #define OHCInterruptEnable   0x10
+            #define OHCInterruptDisable  0x14
+            #define OHCHCCA              0x18
+            #define OHCPeriodCurrentED   0x1C
+            #define OHCControlHeadED     0x20
+            #define OHCControlCurrentED  0x24
+            #define OHCBulkHeadED        0x28
+            #define OHCBulkCurrentED     0x2C
+            #define OHCDoneHead          0x30
+            #define OHCFmInterval        0x34
+            #define OHCFmRemaining       0x38
+            #define OHCFmNumber          0x3C
+            #define OHCPeriodicStart     0x40
+            #define OHCLSThreshold       0x44
+            #define OHCRhDescriptorA     0x48
+            #define OHCRhDescriptorB     0x4C
+            #define OHCRhStatus          0x50
+            #define OHCRhPortStatus      0x54
+
+            #define OHCRhDescriptorA_MASK 0xFFFFFBF0
+
+            typedef struct OHCI_ED {
+                uint32_t flags;
+                uint32_t tailp;
+                uint32_t headp;
+                uint32_t nextED;
+            } __attribute__((packed)) o_endpointDescriptor_t;
+
+            typedef struct OHCI_TD {
+                uint32_t flags;
+                uint32_t curBufPtr;
+                uint32_t nextTd;
+                uint32_t bufEnd;
+            } __attribute__((packed)) o_transferDescriptor_t;
+
+
+            #define TD_DP_SETUP  0
+            #define TD_DP_OUT    1
+            #define TD_DP_IN     2
+            #define TD_DP_RESV   3
+
+            typedef struct OHCI_HCCA {
+                uint32_t HccaInterruptTable[32];
+                uint16_t HccaFrameNumber;
+                uint16_t HccaPad1;
+                uint32_t HccaDoneHead;
+                uint8_t  reserved[116];
+                uint32_t unknown;
+            } __attribute__((packed)) HCCA_t;
+
+            #define NUM_CONTROL_EDS     16
+            #define NUM_BULK_EDS        16
+            #define NUM_INTERRUPT_EDS   32
+            #define OHCI_TD_TIMEOUT     1000
+
+            class OHCIController : public USBController, public Driver, public InterruptHandler
+            {
+            private:
+                PCIDevice* pciDevice;
+                int newDeviceAddress = 1;
+                
+                volatile uint32_t regBase; //Base address of registers
+                //Host Controller Communication Area
+                HCCA_t* hcca;
+                //Value to store physical address of HCCA
+                uint32_t hccaPhys;
+                //Number of root hub ports
+                uint8_t numPorts;
+
+                //Lists
+                o_endpointDescriptor_t* controlEndpoints[NUM_CONTROL_EDS];          // Control list endpoint descriptors
+                uint32_t                controlEndpointsPhys[NUM_CONTROL_EDS];      // Physical Addresses of Control ED's
+                o_endpointDescriptor_t* bulkEndpoints[NUM_BULK_EDS];                // Bulk list endpoint descriptors
+                uint32_t                bulkEndpointsPhys[NUM_BULK_EDS];            // Physical Addresses of Bulk ED's
+                o_endpointDescriptor_t* interruptEndpoints;                         // Interrupt endpoint descriptors
+                                                                                    // Physical addresses are in hcca
+            public:
+                OHCIController(PCIDevice* device);
+
+                bool Initialize() override;
+                void Setup() override;
+
+                // Check if a set of transfer descriptors is done executing
+                // Returns:
+                // 0 -> No Errors and Done
+                // 1 -> Generic Error
+                // 2 -> NAK
+                // 3 -> Not done yet
+                int CheckTransferDone(o_transferDescriptor_t* td, int numTDs);
+
+                // Calculate in which queue the packet should be placed for this interval
+                int CalculateRequiredQueue(int interval);
+                
+                //Reset port of this controller, returns true when succesfull
+                bool ResetPort(uint8_t port);
+
+                bool ControlOut(const bool lsDevice, const int devAddress, const int packetSize, const int len = 0, const uint8_t requestType = 0, const uint8_t request = 0, const uint16_t valueHigh = 0, const uint16_t valueLow = 0, const uint16_t index = 0);
+                bool ControlIn(void* targ, const bool lsDevice, const int devAddress, const int packetSize, const int len = 0, const uint8_t requestType = 0, const uint8_t request = 0, const uint16_t valueHigh = 0, const uint16_t valueLow = 0, const uint16_t index = 0);
+                
+                bool BulkOut(const bool lsDevice, const int devAddress, const int packetSize, const int endP, void* bufPtr, const int len = 0);
+                bool BulkIn(const bool lsDevice, const int devAddress, const int packetSize, const int endP, void* bufPtr, const int len = 0);
+
+                void InterruptIn(const bool lsDevice, const int devAddress, const int packetSize, const int endP, int interval, USBDriver* handler, const int len = 0);
+
+                uint32_t HandleInterrupt(uint32_t esp);
+
+                void SetupNewDevice(uint8_t port);
+
+                //////////
+                // USB Controller Common Functions
+                //////////
+                
+                // Function that will get called on a periodic interval in which the controller can perform specific kinds of things.
+                void ControllerChecksThread() override;
+
+                // Perform a bulk in operation
+                bool BulkIn(USBDevice* device, void* retBuffer, int len, int endP) override;
+                // Perform a bulk out operation
+                bool BulkOut(USBDevice* device, void* sendBuffer, int len, int endP) override;
+
+                // Perform a control in operation
+                bool ControlIn(USBDevice* device, void* target = 0, const int len = 0, const uint8_t requestType = 0, const uint8_t request = 0, const uint16_t valueHigh = 0, const uint16_t valueLow = 0, const uint16_t index = 0) override;
+                // Perform a control out operation
+                bool ControlOut(USBDevice* device, const int len = 0, const uint8_t requestType = 0, const uint8_t request = 0, const uint16_t valueHigh = 0, const uint16_t valueLow = 0, const uint16_t index = 0) override;        
+            
+                // Place a interrupt in transfer in the dedicated queue, handler will get called on completion
+                void InterruptIn(USBDevice* device, int len, int endP) override;
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/usb/controllers/uhci.h b/kernelz/include/system/drivers/usb/controllers/uhci.h
new file mode 100644
index 0000000..c12ad67
--- /dev/null
+++ b/kernelz/include/system/drivers/usb/controllers/uhci.h
@@ -0,0 +1,176 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__USB__CONTROLLERS__UHCI_H
+#define __CACTUSOS__SYSTEM__DRIVERS__USB__CONTROLLERS__UHCI_H
+
+
+#include <system/drivers/driver.h>
+#include <system/components/pci.h>
+#include <system/interruptmanager.h>
+#include <system/usb/usbcontroller.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            #define UHCI_COMMAND     0x00
+            #define UHCI_STATUS      0x02
+
+            #define UHCI_INTERRUPT   0x04
+            #define UHCI_FRAME_NUM   0x06
+            #define UHCI_FRAME_BASE  0x08
+            #define UHCI_SOF_MOD     0x0C
+            #define UHCI_LEGACY      0xC0
+
+            #define UHCI_PORT_WRITE_MASK  0x124E    //  0001 0010 0100 1110
+
+            #define UHCI_STS_HCHALTED            (1<<5)
+            #define UHCI_STS_HC_PROCESS_ERROR    (1<<4)
+            #define UHCI_STS_HOST_SYSTEM_ERROR   (1<<3)
+            #define UHCI_STS_RESUME_DETECT       (1<<2)
+            #define UHCI_STS_USB_ERROR           (1<<1)
+            #define UHCI_STS_USBINT              (1<<0)
+
+            #define TOKEN_OUT    0xE1
+            #define TOKEN_IN     0x69
+            #define TOKEN_SETUP  0x2D
+
+            #define BREADTH (0<<2)
+            #define DEPTH   (1<<2)
+
+            #define QUEUE_HEAD_PTR_MASK  0xFFFFFFF0
+            #define QUEUE_HEAD_Q         0x00000002
+            #define QUEUE_HEAD_T         0x00000001
+
+            typedef struct uhci_queue_head uhci_queue_head_t;
+
+            struct uhci_queue_head {
+                uint32_t horz_ptr;
+                uint32_t vert_ptr;
+
+                uhci_queue_head_t* nextQueuePointer;
+                uhci_queue_head_t* parentQueuePointer;
+            } __attribute__((packed));
+
+
+            #define TD_PTR_MASK  0xFFFFFFF0
+            #define TD_VF        0x00000004
+            #define TD_Q         0x00000002
+            #define TD_T         0x00000001
+
+            #define TD_FLAGS_SPD      0x20000000
+            #define TD_FLAGS_CERR     0x18000000
+            #define TD_FLAGS_LS       0x04000000
+            #define TD_FLAGS_ISO      0x02000000
+            #define TD_FLAGS_IOC      0x01000000
+            #define TD_STATUS_ACTIVE  0x00800000
+            #define TD_STATUS_STALL   0x00400000
+            #define TD_STATUS_DBERR   0x00200000
+            #define TD_STATUS_BABBLE  0x00100000
+            #define TD_STATUS_NAK     0x00080000
+            #define TD_STATUS_CRC_TO  0x00040000
+            #define TD_STATUS_BSTUFF  0x00020000
+            #define TD_STATUS_MASK    0x00FF0000
+            #define TD_ACTLEN_MASK    0x000007FF
+
+            #define TD_INFO_MAXLEN_MASK   0xFFE00000
+            #define TD_INFO_MAXLEN_SHFT   21
+            #define TD_INFO_D             0x00080000
+            #define TD_INFO_ENDPT_MASK    0x00078000
+            #define TD_INFO_ENDPT_SHFT    15
+            #define TD_INFO_ADDR_MASK     0x00007F00
+            #define TD_INFO_ADDR_SHFT     8
+            #define TD_INFO_PID           0x000000FF
+
+
+            #define U_QUEUE_Q128      0
+            #define U_QUEUE_Q64       1
+            #define U_QUEUE_Q32       2
+            #define U_QUEUE_Q16       3
+            #define U_QUEUE_Q8        4
+            #define U_QUEUE_Q4        5
+            #define U_QUEUE_Q2        6
+            #define U_QUEUE_Q1        7
+            #define U_QUEUE_QControl  8
+            #define U_QUEUE_QBulk     9
+
+            #define NUM_UHCI_QUEUES 10
+
+            
+            typedef struct __attribute__((packed)) { 
+                uint32_t   link_ptr;
+                uint32_t   reply;
+                uint32_t   info;
+                uint32_t   buff_ptr;
+                uint32_t   resv0[4];          // the last 4 dwords are reserved for software use.
+            } u_transferDescriptor_t;
+
+            class UHCIController : public USBController, public Driver, public InterruptHandler
+            {
+            private:
+                PCIDevice* pciDevice;
+                int newDeviceAddress = 1;
+
+                uhci_queue_head_t* queueStackList = 0;
+
+                uint32_t* frameList = 0;
+                uint32_t frameListPhys = 0;
+                int numRootPorts = 0;
+            public:
+                UHCIController(PCIDevice* device);
+
+                bool Initialize() override;
+                void Setup() override;
+
+                //Check if this port is present on the controller
+                bool PortPresent(uint8_t port);
+                bool ResetPort(uint8_t port);
+                void SetupNewDevice(uint8_t port);
+
+                void InsertQueue(uhci_queue_head_t* queue, uint32_t queuePhys, const int queueIndex);
+                void RemoveQueue(uhci_queue_head_t* queue, const int queueIndex);
+                int CalculateRequiredQueue(int interval);
+
+                // Check if a set of transfer descriptors is done executing
+                // Returns:
+                // 0 -> No Errors and Done
+                // 1 -> Generic Error
+                // 2 -> NAK
+                // 3 -> Not done yet
+                int CheckTransferDone(u_transferDescriptor_t* td, int numTDs);
+
+                bool ControlOut(const bool lsDevice, const int devAddress, const int packetSize, const int len = 0, const uint8_t requestType = 0, const uint8_t request = 0, const uint16_t valueHigh = 0, const uint16_t valueLow = 0, const uint16_t index = 0);
+                bool ControlIn(void* targ, const bool lsDevice, const int devAddress, const int packetSize, const int len = 0, const uint8_t requestType = 0, const uint8_t request = 0, const uint16_t valueHigh = 0, const uint16_t valueLow = 0, const uint16_t index = 0);
+                
+                bool BulkOut(const bool lsDevice, const int devAddress, const int packetSize, const int endP, void* bufPtr, const int len = 0);
+                bool BulkIn(const bool lsDevice, const int devAddress, const int packetSize, const int endP, void* bufPtr, const int len = 0);
+
+                void InterruptIn(const bool lsDevice, const int devAddress, const int packetSize, const int endP, int interval, USBDriver* handler, const int len = 0);
+
+                uint32_t HandleInterrupt(uint32_t esp);
+
+                //////////
+                // USB Controller Common Functions
+                //////////
+                
+                // Function that will get called on a periodic interval in which the controller can perform specific kinds of things.
+                void ControllerChecksThread() override;
+
+                // Perform a bulk in operation
+                bool BulkIn(USBDevice* device, void* retBuffer, int len, int endP) override;
+                // Perform a bulk out operation
+                bool BulkOut(USBDevice* device, void* sendBuffer, int len, int endP) override;
+
+                // Perform a control in operation
+                bool ControlIn(USBDevice* device, void* target = 0, const int len = 0, const uint8_t requestType = 0, const uint8_t request = 0, const uint16_t valueHigh = 0, const uint16_t valueLow = 0, const uint16_t index = 0) override;
+                // Perform a control out operation
+                bool ControlOut(USBDevice* device, const int len = 0, const uint8_t requestType = 0, const uint8_t request = 0, const uint16_t valueHigh = 0, const uint16_t valueLow = 0, const uint16_t index = 0) override;
+            
+                // Place a interrupt in transfer in the dedicated queue, handler will get called on completion
+                void InterruptIn(USBDevice* device, int len, int endP) override;
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/usb/controllers/xhci.h b/kernelz/include/system/drivers/usb/controllers/xhci.h
new file mode 100644
index 0000000..70bad34
--- /dev/null
+++ b/kernelz/include/system/drivers/usb/controllers/xhci.h
@@ -0,0 +1,240 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__USB__CONTROLLERS__XHCI_H
+#define __CACTUSOS__SYSTEM__DRIVERS__USB__CONTROLLERS__XHCI_H
+
+/*
+ * xHCI Support is not working yet, at the moment it is to much work to support the controller.
+ * Right now only the ohci,uhci and ehci are supported.
+ * Perhaps in the future this implementation will be made to a working state as well
+*/
+/*
+#include <system/drivers/driver.h>
+#include <system/components/pci.h>
+#include <system/interruptmanager.h>
+#include <system/usb/usbcontroller.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            #define xHC_CAPS_CapLength      0x00
+            #define xHC_CAPS_Reserved       0x01
+            #define xHC_CAPS_IVersion       0x02
+            #define xHC_CAPS_HCSParams1     0x04
+            #define xHC_CAPS_HCSParams2     0x08
+            #define xHC_CAPS_HCSParams3     0x0C
+            #define xHC_CAPS_HCCParams1     0x10
+            #define xHC_CAPS_DBOFF          0x14
+            #define xHC_CAPS_RTSOFF         0x18
+            #define xHC_CAPS_HCCParams2     0x1C
+
+            #define xHC_OPS_USBCommand      0x00
+            #define xHC_OPS_USBStatus       0x04
+            #define xHC_OPS_USBPageSize     0x08
+            #define xHC_OPS_USBDnctrl       0x14
+            #define xHC_OPS_USBCrcr         0x18
+            #define xHC_OPS_USBDcbaap       0x30
+            #define xHC_OPS_USBConfig       0x38
+
+            #define xHC_OPS_USBPortSt       0x400
+            #define xHC_Port_PORTSC             0
+            #define xHC_Port_PORTPMSC           4
+            #define xHC_Port_PORTLI             8
+            #define xHC_Port_PORTHLPMC         12
+
+            #define USB_TRHRSI    3   // No more than this between resets for root hubs
+            #define USB_TRSTRCY  10   // reset recovery
+            #define xHC_PortUSB_CHANGE_BITS  ((1<<17) | (1<<18) | (1<<20) | (1<<21) | (1<<22))
+
+            #define xHCI_PROTO_USB2  0
+            #define xHCI_PROTO_USB3  1
+
+            #define xHC_xECP_ID_NONE       0
+            #define xHC_xECP_ID_LEGACY     1
+            #define xHC_xECP_ID_PROTO      2
+            #define xHC_xECP_ID_POWER      3
+            #define xHC_xECP_ID_VIRT       4
+            #define xHC_xECP_ID_MESS       5
+            #define xHC_xECP_ID_LOCAL      6
+            #define xHC_xECP_ID_DEBUG     10
+            #define xHC_xECP_ID_EXT_MESS  17
+
+            // Port_info flags
+            #define xHCI_PROTO_INFO           (1<<0)  // bit 0 set = USB3, else USB2
+            #define xHCI_PROTO_HSO            (1<<1)  // bit 1 set = is USB 2 and High Speed Only
+            #define xHCI_PROTO_HAS_PAIR       (1<<2)  // bit 2 set = has a corresponding port. (i.e.: is a USB3 and has USB2 port (a must))
+                                                    //     clear = does not have a corr. port (i.e.: is a USB2 port and does not have a USB3 port)
+            #define xHCI_PROTO_ACTIVE         (1<<3)  // is the active port of the pair.
+
+            #define xHCI_IS_USB3_PORT(x)  ((port_info[(x)].flags & xHCI_PROTO_INFO) == xHCI_PROTO_USB3)
+            #define xHCI_IS_USB2_PORT(x)  ((port_info[(x)].flags & xHCI_PROTO_INFO) == xHCI_PROTO_USB2)
+            #define xHCI_IS_USB2_HSO(x)   ((port_info[(x)].flags & xHCI_PROTO_HSO) == xHCI_PROTO_HSO)
+            #define xHCI_HAS_PAIR(x)      ((port_info[(x)].flags & xHCI_PROTO_HAS_PAIR) == xHCI_PROTO_HAS_PAIR)
+            #define xHCI_IS_ACTIVE(x)     ((port_info[(x)].flags & xHCI_PROTO_ACTIVE) == xHCI_PROTO_ACTIVE)
+
+            #define xHC_xECP_LEGACY_TIMEOUT     10  // 10 milliseconds
+            #define xHC_xECP_LEGACY_BIOS_OWNED  (1<<16)
+            #define xHC_xECP_LEGACY_OS_OWNED    (1<<24)
+            #define xHC_xECP_LEGACY_OWNED_MASK  (xHC_xECP_LEGACY_BIOS_OWNED | xHC_xECP_LEGACY_OS_OWNED)
+            struct xHC_xECP_LEGACY {
+                uint32_t volatile id_next_owner_flags;
+                uint32_t volatile cntrl_status;
+            } __attribute__((packed));
+
+            struct xHCI_TRB {
+                uint64_t param;
+                uint16_t status;
+                uint16_t command;
+            } __attribute__((packed));
+
+            // event ring specification
+            struct xHCI_EVENT_SEG_TABLE {
+                uint64_t addr;
+                uint16_t size;
+                uint16_t resv;
+            } __attribute__((packed));
+
+            #define xHC_INTERRUPTER_IMAN      0x00
+            #define xHC_INTERRUPTER_IMOD      0x04
+            #define xHC_INTERRUPTER_TAB_SIZE  0x08
+            #define xHC_INTERRUPTER_RESV      0x0C
+            #define xHC_INTERRUPTER_ADDRESS   0x10
+            #define xHC_INTERRUPTER_DEQUEUE   0x18
+
+            #define TRB_GET_STYPE(x)     (((x) & (0x1F << 16)) >> 16)
+            #define TRB_SET_STYPE(x)     (((x) & 0x1F) << 16)
+            #define TRB_GET_TYPE(x)      (((x) & (0x3F << 10)) >> 10)
+            #define TRB_SET_TYPE(x)      (((x) & 0x3F) << 10)
+            #define TRB_GET_COMP_CODE(x) (((x) & (0x7F << 24)) >> 24)
+            #define TRB_SET_COMP_CODE(x) (((x) & 0x7F) << 24)
+            #define TRB_GET_SLOT(x)      (((x) & (0xFF << 24)) >> 24)
+            #define TRB_SET_SLOT(x)      (((x) & 0xFF) << 24)
+            #define TRB_GET_TDSIZE(x)    (((x) & (0x1F << 17)) >> 17)
+            #define TRB_SET_TDSIZE(x)    (((x) & 0x1F) << 17)
+            #define TRB_GET_EP(x)        (((x) & (0x1F << 16)) >> 16)
+            #define TRB_SET_EP(x)        (((x) & 0x1F) << 16)
+
+            #define TRB_GET_TARGET(x)    (((x) & (0x3FF << 22)) >> 22)
+            #define TRB_GET_TX_LEN(x)     ((x) & 0x1FFFF)
+            #define TRB_GET_TOGGLE(x)    (((x) & (1<<1)) >> 1)
+
+            #define TRB_DC(x)            (((x) & (1<<9)) >> 9)
+            #define TRB_IS_IMMED_DATA(x) (((x) & (1<<6)) >> 6)
+            #define TRB_IOC(x)           (((x) & (1<<5)) >> 5)
+            #define TRB_CHAIN(x)         (((x) & (1<<4)) >> 4)
+            #define TRB_SPD(x)           (((x) & (1<<2)) >> 2)
+            #define TRB_TOGGLE(x)        (((x) & (1<<1)) >> 1)
+
+            #define TRB_CYCLE_ON          (1<<0)
+            #define TRB_CYCLE_OFF         (0<<0)
+
+            #define TRB_TOGGLE_CYCLE_ON   (1<<1)
+            #define TRB_TOGGLE_CYCLE_OFF  (0<<1)
+
+            #define TRB_CHAIN_ON          (1<<4)
+            #define TRB_CHAIN_OFF         (0<<4)
+
+            #define TRB_IOC_ON            (1<<5)
+            #define TRB_IOC_OFF           (0<<5)
+
+            #define TRB_LINK_CMND         (TRB_SET_TYPE(LINK) | TRB_IOC_OFF | TRB_CHAIN_OFF | TRB_TOGGLE_CYCLE_OFF | TRB_CYCLE_ON)
+
+            // Common TRB types
+            enum { NORMAL=1, SETUP_STAGE, DATA_STAGE, STATUS_STAGE, ISOCH, LINK, EVENT_DATA, NO_OP,
+                ENABLE_SLOT=9, DISABLE_SLOT, ADDRESS_DEVICE, CONFIG_EP, EVALUATE_CONTEXT, RESET_EP,
+                STOP_EP=15, SET_TR_DEQUEUE, RESET_DEVICE, FORCE_EVENT, DEG_BANDWIDTH, SET_LAT_TOLERANCE,
+                GET_PORT_BAND=21, FORCE_HEADER, NO_OP_CMD,  // 24 - 31 = reserved
+                TRANS_EVENT=32, COMMAND_COMPLETION, PORT_STATUS_CHANGE, BANDWIDTH_REQUEST, DOORBELL_EVENT,
+                HOST_CONTROLLER_EVENT=37, DEVICE_NOTIFICATION, MFINDEX_WRAP, 
+                // 40 - 47 = reserved
+                // 48 - 63 = Vendor Defined
+            };
+
+            // event completion codes
+            enum { TRB_SUCCESS=1, DATA_BUFFER_ERROR, BABBLE_DETECTION, TRANSACTION_ERROR, TRB_ERROR, STALL_ERROR,
+                RESOURCE_ERROR=7, BANDWIDTH_ERROR, NO_SLOTS_ERROR, INVALID_STREAM_TYPE, SLOT_NOT_ENABLED, EP_NOT_ENABLED,
+                SHORT_PACKET=13, RING_UNDERRUN, RUNG_OVERRUN, VF_EVENT_RING_FULL, PARAMETER_ERROR, BANDWITDH_OVERRUN,
+                CONTEXT_STATE_ERROR=19, NO_PING_RESPONSE, EVENT_RING_FULL, INCOMPATIBLE_DEVICE, MISSED_SERVICE,
+                COMMAND_RING_STOPPED=24, COMMAND_ABORTED, STOPPED, STOPPER_LENGTH_ERROR, RESERVED, ISOCH_BUFFER_OVERRUN,
+                EVERN_LOST=32, UNDEFINED, INVALID_STREAM_ID, SECONDARY_BANDWIDTH, SPLIT_TRANSACTION
+                // 37 - 191 reserved
+                // 192 - 223 vender defined errors
+                // 224 - 225 vendor defined info
+            };
+
+            #define CMND_RING_TRBS   128  // not more than 4096
+
+            #define TRBS_PER_RING    256
+
+            #define xHCI_SPEED_FULL   1
+            #define xHCI_SPEED_LOW    2
+            #define xHCI_SPEED_HI     3
+            #define xHCI_SPEED_SUPER  4
+            #define XHCI_IRQ_DONE  (1<<31)
+
+            // Port_info:
+            struct S_XHCI_PORT_INFO {
+                uint8_t flags;                // port_info flags below
+                uint8_t other_port_num;       // zero based offset to other speed port
+                uint8_t offset;               // offset of this port within this protocol
+                uint8_t reserved;
+            } __attribute__((packed));
+
+            class XHCIController : public USBController, public Driver, public InterruptHandler
+            {
+            private:
+                PCIDevice* pciDevice;
+                uint32_t regBase;
+                uint8_t opRegOffset;
+
+                //Controller Registers
+                uint32_t hccparams1, hccparams2, hcsparams1, hcsparams2;
+                uint32_t rts_offset, db_offset; 
+                uint32_t context_size;
+                uint32_t pageSize;
+
+                //Memory Structures
+                uint32_t devContextAreaPhys, devContextAreaVirt;
+                uint32_t commandRingPhys, commandRingVirt;
+                uint32_t commandTrbPhys, commandTrbVirt;
+                uint32_t commandTrbCycle;
+                uint32_t curEventRingAddrPhys, curEventRingAddrVirt;
+                uint32_t curEventRingCycle;
+
+                //Port info
+                uint8_t numPorts;
+                S_XHCI_PORT_INFO port_info[16];
+            public:
+                XHCIController(PCIDevice* device);
+
+                bool Initialize() override;
+                void Setup() override;
+
+                bool ResetPort(const int port);
+                bool GetDescriptor(const int port);
+                uint32_t HandleInterrupt(uint32_t esp);
+
+                bool StopLegacy(uint32_t list_off);
+                uint32_t GetProtoOffset(uint32_t list_off, const int version, int* offset, int* count, uint16_t* flags);
+                uint32_t CreateRing(const int trbs);
+                uint32_t CreateEventRing(const int trbs, uint32_t* ret_addr);
+                bool SendCommand(struct xHCI_TRB* trb, const bool ring_it);
+                void GetTrb(struct xHCI_TRB* trb, const uint32_t address);
+                void SetTrb(struct xHCI_TRB* trb, const uint32_t address);
+
+                void WriteDoorbell(const uint32_t slot_id, const uint32_t val);
+                void WriteOpReg(const uint32_t offset, const uint32_t val);
+                void WriteOpReg64(const uint32_t offset, const uint64_t val);
+                uint32_t ReadOpReg(const uint32_t offset);
+                uint64_t ReadOpReg64(const uint32_t offset);
+                void writePrimaryIntr(const uint32_t offset, const uint32_t val);
+                void writePrimaryIntr64(const uint32_t offset, const uint64_t val);
+                uint32_t readPrimaryIntr(const uint32_t offset);
+                uint64_t readPrimaryIntr64(const uint32_t offset);
+            };
+        }
+    }
+}
+*/
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/usb/mass_storage.h b/kernelz/include/system/drivers/usb/mass_storage.h
new file mode 100644
index 0000000..ceaae16
--- /dev/null
+++ b/kernelz/include/system/drivers/usb/mass_storage.h
@@ -0,0 +1,168 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__USB__MASS_STORAGE_H
+#define __CACTUSOS__SYSTEM__DRIVERS__USB__MASS_STORAGE_H
+
+#include <system/drivers/usb/usbdriver.h>
+#include <system/disks/disk.h>
+#include <system/tasking/lock.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            #define SCSI_TEST_UNIT_READY        0x00
+            #define SCSI_REQUEST_SENSE          0x03
+            #define SCSI_INQUIRY                0x12
+            #define SCSI_READ_FORMAT_CAPACITIES 0x23
+            #define SCSI_READ_CAPACITY_10       0x25
+            #define SCSI_READ_CAPACITY_16       0x9E
+            #define SCSI_READ_10                0x28
+            #define SCSI_WRITE_10               0x2A
+            #define SCSI_READ_16                0x88
+            #define SCSI_WRITE_16               0x8A
+            //#define SCSI_READ_12                0xA8
+            //#define SCSI_WRITE_12               0xAA
+
+            #define CBW_SIGNATURE 0x43425355
+            #define CSW_SIGNATURE 0x53425355
+
+            typedef struct 
+            {
+                uint32_t signature;     // USBC in hexadecimal, acting as magic number
+                uint32_t tag;           // Signature
+                uint32_t transferLen;   // Number of bytes to transfer excluding size of CBW
+                uint8_t flags;          // 7: 0=Out 1=In, 6:0=Reserved
+                uint8_t lun;            // 7:4 Reserved, 3:0 Logical Unit Number
+                uint8_t cmdLen;         // Length of command in next field [1-16]
+                uint8_t command[16];    // Command Data
+            } __attribute__((packed)) CommandBlockWrapper;
+
+            typedef struct
+            {
+                uint32_t signature;     // CSW Magic number
+                uint32_t tag;           // Signature, same as CBW
+                uint32_t dataResidue;   // Difference in data actually read/written
+                uint8_t status;         // Status Byte
+            } __attribute__((packed)) CommandStatusWrapper;
+
+            typedef struct
+            {
+                uint8_t peripheralDeviceType : 5;
+                uint8_t peripheralQualifier : 3;
+                uint8_t resv1 : 7;
+                uint8_t RMB : 1;
+                uint8_t version;
+                uint8_t responseDataFormat : 4;
+                uint8_t HiSup : 1;
+                uint8_t NormACA : 1;
+                uint8_t resv2 : 2;
+                uint8_t additionalLength;
+                uint8_t prot : 1;
+                uint8_t resv3 : 2;
+                uint8_t _3PC : 1;
+                uint8_t TPGS : 2;
+                uint8_t ACC : 1;
+                uint8_t SCCS : 1;
+                uint8_t addr16 : 1;
+                uint8_t resv4 : 3;
+                uint8_t multiP : 1;
+                uint8_t VS1 : 1;
+                uint8_t ENCServ : 1;
+                uint8_t resv5 : 1;
+                uint8_t VS2 : 1;
+                uint8_t cmndQue : 1;
+                uint8_t resv6 : 2;
+                uint8_t SYNC : 1;
+                uint8_t wbus16 : 1;
+                uint8_t resv7 : 2;
+                char vendorInformation[8];
+                char productIdentification[16];
+                char productRevisionLevel[4];
+            } __attribute__((packed)) InquiryReturnBlock;
+
+            typedef struct
+            {
+                uint8_t reserved[3];
+                uint8_t listLength;
+            } __attribute__((packed)) CapacityListHeader;
+
+            typedef struct
+            {
+                uint32_t numberOfBlocks;
+                uint8_t descriptorCode : 2;
+                uint8_t reserved : 6;
+                uint32_t blockLength : 24;
+            } __attribute__((packed)) CapacityDescriptor;
+
+            typedef struct
+            {
+                uint32_t logicalBlockAddress;
+                uint32_t blockLength;
+            } __attribute__((packed)) Capacity10Block;
+
+            typedef struct
+            {
+                uint64_t logicalBlockAddress;
+                uint32_t blockLength;
+                uint8_t unused[20];
+            } __attribute__((packed)) Capacity16Block;
+
+            typedef struct
+            {
+                uint8_t errorCode : 7;
+                uint8_t valid : 1;
+                uint8_t resv1;
+                uint8_t senseKey : 4;
+                uint8_t resv2 : 1;
+                uint8_t ILI : 1;
+                uint8_t EOM : 1;
+                uint8_t fileMark : 1;
+                uint8_t information[4];
+                uint8_t additionalLength;
+                uint8_t resv3[4];
+                uint8_t ASC;
+                uint8_t ASCQ;
+                uint8_t FRUC;
+                uint8_t specific[3];
+            } __attribute__((packed)) RequestSenseBlock;
+
+            class USBMassStorageDriver : public USBDriver, public Disk
+            {
+            private:
+                int bulkInEP = 0;   // Endpoint number of bulk in
+                int bulkOutEP = 0;  // Endpoint number of bulk out
+                int maxLUN = 0;     // Number of Logical Units
+                
+                bool use16Base = false; // Should we read/write using the 16 command
+
+                MutexLock readWriteLock;
+            public:
+                // Create new driver for a MSD
+                USBMassStorageDriver(USBDevice* dev);
+
+                // Perform a SCSI In or Out operation on device
+                bool SCSIRequest(CommandBlockWrapper* request, uint8_t* dataPointer, int dataLength);
+
+                // Prepare Command Block for a specific request
+                CommandBlockWrapper SCSIPrepareCommandBlock(uint8_t command, int length, uint64_t lba = 0, int sectors = 0);
+                
+                // Perform a reset recovery process after stall
+                bool ResetRecovery();
+
+                // Called when mass storage device is plugged into system
+                bool Initialize() override;
+
+                // Called when mass storage device is unplugged from system
+                void DeInitialize() override;
+
+                // Read Sector from mass storage device
+                char ReadSector(common::uint32_t lba, common::uint8_t* buf) override;
+                // Write Sector to mass storage device
+                char WriteSector(common::uint32_t lba, common::uint8_t* buf) override;
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/usb/usbcomborecv.h b/kernelz/include/system/drivers/usb/usbcomborecv.h
new file mode 100644
index 0000000..d096eb2
--- /dev/null
+++ b/kernelz/include/system/drivers/usb/usbcomborecv.h
@@ -0,0 +1,42 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__USB__COMBORECEIVER_H
+#define __CACTUSOS__SYSTEM__DRIVERS__USB__COMBORECEIVER_H
+
+#include <system/drivers/usb/usbdriver.h>
+#include <system/usb/hidparser.h>
+#include <system/input/keyboard.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            // Class describing a device used for both keyboard and mouse input
+            class USBComboReceiver: public USBDriver, public Keyboard
+            {
+            private:
+                uint8_t prevPacket[8];
+
+                int keyboardIntEndpoint = -1;
+                int mouseIntEndpoint = -1;
+
+                int keyboardInterface = -1;
+                int mouseInterface = -1;
+            public:
+                // Instance initializer
+                USBComboReceiver(USBDevice* dev);
+                
+                // Called when device is plugged into system
+                bool Initialize() override;
+
+                // Called when device is unplugged from system
+                void DeInitialize() override;
+
+                // Called by USB driver when we receive a interrupt packet
+                bool HandleInterruptPacket(InterruptTransfer_t* transfer) override;
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/usb/usbdefs.h b/kernelz/include/system/drivers/usb/usbdefs.h
new file mode 100644
index 0000000..44a2869
--- /dev/null
+++ b/kernelz/include/system/drivers/usb/usbdefs.h
@@ -0,0 +1,161 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__USB__USBDEFS_H
+#define __CACTUSOS__SYSTEM__DRIVERS__USB__USBDEFS_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        // Reset wait times.  USB 2.0 specs, page 153, section 7.1.7.5, paragraph 3
+        #define USB_TDRSTR      50   // reset on a root hub
+        #define USB_TDRST       10   // minimum delay for a reset
+        #define USB_TRHRSI      3   // No more than this between resets for root hubs
+        #define USB_TRSTRCY     10   // reset recovery
+        #define PINDC_OFF       0b00
+        #define PINDC_AMBER     0b01
+        #define PINDC_GREEN     0b10
+        #define ENDP_CONTROL    0
+
+        struct DEVICE_DESC {
+            common::uint8_t  len;
+            common::uint8_t  type;
+            common::uint16_t usb_ver;
+            common::uint8_t  _class;
+            common::uint8_t  subclass;
+            common::uint8_t  protocol;
+            common::uint8_t  max_packet_size;
+            common::uint16_t vendorid;
+            common::uint16_t productid;
+            common::uint16_t device_rel;
+            common::uint8_t  manuf_indx;   // index value
+            common::uint8_t  prod_indx;    // index value
+            common::uint8_t  serial_indx;  // index value
+            common::uint8_t  configs;      // Number of configurations
+        } __attribute__((packed));
+
+        struct REQUEST_PACKET {
+            common::uint8_t  request_type;
+            common::uint8_t  request;
+            common::uint16_t value;
+            common::uint16_t index;
+            common::uint16_t length;
+        } __attribute__((packed));
+
+        // config descriptor
+        struct CONFIG_DESC {
+            common::uint8_t  len;
+            common::uint8_t  type;
+            common::uint16_t tot_len;
+            common::uint8_t  num_interfaces;
+            common::uint8_t  config_val;
+            common::uint8_t  config_indx;
+            common::uint8_t  bm_attrbs;
+            common::uint8_t  max_power;
+        } __attribute__((packed));
+
+        struct STRING_DESC {
+            common::uint8_t  len;         // length of whole desc in bytes
+            common::uint8_t  type;
+            common::uint16_t string[127];
+        } __attribute__((packed));
+
+        struct INTERFACE_ASSOSIATION_DESC {
+            common::uint8_t  len;             // len of this desc (8)
+            common::uint8_t  type;            // type = 11
+            common::uint8_t  interface_num;   // first interface number to start association
+            common::uint8_t  count;           // count of continuous interfaces for association
+            common::uint8_t  _class;          //
+            common::uint8_t  subclass;        //
+            common::uint8_t  protocol;        //
+            common::uint8_t  function_indx;   // string id of this association
+        } __attribute__((packed));
+
+        // interface descriptor
+        struct INTERFACE_DESC {
+            common::uint8_t  len;
+            common::uint8_t  type;
+            common::uint8_t  interface_num;
+            common::uint8_t  alt_setting;
+            common::uint8_t  num_endpoints;
+            common::uint8_t  interface_class;
+            common::uint8_t  interface_sub_class;
+            common::uint8_t  interface_protocol;
+            common::uint8_t  interface_indx;
+        } __attribute__((packed));
+
+        // endpoint descriptor
+        struct ENDPOINT_DESC {
+            common::uint8_t  len;
+            common::uint8_t  type;
+            common::uint8_t  end_point;        // 6:0 end_point number, 7 = IN (set) or OUT (clear)
+            common::uint8_t  bm_attrbs;        // 
+            common::uint16_t max_packet_size;  // 10:0 = max_size, 12:11 = max transactions, 15:13 = reserved
+            common::uint8_t  interval;
+        } __attribute__((packed));
+
+        struct IF_HID_DESC {
+            common::uint8_t  len;
+            common::uint8_t  type;
+            common::uint16_t release;
+            common::uint8_t  countryCode;
+            common::uint8_t  numDescriptors;
+            // Types and lenght folowing below 
+        } __attribute__((packed));
+
+        // setup packets
+        #define DEV_TO_HOST     0x80
+        #define HOST_TO_DEV     0x00
+        #define REQ_TYPE_STNDRD 0x00
+        #define REQ_TYPE_CLASS  0x20
+        #define REQ_TYPE_VENDOR 0x40
+        #define REQ_TYPE_RESV   0x60
+        #define RECPT_DEVICE    0x00
+        #define RECPT_INTERFACE 0x01
+        #define RECPT_ENDPOINT  0x02
+        #define RECPT_OTHER     0x03
+        #define STDRD_GET_REQUEST   (DEV_TO_HOST | REQ_TYPE_STNDRD | RECPT_DEVICE)
+        #define STDRD_SET_REQUEST   (HOST_TO_DEV | REQ_TYPE_STNDRD | RECPT_DEVICE)
+        #define STDRD_SET_INTERFACE (HOST_TO_DEV | REQ_TYPE_STNDRD | RECPT_INTERFACE)
+
+        // device requests
+        enum DeviceRequest { GET_STATUS=0, CLEAR_FEATURE, SET_FEATURE=3, SET_ADDRESS=5, GET_DESCRIPTOR=6, SET_DESCRIPTOR,
+                GET_CONFIGURATION, SET_CONFIGURATION,
+        // interface requests
+                GET_INTERFACE, SET_INTERFACE,
+        // standard endpoint requests
+                SYNCH_FRAME,
+        // Device specific
+                GET_MAX_LUNS = 0xFE, BULK_ONLY_RESET
+        };
+
+        // Descriptor types
+        enum DescriptorTypes { 
+            DEVICE=1, 
+            CONFIG, 
+            STRING, 
+            INTERFACE, 
+            ENDPOINT, 
+            DEVICE_QUALIFIER,
+            OTHER_SPEED_CONFIG, 
+            INTERFACE_POWER, 
+            OTG, 
+            DEBUG, 
+            INTERFACE_ASSOSIATION,
+            
+            HID=0x21,
+            HID_REPORT, 
+            HID_PHYSICAL, 
+            
+            INTERFACE_FUNCTION = 0x24,
+            ENDPOINT_FUNCTION,
+            
+            HUB = 0x29
+        };
+
+        #define HID_REQUEST_SET_IDLE 0x0A
+        #define HID_REQUEST_SET_PROTOCOL 0x0B
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/usb/usbdriver.h b/kernelz/include/system/drivers/usb/usbdriver.h
new file mode 100644
index 0000000..77043cb
--- /dev/null
+++ b/kernelz/include/system/drivers/usb/usbdriver.h
@@ -0,0 +1,32 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__USB__USBDRIVER_H
+#define __CACTUSOS__SYSTEM__DRIVERS__USB__USBDRIVER_H
+
+#include <system/drivers/driver.h>
+#include <system/usb/usbdevice.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        typedef struct InterruptTransfer InterruptTransfer_t;
+
+        class USBDriver : public drivers::Driver
+        {
+        public:
+            // Which device is this driver for
+            USBDevice* device;
+        public:
+            USBDriver(USBDevice* dev, char* driverName);
+            virtual ~USBDriver();
+
+            // De-Active this driver from the system
+            // Called when device is unplugged
+            virtual void DeInitialize();
+
+            // Called from USB Controller when a interrupt packet is received
+            virtual bool HandleInterruptPacket(InterruptTransfer_t* transfer);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/usb/usbkeyboard.h b/kernelz/include/system/drivers/usb/usbkeyboard.h
new file mode 100644
index 0000000..1d294ed
--- /dev/null
+++ b/kernelz/include/system/drivers/usb/usbkeyboard.h
@@ -0,0 +1,40 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__USB__KEYBOARD_H
+#define __CACTUSOS__SYSTEM__DRIVERS__USB__KEYBOARD_H
+
+#include <system/drivers/usb/usbdriver.h>
+#include <system/usb/hidparser.h>
+#include <system/input/keyboard.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            class USBKeyboard : public USBDriver, public Keyboard
+            {
+            private:
+                int InInterruptEndpoint = -1;
+
+                uint8_t prevPacket[8];
+            public:
+                // Instance initializer
+                USBKeyboard(USBDevice* dev);
+                
+                // Called when mass storage device is plugged into system
+                bool Initialize() override;
+
+                // Called when mass storage device is unplugged from system
+                void DeInitialize() override;
+
+                // Called by USB driver when we receive a interrupt packet
+                bool HandleInterruptPacket(InterruptTransfer_t* transfer) override;
+
+                // Update LED's on a keyboard device
+                void UpdateLEDS() override;
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/usb/usbmouse.h b/kernelz/include/system/drivers/usb/usbmouse.h
new file mode 100644
index 0000000..0d110c2
--- /dev/null
+++ b/kernelz/include/system/drivers/usb/usbmouse.h
@@ -0,0 +1,42 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__USB__MOUSE_H
+#define __CACTUSOS__SYSTEM__DRIVERS__USB__MOUSE_H
+
+#include <system/drivers/usb/usbdriver.h>
+#include <system/usb/hidparser.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            class USBMouse : public USBDriver
+            {
+            private:
+                HIDParser hidParser;
+                bool GetHIDProperty(struct HID_DATA* target, uint8_t* buffer, int bufLen, HID_USAGE item);
+
+                bool useCustomReport = false;
+                struct HID_DATA hidX;
+                struct HID_DATA hidY;
+                struct HID_DATA hidZ;
+
+                int InInterruptEndpoint = -1;
+            public:
+                // Instance initializer
+                USBMouse(USBDevice* dev);
+                
+                // Called when device is plugged into system
+                bool Initialize() override;
+
+                // Called when device is unplugged from system
+                void DeInitialize() override;
+
+                // Called by USB driver when we receive a interrupt packet
+                bool HandleInterruptPacket(InterruptTransfer_t* transfer) override;
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/drivers/video/vmwaresvga.h b/kernelz/include/system/drivers/video/vmwaresvga.h
new file mode 100644
index 0000000..278bdc2
--- /dev/null
+++ b/kernelz/include/system/drivers/video/vmwaresvga.h
@@ -0,0 +1,54 @@
+#ifndef __CACTUSOS__SYSTEM__DRIVERS__VMWARESVGA_H
+#define __CACTUSOS__SYSTEM__DRIVERS__VMWARESVGA_H
+
+#include <system/drivers/driver.h>
+#include <system/components/pci.h>
+#include <system/interruptmanager.h>
+#include <system/components/graphicsdevice.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        namespace drivers
+        {
+            #define VMWARESVGAII_VENDORID 0x15AD
+            #define VMWARESVGAII_DEVICEID 0x0405
+
+            #define SVGA_INDEX_PORT         0x0
+            #define SVGA_VALUE_PORT         0x1
+            #define SVGA_BIOS_PORT          0x2
+            #define SVGA_IRQSTATUS_PORT     0x8
+
+            #define SVGA_MAGIC         0x900000UL
+            #define SVGA_MAKE_ID(ver)  (SVGA_MAGIC << 8 | (ver))
+
+            /* Version 2 let the address of the frame buffer be unsigned on Win32 */
+            #define SVGA_VERSION_2     2
+            #define SVGA_ID_2          SVGA_MAKE_ID(SVGA_VERSION_2)
+
+            #define SVGA_REG_ID 0
+            #define SVGA_REG_FB_START 13
+            #define SVGA_REG_FB_Enable 1
+            #define SVGA_REG_FB_Width 2
+            #define SVGA_REG_FB_Height 3
+            #define SVGA_REG_FB_BitsPerPixel 7
+
+            class VMWARESVGAII : public Driver, public GraphicsDevice
+            {
+            private:
+                PCIDevice* pciDevice;
+
+                void WriteRegister(common::uint32_t reg, common::uint32_t value);
+                common::uint32_t ReadRegister(common::uint32_t reg);
+            public:
+                VMWARESVGAII(PCIDevice* pciDev);
+
+                bool Initialize();
+                bool SelectBestVideoMode();
+            };
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/initrd.h b/kernelz/include/system/initrd.h
new file mode 100644
index 0000000..d9405a7
--- /dev/null
+++ b/kernelz/include/system/initrd.h
@@ -0,0 +1,30 @@
+#ifndef __CACTUSOS__SYSTEM__INITRD_H
+#define __CACTUSOS__SYSTEM__INITRD_H
+
+#include <common/types.h>
+#include <multiboot/multiboot.h>
+#include <system/bootconsole.h>
+#include <common/string.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        struct InitrdFileHeader
+        {
+            char name[30];
+            char path[100];
+            common::uint32_t size;
+        } __attribute__((packed));
+
+        class InitialRamDisk
+        {
+        public:
+            static void Initialize(multiboot_info_t* mbi);
+
+            static void* ReadFile(const char* path, common::uint32_t* fileSizeReturn = 0);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/input/keyboard.h b/kernelz/include/system/input/keyboard.h
new file mode 100644
index 0000000..a1cf2c6
--- /dev/null
+++ b/kernelz/include/system/input/keyboard.h
@@ -0,0 +1,55 @@
+#ifndef __CACTUSOS__SYSTEM__INPUT__KEYBOARD_H
+#define __CACTUSOS__SYSTEM__INPUT__KEYBOARD_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        // Structure for modifier keys that are keyboard specific
+        struct InternalKeyboardStatus
+        {
+            bool LeftShift;
+            bool RightShift;
+
+            bool Alt;
+            bool AltGr;
+            
+            bool LeftControl;
+            bool RightControl;
+        };
+
+        // Structure for shared modifier keys between keyboards
+        struct KeyboardStatus
+        {
+            bool CapsLock;
+            bool NumLock;
+        };
+        
+        // Types of keyboards currently supported
+        enum KeyboardType
+        {
+            PS2,
+            USB
+        };
+
+        // Interface for providing a common access for all keyboard devices
+        class Keyboard
+        {
+        public:
+            KeyboardType type;
+            InternalKeyboardStatus status;
+        public:
+            Keyboard(KeyboardType type);
+
+            // Update LED's on a keyboard device
+            virtual void UpdateLEDS();
+            
+            // Checks if the buffer contains the given key, also returns position of key
+            bool ContainsKey(common::uint8_t key, common::uint8_t* packet, int* pos);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/input/keyboardmanager.h b/kernelz/include/system/input/keyboardmanager.h
new file mode 100644
index 0000000..a0043d4
--- /dev/null
+++ b/kernelz/include/system/input/keyboardmanager.h
@@ -0,0 +1,33 @@
+#ifndef __CACTUSOS__SYSTEM__INPUT__KEYBOARDMANAGER_H
+#define __CACTUSOS__SYSTEM__INPUT__KEYBOARDMANAGER_H
+
+#include <system/input/keyboard.h>
+#include <common/list.h>
+#include <system/memory/fifostream.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        // Class responsable for managing all keyboard devices present on the system
+        // Also provides a stream interface to read keystrokes 
+        class KeyboardManager : public FIFOStream
+        {
+        public:
+            // List of all keyboards present on system
+            List<Keyboard*> keyboards;
+
+            // Status of all keyboards
+            KeyboardStatus sharedStatus;
+        private:
+            uint8_t ConvertToPS2(uint32_t key);
+        public:
+            KeyboardManager();
+
+            // Handle a keypress or a change in modifier keys
+            void HandleKeyChange(Keyboard* src, uint32_t key, bool pressed);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/interruptmanager.h b/kernelz/include/system/interruptmanager.h
new file mode 100644
index 0000000..4756649
--- /dev/null
+++ b/kernelz/include/system/interruptmanager.h
@@ -0,0 +1,34 @@
+#ifndef __CACTUSOS__SYSTEM__INTERRUPTMANAGER_H
+#define __CACTUSOS__SYSTEM__INTERRUPTMANAGER_H
+
+#include <common/list.h>
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class InterruptHandler
+        {
+        public: 
+            InterruptHandler(common::uint8_t intNumber);
+            virtual common::uint32_t HandleInterrupt(common::uint32_t esp);
+        };
+
+
+        class InterruptManager
+        {
+        private:
+            static List<InterruptHandler*>* interruptCallbacks[256];
+        public:
+            static void Initialize();
+            static common::uint32_t HandleInterrupt(common::uint8_t interrupt, common::uint32_t esp);
+
+            static void AddHandler(InterruptHandler* handler, common::uint8_t interrupt);
+            static void RemoveHandler(InterruptHandler* handler, common::uint8_t interrupt);
+        };  
+    }
+}
+
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/listings/directorylisting.h b/kernelz/include/system/listings/directorylisting.h
new file mode 100644
index 0000000..3c914bc
--- /dev/null
+++ b/kernelz/include/system/listings/directorylisting.h
@@ -0,0 +1,37 @@
+#ifndef __CACTUSOS__SYSTEM__LISTINGS__DIRECTORYLISTING_H
+#define __CACTUSOS__SYSTEM__LISTINGS__DIRECTORYLISTING_H
+
+#include <system/listings/listingcontroller.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        // A class that is responsable for processes which request a directory list
+        class DirectoryListing : public ListingController
+        {
+        public:
+            /**
+            Create new instance of DirectoryListing
+            */
+            DirectoryListing();
+
+            /**
+            Begin processing a new directorylist request
+            Returns amount of items in directory
+            */
+            int BeginListing(Thread* thread, uint32_t pathPtr) override;
+            /**
+            Get an item from the current request.
+            Returns characters in file/dirname
+            */
+            int GetEntry(Thread* thread, int entry, uint32_t bufPtr) override;
+            /**
+            End the current listing
+            */
+            void EndListing(Thread* thread) override;
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/listings/listingcontroller.h b/kernelz/include/system/listings/listingcontroller.h
new file mode 100644
index 0000000..91e28c0
--- /dev/null
+++ b/kernelz/include/system/listings/listingcontroller.h
@@ -0,0 +1,34 @@
+#ifndef __CACTUSOS__SYSTEM__VFS__LISTINGCONTROLLER_H
+#define __CACTUSOS__SYSTEM__VFS__LISTINGCONTROLLER_H
+
+#include <system/vfs/virtualfilesystem.h>
+#include <system/tasking/process.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        // A class that creates an easy interface for threads to request a list from the kernel.
+        // This can for example be a list of files or processes.
+        class ListingController
+        {
+        protected:
+            // Threads that have also requested a listing before an other one was finished.
+            List<Thread*> waitingQueue;
+            
+            // Current thread which has requested a list
+            Thread* currentReqThread;
+
+            // Are we currently handling a request?
+            bool requestBusy = false;
+        public:
+            ListingController();
+
+            virtual int BeginListing(Thread* thread, uint32_t arg1 = 0);
+            virtual int GetEntry(Thread* thread, int entry, uint32_t bufPtr);
+            virtual void EndListing(Thread* thread);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/listings/systeminfo.h b/kernelz/include/system/listings/systeminfo.h
new file mode 100644
index 0000000..70495a0
--- /dev/null
+++ b/kernelz/include/system/listings/systeminfo.h
@@ -0,0 +1,56 @@
+#ifndef __CACTUSOS__SYSTEM__LISTINGS__SYSTEMINFO_H
+#define __CACTUSOS__SYSTEM__LISTINGS__SYSTEMINFO_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        struct SIBIOS
+        {
+            char* vendor = "N/A";
+            char* version = "N/A";
+            char* releaseDate = "N/A";
+        };
+
+        struct SISYSTEM
+        {
+            char* manufacturer = "N/A";
+            char* product = "N/A";
+            char* version = "N/A";
+            char* serial = "N/A";
+            char* sku = "N/A";
+            char* family = "N/A";  
+        };
+
+        struct SIENCLOSURE
+        {
+            char* manufacturer = "N/A";
+            char* version = "N/A";
+            char* serial = "N/A";
+            char* sku = "N/A";
+        };
+
+        struct SIPROCESSOR
+        {
+            char* socket = "N/A";
+            char* manufacturer = "N/A";
+            char* version = "N/A";
+        };       
+
+        class SystemInfoManager
+        {
+        public:
+            static SIBIOS       bios;
+            static SISYSTEM     system;
+            static SIENCLOSURE  enclosure;
+            static SIPROCESSOR  processor;
+        public:
+            // Handle a request from a syscall to get information about the system
+            static bool HandleSysinfoRequest(void* arrayPointer, int count, common::uint32_t retAddr, bool getSize);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/log.h b/kernelz/include/system/log.h
new file mode 100644
index 0000000..7c0f3db
--- /dev/null
+++ b/kernelz/include/system/log.h
@@ -0,0 +1,24 @@
+#ifndef __CACTUSOS__SYSTEM__LOG_H
+#define __CACTUSOS__SYSTEM__LOG_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        #define LOG_SHOW_MS 1
+
+        enum LogLevel
+        {
+            Info,
+            Warning,
+            Error
+        };
+
+        void Log(LogLevel level, const char* __restrict__ format, ...);
+        void Print(const char* data, common::uint32_t length);
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/memory/deviceheap.h b/kernelz/include/system/memory/deviceheap.h
new file mode 100644
index 0000000..f450302
--- /dev/null
+++ b/kernelz/include/system/memory/deviceheap.h
@@ -0,0 +1,34 @@
+#ifndef __CACTUSOS__SYSTEM__DEVICEHEAP_H
+#define __CACTUSOS__SYSTEM__DEVICEHEAP_H
+
+#include <core/virtualmemory.h>
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        // Memory reserved for devices, 100MB Should be more than enough
+        #define DEVICE_HEAP_SIZE 100_MB
+
+        #define DEVICE_HEAP_START (KERNEL_HEAP_START + KERNEL_HEAP_SIZE + 4_MB)
+        #define DEVICE_HEAP_END (DEVICE_HEAP_START + DEVICE_HEAP_SIZE)
+
+        // Class that can allocate memory for memory mapped devices
+        class DeviceHeap
+        {
+        private:
+            // Current address of last memory allocation
+            // Will increase on every allocation
+            static common::uint32_t currentAddress;
+        public:
+            // Allocate a chunck of memory in the virtual address space
+            // Must be a page aligned size
+            // Note: Memory needs to be mapped to right address afterwards, function does not include this
+            static common::uint32_t AllocateChunk(common::uint32_t size);
+        };
+    }
+}
+
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/memory/fifostream.h b/kernelz/include/system/memory/fifostream.h
new file mode 100644
index 0000000..ec3c782
--- /dev/null
+++ b/kernelz/include/system/memory/fifostream.h
@@ -0,0 +1,50 @@
+#ifndef __CACTUSOS__SYSTEM__MEMORY__FIFOSTREAM_H
+#define __CACTUSOS__SYSTEM__MEMORY__FIFOSTREAM_H
+
+#include <common/types.h>
+#include <common/memoryoperations.h>
+#include <system/memory/stream.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class FIFOStream : public Stream
+        {
+        private:
+            // Internal buffer
+            char* buffer;
+            // End of the internal buffer
+            char* buffer_end;
+            // Number of items in the buffer
+            int count;
+            // Maximum allowed items
+            int capacity;
+            // Pointer to head
+            char* head;
+            // Pointer to tail
+            char* tail;
+        public:
+            /**
+             * Create a new fifo stream
+            */
+            FIFOStream(int capacity = 100);
+            ~FIFOStream();
+
+            /**
+             * Read a byte from this stream
+            */
+            char Read();
+            /**
+             * Write a byte to this stream buffer
+            */
+            void Write(char byte);
+            /**
+             * How many bytes can currently be read?
+            */
+            int Available();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/memory/heap.h b/kernelz/include/system/memory/heap.h
new file mode 100644
index 0000000..95ff22f
--- /dev/null
+++ b/kernelz/include/system/memory/heap.h
@@ -0,0 +1,63 @@
+#ifndef __CACTUSOS__SYSTEM__HEAP_H
+#define __CACTUSOS__SYSTEM__HEAP_H
+
+#include <core/virtualmemory.h>
+#include <system/tasking/lock.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        #define KERNEL_HEAP_START (KERNEL_VIRT_ADDR + 4_MB)
+        #define KERNEL_HEAP_SIZE 16_MB
+
+        // Only split a memory block when we can use it to store this amount of data in it
+        #define MINIMAL_SPLIT_SIZE 4
+        
+        // Magic number used for memory headers
+        #define MEMORY_HEADER_MAGIC 1234567890
+
+        #ifndef align_up
+        #define align_up(num, align) \
+            (((num) + ((align) - 1)) & ~((align) - 1))
+        #endif
+
+        struct MemoryHeader
+        {
+            common::uint32_t magic;
+
+            MemoryHeader* next;
+            MemoryHeader* prev;
+            common::uint32_t allocated;
+            common::uint32_t size;
+        } __attribute__((packed));
+
+        class KernelHeap
+        {
+        private:
+            static common::uint32_t startAddress;
+            static common::uint32_t endAddress;
+
+            static MemoryHeader* firstHeader;
+
+            static void* InternalAllocate(common::uint32_t size);
+            static MemoryHeader* FirstFree(common::uint32_t size);
+
+            static MutexLock heapMutex;
+        public:
+            static void Initialize(common::uint32_t start, common::uint32_t end);
+
+            static void* malloc(common::uint32_t size, common::uint32_t* physReturn = 0);
+            static void free(void* ptr);
+
+            static void* alignedMalloc(common::uint32_t size, common::uint32_t align, common::uint32_t* physReturn = 0);
+            static void allignedFree(void* ptr);
+
+            static bool CheckForErrors();
+            static common::uint32_t UsedMemory();
+        };
+    }
+}
+
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/memory/new.h b/kernelz/include/system/memory/new.h
new file mode 100644
index 0000000..065d32d
--- /dev/null
+++ b/kernelz/include/system/memory/new.h
@@ -0,0 +1,48 @@
+#ifndef __CACTUSOS__SYSTEM__NEW_H
+#define __CACTUSOS__SYSTEM__NEW_H
+
+#include <stddef.h>
+#include <system/memory/heap.h>
+
+using namespace CactusOS::system;
+ 
+void *operator new(size_t size)
+{
+    return KernelHeap::malloc(size);
+}
+ 
+void *operator new[](size_t size)
+{
+    return KernelHeap::malloc(size);
+}
+
+void* operator new(size_t size, void* ptr)
+{
+    return ptr;
+}
+
+void* operator new[](size_t size, void* ptr)
+{
+    return ptr;
+}
+ 
+void operator delete(void *p)
+{
+    KernelHeap::free(p);
+}
+ 
+void operator delete[](void *p)
+{
+    KernelHeap::free(p);
+}
+
+void operator delete(void* ptr, size_t size)
+{
+    KernelHeap::free(ptr);
+}
+void operator delete[](void* ptr, size_t size)
+{
+    KernelHeap::free(ptr);
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/memory/sharedmem.h b/kernelz/include/system/memory/sharedmem.h
new file mode 100644
index 0000000..9f418f8
--- /dev/null
+++ b/kernelz/include/system/memory/sharedmem.h
@@ -0,0 +1,42 @@
+#ifndef __CACTUSOS__SYSTEM__MEMORY__SHAREDMEM_H
+#define __CACTUSOS__SYSTEM__MEMORY__SHAREDMEM_H
+
+#include <system/tasking/process.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class SharedMemory
+        {
+        public:
+            /**
+             * Create a shared area of memory between processes
+             * Proc1: Procces 1 where the memory needs to be present
+             * Proc2: Process 2 where the memory needs to be present
+             * virtStart: The virtual start of the memory region
+             * len: The length of the memory region
+            */
+            static bool CreateSharedRegion(Process* proc1, Process* proc2, common::uint32_t virtStart, common::uint32_t len);
+            /**
+             * Create a shared area of memory between processes
+             * Proc1: Procces 1 where the memory needs to be present
+             * Proc2: Process 2 where the memory needs to be present
+             * virtStart1: The virtual start of the memory region for process 1
+             * virtStart2: The virtual start of the memory region for process 2
+             * len: The length of the memory region
+            */
+            static bool CreateSharedRegion(Process* proc1, Process* proc2, common::uint32_t virtStart1, common::uint32_t virtStart2, common::uint32_t len);
+            /**
+             * Remove shared memory between 2 processes 
+            */
+            static bool RemoveSharedRegion(Process* proc1, Process* proc2, common::uint32_t virtStart, common::uint32_t len);
+            /**
+             * Remove shared memory between 2 processes 
+            */
+            static bool RemoveSharedRegion(Process* proc1, Process* proc2, common::uint32_t virtStart1, common::uint32_t virtStart2, common::uint32_t len);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/memory/stream.h b/kernelz/include/system/memory/stream.h
new file mode 100644
index 0000000..e07f38d
--- /dev/null
+++ b/kernelz/include/system/memory/stream.h
@@ -0,0 +1,38 @@
+#ifndef __CACTUSOS__SYSTEM__MEMORY__STREAM_H
+#define __CACTUSOS__SYSTEM__MEMORY__STREAM_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class Stream
+        {
+        public:
+            /**
+             * Create a new instance of the stream class
+            */
+            Stream();
+            /**
+             * Delete the stream and free all the memory it has used
+            */
+            virtual ~Stream();
+
+            /**
+             * Read a byte from this stream
+            */
+            virtual char Read();
+            /**
+             * Write a byte to this stream buffer
+            */
+            virtual void Write(char byte);
+            /**
+             * How many bytes can currently be read?
+            */
+            virtual int Available();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/serialport.h b/kernelz/include/system/serialport.h
new file mode 100644
index 0000000..e1729b9
--- /dev/null
+++ b/kernelz/include/system/serialport.h
@@ -0,0 +1,38 @@
+#ifndef __CACTUSOS__SYSTEM__SERIALPORT_H
+#define __CACTUSOS__SYSTEM__SERIALPORT_H
+
+#include <common/types.h>
+#include <core/port.h>
+#include <system/serialport.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        enum COMPort
+        {
+            COM1 = 0x3F8,
+            COM2 = 0x2F8,
+            COM3 = 0x3E8,
+            COM4 = 0x2E8
+        };
+
+        class Serialport
+        {
+        private:
+            static COMPort PortAddress;
+        public:
+            static int SerialReceiveReady();
+            static int SerialSendReady();
+
+            static bool Initialized;
+            static void Init(COMPort port);
+
+            static char Read();
+            static void Write(char a);
+            static void WriteStr(char* str);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/syscalls/implementations/cactusos.h b/kernelz/include/system/syscalls/implementations/cactusos.h
new file mode 100644
index 0000000..eeab027
--- /dev/null
+++ b/kernelz/include/system/syscalls/implementations/cactusos.h
@@ -0,0 +1,18 @@
+#ifndef __CACTUSOS__SYSTEM__SYSCALLS__IMPLEMENTATIONS_CACTUSOS_H
+#define __CACTUSOS__SYSTEM__SYSCALLS__IMPLEMENTATIONS_CACTUSOS_H
+
+#include <core/registers.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class CactusOSSyscalls
+        {
+        public:
+            static core::CPUState* HandleSyscall(core::CPUState* state);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/syscalls/implementations/linux.h b/kernelz/include/system/syscalls/implementations/linux.h
new file mode 100644
index 0000000..f9dbc7a
--- /dev/null
+++ b/kernelz/include/system/syscalls/implementations/linux.h
@@ -0,0 +1,18 @@
+#ifndef __CACTUSOS__SYSTEM__SYSCALLS__IMPLEMENTATIONS_LINUX_H
+#define __CACTUSOS__SYSTEM__SYSCALLS__IMPLEMENTATIONS_LINUX_H
+
+#include <core/registers.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class LinuxSyscalls
+        {
+        public:
+            static core::CPUState* HandleSyscall(core::CPUState* state);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/syscalls/syscalls.h b/kernelz/include/system/syscalls/syscalls.h
new file mode 100644
index 0000000..ac89ae9
--- /dev/null
+++ b/kernelz/include/system/syscalls/syscalls.h
@@ -0,0 +1,20 @@
+#ifndef __CACTUSOS__SYSTEM__SYSCALLS__SYSCALLS_H
+#define __CACTUSOS__SYSTEM__SYSCALLS__SYSCALLS_H
+
+#include <system/interruptmanager.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class SystemCallHandler : public InterruptHandler
+        {
+        public:
+            SystemCallHandler();
+
+            common::uint32_t HandleInterrupt(common::uint32_t esp);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/system.h b/kernelz/include/system/system.h
new file mode 100644
index 0000000..001c123
--- /dev/null
+++ b/kernelz/include/system/system.h
@@ -0,0 +1,142 @@
+#ifndef __CACTUSOS__SYSTEM__SYSTEM_H
+#define __CACTUSOS__SYSTEM__SYSTEM_H
+
+#define BOCHS_GFX_HACK 0        // Enable or disable the bochs hack
+#define ENABLE_USB 1            // Enable USB-Stack
+#define ENABLE_MEMORY_CHECKS 1  // Enable the checking of memory on a specified interval
+#define ENABLE_ADV_DEBUG 1      // Enable advanced debugging features
+
+#include <system/bootconsole.h>
+#include <system/components/systemcomponent.h>
+#include <system/components/pit.h>
+#include <system/components/rtc.h>
+#include <system/components/smbios.h>
+#include <system/components/graphicsdevice.h>
+#include <system/components/vesa.h>
+#include <system/components/edid.h>
+#include <system/components/pci.h>
+#include <system/components/apm.h>
+#include <system/components/dma.h>
+#include <system/virtual8086/VM86Manager.h>
+#include <system/virtual8086/VM86Monitor.h>
+
+#include <system/initrd.h>
+#include <system/drivers/drivermanager.h>
+#include <system/drivers/pcidrivers.h>
+#include <system/drivers/integrated/ps2-mouse.h>
+#include <system/drivers/integrated/ps2-keyboard.h>
+#include <system/drivers/integrated/floppy.h>
+#include <system/disks/diskmanager.h>
+#include <system/disks/partitionmanager.h>
+#include <system/vfs/vfsmanager.h>
+#include <system/tasking/scheduler.h>
+#include <system/syscalls/syscalls.h>
+#include <common/random.h>
+#include <system/tasking/ipcmanager.h>
+#include <system/memory/sharedmem.h>
+#include <system/listings/listingcontroller.h>
+#include <system/usb/usbmanager.h>
+#include <system/input/keyboardmanager.h>
+
+#include <system/log.h>
+#include <system/debugger.h>
+#include <../../lib/include/systeminfo.h>
+
+#define GDB_BREAK() asm("int $3");
+
+namespace CactusOS
+{
+    namespace system
+    {
+        #define DEFAULT_SCREEN_WIDTH 1024
+        #define DEFAULT_SCREEN_HEIGHT 768
+        #define DEFAULT_SCREEN_BPP 32
+
+        enum ScreenMode
+        {
+            TextMode,
+            GraphicsMode
+        };
+
+        enum PowerRequest
+        {
+            None,
+            Shutdown,
+            Reboot
+        };
+
+        /**
+         * The default stream where processes data is send to.
+         * Data is send to the screen/serial output
+        */
+        class StandardOutSteam : public Stream
+        {
+        public:
+            StandardOutSteam() : Stream() {}
+
+            // We only overwrite the write function since reading is not supported
+            void Write(char byte)
+            {
+                char str[1];
+                str[0] = byte;
+                Print(str, 1);
+            }
+        };     
+
+        class System
+        {
+        public:
+            static multiboot_info_t* mbi;
+            static PIT* pit;
+            static RTC* rtc;
+            static SMBIOS* smbios;
+            static DMAController* dma;
+            static Virtual8086Manager* vm86Manager;
+            static Virtual8086Monitor* vm86Monitor;
+            static GraphicsDevice* gfxDevice;
+            static EDID* edid;
+            static PCIController* pci;
+            static drivers::DriverManager* driverManager;
+            static DiskManager* diskManager;
+            static VFSManager* vfs;
+            static Scheduler* scheduler;
+            static SystemCallHandler* syscalls;
+            static APMController* apm;
+            static LIBCactusOS::SharedSystemInfo* systemInfo;
+
+            static ScreenMode screenMode;
+            static bool gdbEnabled; //Is the gdb stub enabled?
+            static bool setupMode; //Are we running the setup program?
+            static KeyboardManager* keyboardManager;
+            static Stream* ProcStandardOut;
+            static List<ListingController*>* listings;
+            static USBManager* usbManager;
+            static SymbolDebugger* kernelDebugger;
+            #if BOCHS_GFX_HACK
+            static bool isBochs; //are we running inside bochs
+            #endif
+
+            #if ENABLE_ADV_DEBUG
+            typedef struct
+            {
+                // Values for measuring activity of idle process
+                uint32_t idleProcCounter = 0;
+                uint32_t idleProcStartTime = 0;
+                uint32_t idleProcActive = 0;
+
+                // Amount of disk read operations
+                uint32_t diskReadOp = 0;
+
+                // Amount of disk write operations
+                uint32_t diskWriteOp = 0;
+            } SYSTEM_STATS;
+            static SYSTEM_STATS statistics;
+            #endif
+
+            static void Start();
+            static void Panic();
+        };
+    }
+} 
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/tasking/elf.h b/kernelz/include/system/tasking/elf.h
new file mode 100644
index 0000000..e1906c1
--- /dev/null
+++ b/kernelz/include/system/tasking/elf.h
@@ -0,0 +1,59 @@
+#ifndef __CACTUSOS__SYSTEM__ELFLOADER_H
+#define __CACTUSOS__SYSTEM__ELFLOADER_H
+
+#include <common/types.h>
+#include <system/tasking/process.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        #define ELFMAG0   0x7f
+        #define ELFMAG1   'E'
+        #define ELFMAG2   'L'
+        #define ELFMAG3   'F'
+
+        struct ElfHeader {
+            unsigned char e_ident[16];
+            common::uint16_t e_type;
+            common::uint16_t e_machine;
+            common::uint32_t e_version;
+            common::uint32_t e_entry;
+            common::uint32_t e_phoff;
+            common::uint32_t e_shoff;
+            common::uint32_t e_flags;
+            common::uint16_t e_ehsize;
+            common::uint16_t e_phentsize;
+            common::uint16_t e_phnum;
+            common::uint16_t e_shentsize;
+            common::uint16_t e_shnum;
+            common::uint16_t e_shstrndx;
+        } __attribute__((packed));
+
+        struct ElfSectionHeader {
+            common::uint32_t sh_name;
+            common::uint32_t sh_type;
+            common::uint32_t sh_flags;
+            common::uint32_t sh_addr;
+            common::uint32_t sh_offset;
+            common::uint32_t sh_size;
+            common::uint32_t sh_link;
+            common::uint32_t sh_info;
+            common::uint32_t sh_addralign;
+            common::uint32_t sh_entsize;
+        } __attribute__((packed));
+
+        struct ElfProgramHeader {
+            common::uint32_t p_type;
+            common::uint32_t p_offset;
+            common::uint32_t p_vaddr;
+            common::uint32_t p_paddr;
+            common::uint32_t p_filesz;
+            common::uint32_t p_memsz;
+            common::uint32_t p_flags;
+            common::uint32_t p_align;
+        } __attribute__((packed));
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/tasking/ipcmanager.h b/kernelz/include/system/tasking/ipcmanager.h
new file mode 100644
index 0000000..37cf551
--- /dev/null
+++ b/kernelz/include/system/tasking/ipcmanager.h
@@ -0,0 +1,33 @@
+#ifndef __CACTUSOS__SYSTEM__TASKING__IPCMANAGER_H
+#define __CACTUSOS__SYSTEM__TASKING__IPCMANAGER_H
+
+#include <core/registers.h>
+#include <system/tasking/process.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        struct IPCReceiveDescriptor
+        {
+            // Which process is waiting for a message?
+            Process* receivingProcess;
+            // Which thread called receive and is currently blocked.
+            Thread* receivingThread;
+            // Do we need to receive the message from a specific process?
+            int receiveFromPID;
+            // Do we need to receive a specific type of message?
+            int receiveType;
+        };
+
+        class IPCManager
+        {
+        public:
+            static void Initialize();
+            static void HandleSend(core::CPUState* state, Process* proc);
+            static void HandleReceive(core::CPUState* state, Process* proc);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/tasking/lock.h b/kernelz/include/system/tasking/lock.h
new file mode 100644
index 0000000..1e53604
--- /dev/null
+++ b/kernelz/include/system/tasking/lock.h
@@ -0,0 +1,23 @@
+#ifndef __CACTUSOS__SYSTEM__TASKING__LOCK_H
+#define __CACTUSOS__SYSTEM__TASKING__LOCK_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class MutexLock
+        {
+        private:
+            int value = 0;
+        public:
+            MutexLock();
+
+            void Lock();
+            void Unlock();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/tasking/process.h b/kernelz/include/system/tasking/process.h
new file mode 100644
index 0000000..ac671e3
--- /dev/null
+++ b/kernelz/include/system/tasking/process.h
@@ -0,0 +1,73 @@
+#ifndef __CACTOSOS__SYSTEM__TASKING__PROCESS_H
+#define __CACTOSOS__SYSTEM__TASKING__PROCESS_H
+
+#include <system/tasking/thread.h>
+#include <common/list.h>
+#include <common/types.h>
+#include <../../lib/include/ipc.h>
+#include <system/memory/stream.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class SymbolDebugger;
+        
+        enum ProcessState
+        {
+            Active
+        };
+
+        #define PROC_USER_HEAP_SIZE 1_MB //1 MB heap space for processes, and of course more if needed.
+
+        struct Thread;
+
+        struct Process
+        {
+            int id;
+            int syscallID;
+            bool isUserspace;
+            char* args;
+            ProcessState state;
+            List<Thread*> Threads;
+            common::uint32_t pageDirPhys;
+            struct Excecutable
+            {
+                common::uint32_t memBase;
+                common::uint32_t memSize;
+            } excecutable;
+            
+            struct Heap
+            {
+                common::uint32_t heapStart;
+                common::uint32_t heapEnd;
+            } heap;
+            List<LIBCactusOS::IPCMessage> ipcMessages;
+
+            Stream* stdInput;
+            Stream* stdOutput;
+
+            // For Debuging
+            char fileName[32];
+
+            // Debugger assigned to this process
+            SymbolDebugger* symDebugger = 0;
+        };
+
+        class ProcessHelper
+        {
+        private:
+            ProcessHelper();
+        public:
+            static List<Process*> Processes;
+            
+            static Process* Create(char* fileName, char* arguments = 0, bool isKernel = false);
+            static Process* CreateKernelProcess();
+            static void RemoveProcess(Process* proc);
+            static void UpdateHeap(Process* proc, common::uint32_t newEndAddr);
+            static Process* ProcessById(int id);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/tasking/scheduler.h b/kernelz/include/system/tasking/scheduler.h
new file mode 100644
index 0000000..52fb534
--- /dev/null
+++ b/kernelz/include/system/tasking/scheduler.h
@@ -0,0 +1,48 @@
+#ifndef __CACTUSOS__SYSTEM__TASKING__SCHEDULER_H
+#define __CACTUSOS__SYSTEM__TASKING__SCHEDULER_H
+
+#include <common/types.h>
+#include <system/interruptmanager.h>
+#include <system/tasking/thread.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        #define SCHEDULER_FREQUENCY 30
+
+        class Scheduler : public InterruptHandler
+        {
+        private:
+            common::uint32_t frequency = 0;
+            common::uint32_t tickCount = 0;
+
+            List<Thread*> threadsList;
+            Thread* currentThread = 0;
+
+            Thread* GetNextReadyThread();
+            void ProcessSleepingThreads();
+
+            bool switchForced = false; //Is the current switch forced by a forceSwitch() call?
+        public:
+            bool Enabled = true;
+            Scheduler();
+
+            common::uint32_t HandleInterrupt(common::uint32_t esp);
+
+            void AddThread(Thread* thread, bool forceSwitch = false);
+            void ForceSwitch();
+
+            Thread* CurrentThread();
+            Process* CurrentProcess();
+
+            void InitialThreadUserJump(Thread* thread);
+
+            //Blocking and unblocking
+            void Block(Thread* thread, BlockedState reason = BlockedState::Unkown);
+            void Unblock(Thread* thread, bool forceSwitch = false);
+        };
+    }   
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/tasking/thread.h b/kernelz/include/system/tasking/thread.h
new file mode 100644
index 0000000..6483740
--- /dev/null
+++ b/kernelz/include/system/tasking/thread.h
@@ -0,0 +1,62 @@
+#ifndef __CACTOSOS__SYSTEM__TASKING__THREAD_H
+#define __CACTOSOS__SYSTEM__TASKING__THREAD_H
+
+#include <system/tasking/process.h>
+#include <common/list.h>
+#include <common/types.h>
+#include <core/registers.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        #define THREAD_STACK_SIZE 4_KB
+        
+        #define SEG_USER_DATA 0x23
+        #define SEG_USER_CODE 0x1B
+        #define SEG_KERNEL_DATA 0x10
+        #define SEG_KERNEL_CODE 8
+
+        enum ThreadState
+        {
+            Blocked,
+            Ready,
+            Stopped,
+            Started
+        };
+
+        enum BlockedState
+        {
+            Unkown,
+            SleepMS,
+            ReceiveIPC
+        };
+
+        struct Process;
+
+        struct Thread
+        {
+            Process* parent;
+            common::uint8_t* stack;
+            common::uint8_t* userStack;
+            common::uint32_t userStackSize;
+            ThreadState state;
+            BlockedState blockedState;
+            core::CPUState* regsPtr;
+            
+            common::uint32_t timeDelta;
+            common::uint8_t* FPUBuffer;
+        };
+
+        class ThreadHelper
+        {
+        private:
+            ThreadHelper();
+        public:
+            static Thread* CreateFromFunction(void (*entryPoint)(), bool isKernel = false, common::uint32_t flags = 0x202, Process* parent = 0);
+            static void RemoveThread(Thread* thread);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/usb/hidparser.h b/kernelz/include/system/usb/hidparser.h
new file mode 100644
index 0000000..6f67e34
--- /dev/null
+++ b/kernelz/include/system/usb/hidparser.h
@@ -0,0 +1,134 @@
+#ifndef __CACTUSOS__SYSTEM__USB__HIDPARSER_H
+#define __CACTUSOS__SYSTEM__USB__HIDPARSER_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        enum HID_PAGE_USAGE {
+            GEN_DESKTOP = 1, BUTTON = 9,
+        };
+
+        enum HID_USAGE {
+            POINTER = 1, MOUSE,
+            POINTER_X = 0x30, POINTER_Y, POINTER_WHEEL = 0x38,
+            NOTHING = 0xFF
+        };
+
+        #define BUTTON_LEFT    0
+        #define BUTTON_RIGHT   1
+        #define BUTTON_MIDDLE  2
+
+        #define PATH_SIZE               10 // maximum depth for Path
+        #define USAGE_TAB_SIZE          50 // Size of usage stack
+        #define MAX_REPORT             300 // Including FEATURE, INPUT and OUTPUT
+
+        #define SIZE_0                0x00
+        #define SIZE_1                0x01
+        #define SIZE_2                0x02
+        #define SIZE_4                0x03
+        #define SIZE_MASK             0x03
+                                
+        #define TYPE_MAIN             0x00
+        #define TYPE_GLOBAL           0x04
+        #define TYPE_LOCAL            0x08
+        #define TYPE_MASK             0xC0
+
+        #define ITEM_MASK             0xFC
+        #define ITEM_UPAGE            0x04
+        #define ITEM_USAGE            0x08  // local item
+        #define ITEM_LOG_MIN          0x14
+        #define ITEM_USAGE_MIN        0x18  // local item
+        #define ITEM_LOG_MAX          0x24
+        #define ITEM_USAGE_MAX        0x28  // local item
+        #define ITEM_PHY_MIN          0x34
+        #define ITEM_PHY_MAX          0x44
+        #define ITEM_UNIT_EXP         0x54
+        #define ITEM_UNIT             0x64
+        #define ITEM_REP_SIZE         0x74
+        #define ITEM_STRING           0x78  // local item?
+        #define ITEM_REP_ID           0x84
+        #define ITEM_REP_COUNT        0x94
+
+        #define ITEM_COLLECTION       0xA0
+        #define ITEM_END_COLLECTION   0xC0
+        #define ITEM_FEATURE          0xB0
+        #define ITEM_INPUT            0x80
+        #define ITEM_OUTPUT           0x90
+
+        // Attribute Flags
+        #define ATTR_DATA_CST         0x01
+        #define ATTR_NVOL_VOL         0x80
+
+        // Describe a HID Path point 
+        struct HID_NODE {
+            common::uint16_t u_page;
+            common::uint16_t usage;
+        };
+
+        // Describe a HID Path
+        struct HID_PATH {
+            int    size;                      // HID Path size
+            struct HID_NODE node[PATH_SIZE];  // HID Path
+        };
+
+        // Describe a HID Data with its location in report 
+        struct HID_DATA {
+            common::uint32_t value;     // HID Object Value
+            struct HID_PATH path;       // HID Path
+            
+            common::uint8_t  report_id; // Report ID, (from incoming report) ???
+            int    report_count;        // count of reports for this usage type
+            int    offset;              // Offset of data in report
+            int    size;                // Size of data in bits
+                                        
+            common::uint8_t  type;      // Type : FEATURE / INPUT / OUTPUT
+            common::uint8_t  attribute; // Report field attribute (2 = (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position))
+                                        //                        (6 = (Data,Var,Rel,No Wrap,Linear,Preferred State,No Null Position))
+            common::uint8_t unit;       // HID Unit
+            common::uint8_t unit_exp;   // Unit exponent
+            
+            int    log_min;             // Logical Min
+            int    log_max;             // Logical Max
+            int    phy_min;             // Physical Min
+            int    phy_max;             // Physical Max
+        };
+
+
+        class HIDParser
+        {
+        private:
+
+        public:
+            const common::uint8_t *report_desc;              // Store Report Descriptor
+            int    report_desc_size;             // Size of Report Descriptor
+            int    pos;                          // Store current pos in descriptor
+            common::uint8_t  item;                         // Store current Item
+            common::uint32_t value;                        // Store current Value
+            
+            struct HID_DATA data;                  // Store current environment
+            
+            int    offset_table[MAX_REPORT][3];  // Store ID, type & offset of report
+            int    report_count;                 // Store Report Count
+            int    count;                        // Store local report count
+            
+            common::uint16_t u_page;                       // Global UPage
+            struct HID_NODE usage_table[USAGE_TAB_SIZE]; // Usage stack
+            int    usage_size;                   // Design number of usage used
+            int    usage_min;
+            int    usage_max;
+            
+            int    cnt_object;                   // Count objects in Report Descriptor
+            int    cnt_report;                   // Count reports in Report Descriptor
+        public:
+            bool Parse(struct HID_DATA* data);
+            void Reset();
+            bool FindObject(struct HID_DATA* data);
+            int* GetReportOffset(const common::uint8_t report_id, const common::uint8_t report_type);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/usb/usbcontroller.h b/kernelz/include/system/usb/usbcontroller.h
new file mode 100644
index 0000000..3a20415
--- /dev/null
+++ b/kernelz/include/system/usb/usbcontroller.h
@@ -0,0 +1,100 @@
+#ifndef __CACTUSOS__SYSTEM__USB__USBCONTROLLER_H
+#define __CACTUSOS__SYSTEM__USB__USBCONTROLLER_H
+
+#include <system/drivers/driver.h>
+#include <system/components/pci.h>
+#include <system/interruptmanager.h>
+#include <system/usb/usbdevice.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        enum USBControllerType
+        {
+            UHCI,
+            OHCI,
+            EHCI,
+            xHCI
+        };
+
+        class USBDriver;
+        typedef struct InterruptTransfer
+        {
+            uint8_t* bufferPointer;
+            uint32_t bufferPhys;
+            int bufferLen;
+
+            USBDriver* handler;
+            int queueIndex;
+
+            uint32_t tdPhys;
+            void* td;
+            int numTd;
+
+            void* qh;
+            int endpoint;
+        } InterruptTransfer_t;
+
+        class USBDevice;
+        class USBController
+        {
+        protected:
+            List<InterruptTransfer_t*> interrupTransfers;            
+        public:
+            // What type of controller is this
+            USBControllerType type;
+            // Create new instance of USBController class
+            USBController(USBControllerType usbType);
+
+            // Setup this controller into the active state
+            virtual void Setup();
+
+            // Function that will get called on a periodic interval in which the controller can perform specific kinds of things.
+            // One of these things is port connection change checking and updating devices if necessary.
+            virtual void ControllerChecksThread();
+
+            /////
+            // USB Common functions per controller
+            /////
+
+            // Perform a bulk in operation
+            virtual bool BulkIn(USBDevice* device, void* retBuffer, int len, int endP);
+            // Perform a bulk out operation
+            virtual bool BulkOut(USBDevice* device, void* sendBuffer, int len, int endP);
+
+            // Perform a control in operation
+            virtual bool ControlIn(USBDevice* device, void* target = 0, const int len = 0, const uint8_t requestType = 0, const uint8_t request = 0, const uint16_t valueHigh = 0, const uint16_t valueLow = 0, const uint16_t index = 0);
+            // Perform a control out operation
+            virtual bool ControlOut(USBDevice* device, const int len = 0, const uint8_t requestType = 0, const uint8_t request = 0, const uint16_t valueHigh = 0, const uint16_t valueLow = 0, const uint16_t index = 0);
+            
+            // Place a interrupt in transfer in the dedicated queue, handler will get called on completion
+            virtual void InterruptIn(USBDevice* device, int len, int endP);
+
+            /////
+            // Functions that use controler specific implementations
+            /////
+
+            // Get Device descriptor of specific device
+            bool GetDeviceDescriptor(struct DEVICE_DESC* dev_desc, USBDevice* device);
+
+            // Get String descriptor of specific device
+            bool GetStringDescriptor(struct STRING_DESC* stringDesc, USBDevice* device, uint16_t index, uint16_t lang = 0);
+            
+            // Get String descriptor of specific device
+            // Returns buffer with Configuration header and additional data            
+            uint8_t* GetConfigDescriptor(USBDevice* device);
+            
+            // Set configuration for device
+            bool SetConfiguration(USBDevice* device, uint8_t config);
+
+            // Receive devices current configuration
+            int GetConfiguration(USBDevice* device);
+            
+            // Get maximum of Logical unit numbers, Only for Mass Storage Devices!
+            int GetMaxLuns(USBDevice* device);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/usb/usbdevice.h b/kernelz/include/system/usb/usbdevice.h
new file mode 100644
index 0000000..a6eadf5
--- /dev/null
+++ b/kernelz/include/system/usb/usbdevice.h
@@ -0,0 +1,75 @@
+#ifndef __CACTUSOS__SYSTEM__USB__USBDEVICE_H
+#define __CACTUSOS__SYSTEM__USB__USBDEVICE_H
+
+#include <system/usb/usbcontroller.h>
+#include <system/usb/usbendpoint.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class USBController;
+        class USBDriver;
+        
+        // Class describing a common interface to interact with different usb devices
+        class USBDevice
+        {
+        public:
+            // Port to which this device is attached to on the controller
+            // This is the physical port and not a virtual address of some sort
+            // The address is stored in the properties per controller
+            uint8_t portNum = 0;
+            // Ranging from 0 to 127, should not be 0 after initializing
+            uint8_t devAddress = 0;
+            // Which controller is this device attached to?
+            USBController* controller = 0;
+            // The name of this device present in the string descriptor
+            char* deviceName = 0;
+            // Class code of this device
+            uint16_t classID = 0;
+            // Sub-Class code of this device
+            uint16_t subclassID = 0;
+            // Protocol used
+            uint16_t protocol = 0;
+            // Vendor ID of device
+            uint16_t vendorID = 0;
+            // Product ID of device
+            uint16_t productID = 0;
+
+            // Driver associated with this device, 0 if none found
+            USBDriver* driver = 0;
+
+            //// Properties per controller
+            struct UHCIProperties
+            {
+                bool lowSpeedDevice;
+                int maxPacketSize;
+            } uhciProperties;
+            struct OHCIProperties
+            {
+                int desc_mps;
+                bool ls_device;
+            } ohciProperties;
+
+            // List of all endpoints of device
+            List<USBEndpoint*> endpoints;
+
+            // Pointer to HID descriptor found in interface
+            // Only valid for mouse or keyboard
+            uint8_t* hidDescriptor = 0;
+        public:
+            // Create new USBDevice, only called by controllers
+            USBDevice();
+            // Destructor
+            ~USBDevice();
+
+            // Automaticly test this device for its specs and assign a driver if found
+            bool AssignDriver();
+
+            // Called when device is unplugged from system
+            void OnUnplugged();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/usb/usbendpoint.h b/kernelz/include/system/usb/usbendpoint.h
new file mode 100644
index 0000000..a7f7042
--- /dev/null
+++ b/kernelz/include/system/usb/usbendpoint.h
@@ -0,0 +1,48 @@
+#ifndef __CACTUSOS__SYSTEM__USB__USBENDPOINT_H
+#define __CACTUSOS__SYSTEM__USB__USBENDPOINT_H
+
+#include <system/drivers/usb/usbdefs.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        enum EndpointDirection : int
+        {
+            Out,
+            In
+        };
+
+        enum EndpointType : int
+        {
+            Control,
+            Isochronous,
+            Bulk,
+            Interrupt
+        };
+
+        // An easy interface for managing endpoints
+        class USBEndpoint
+        {
+        private:
+            bool toggleState = false;
+        public:
+            common::uint8_t endpointNumber = 0; // Index of endpoint in device
+            EndpointDirection dir = EndpointDirection::Out; // Direction of transfer for this endpoint
+            EndpointType type = EndpointType::Control; // Type of endpoint
+            common::uint16_t maxPacketSize = 0; // Max size a packet can be for this endpoint
+            common::uint8_t interval = 0; // Interval for interrupt packets
+        public:
+            // Create new USB Endpoint from ENDPOINT_DESC gathered from configuration descriptor
+            USBEndpoint(struct ENDPOINT_DESC* src);
+
+            // Get toggle bit and toggle it for next packet
+            bool Toggle();
+
+            // Set Toggle bit
+            void SetToggle(bool v);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/usb/usbmanager.h b/kernelz/include/system/usb/usbmanager.h
new file mode 100644
index 0000000..accc580
--- /dev/null
+++ b/kernelz/include/system/usb/usbmanager.h
@@ -0,0 +1,42 @@
+#ifndef __CACTUSOS__SYSTEM__USB__USBMANAGER_H
+#define __CACTUSOS__SYSTEM__USB__USBMANAGER_H
+
+#include <system/usb/usbcontroller.h>
+#include <system/usb/usbdevice.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class USBManager
+        { 
+        public:
+            // The list of all usb controllers present on this pc. (the ones detected by pci)
+            List<USBController*> controllerList;
+            // List of all known USBDevices
+            List<USBDevice*> deviceList;
+            // Holds if usb devices present on boot are all initialized
+            bool initDone = false;
+        public:
+            //Create new instance of USBManager
+            USBManager();
+
+            //Add controller to list, called by HC drivers.
+            void AddController(USBController* c);
+            //Remove controller from list
+            void RemoveController(USBController* c);
+            //Add device to list, called by HC drivers.
+            void AddDevice(USBDevice* c);
+            //Remove device, called after device unplug
+            void RemoveDevice(USBController* controller, uint8_t port);
+            //Send the setup command to all the controllers
+            void SetupAll();
+            //Make all usb devices detect their properties and automaticly select a driver
+            void AssignAllDrivers();
+            //Check for changes in usb status
+            void USBPoll();
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/vfs/fat.h b/kernelz/include/system/vfs/fat.h
new file mode 100644
index 0000000..33dabf3
--- /dev/null
+++ b/kernelz/include/system/vfs/fat.h
@@ -0,0 +1,265 @@
+#ifndef __CACTUSOS__SYSTEM__VFS__FAT32_H
+#define __CACTUSOS__SYSTEM__VFS__FAT32_H
+
+#include <system/vfs/virtualfilesystem.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        struct FAT32_BPB
+        {
+            common::uint8_t     bootCode[3];
+            common::uint8_t     Oem_Id[8];
+            common::uint16_t    bytesPerSector;
+            common::uint8_t     SectorsPerCluster;
+            common::uint16_t    ReservedSectors;
+            common::uint8_t     NumOfFats;
+            common::uint16_t    NumDirEntries;
+            common::uint16_t    TotalSectorsSmall;
+            common::uint8_t     MediaDescriptorType;
+            common::uint16_t    SectorsPerFat12_16;
+            common::uint16_t    SectorsPerTrack;
+            common::uint16_t    NumHeads;
+            common::uint32_t    HiddenSectors;
+            common::uint32_t    TotalSectorsBig;
+
+            //Beginning of fat32 values
+            common::uint32_t    SectorsPerFat32;
+            common::uint16_t    Flags;
+            common::uint16_t    FATVersionNum;
+            common::uint32_t    RootDirCluster;
+            common::uint16_t    FSInfoSector;
+            common::uint16_t    BackupBootSector;
+            common::uint8_t     Reserved[12];
+            common::uint8_t     DriveNum;
+            common::uint8_t     WinNTFlags;
+            common::uint8_t     Signature;
+            common::uint32_t    VolumeIDSerial;
+            common::uint8_t     VolumeLabel[11];
+            common::uint8_t     SystemIDString[8];
+            common::uint8_t     BootCode[420];
+            common::uint16_t    BootSignature;
+        } __attribute__((packed));
+
+        struct FAT32_FSInfo
+        {
+            common::uint32_t    signature1;
+            common::uint8_t     reserved1[480];
+            common::uint32_t    signature2;
+            common::uint32_t    lastFreeCluster;
+            common::uint32_t    startSearchCluster;
+            common::uint8_t     reserved2[12];
+            common::uint32_t    signature3;
+        } __attribute__((packed));
+
+        struct DirectoryEntry
+        {
+            common::uint8_t     FileName[11];       // 8.3 Filename
+            common::uint8_t     Attributes;         // Entry Flags
+            common::uint8_t     Reserved;           // Not Used
+            common::uint8_t     CreationTimeTenth;  // Creation time in tenths of a second. Range 0-199 inclusive. 
+            common::uint16_t    CreationTime;       // The time that the file was created. Multiply Seconds by 2. 
+            common::uint16_t    CreationDate;       // The date on which the file was created. 
+            common::uint16_t    AccessDate;         // Last accessed date. Same format as the creation date. 
+            common::uint16_t    HighFirstCluster;   // High word of this entrys first cluster number (always 0 for a FAT12 or FAT16 volume).
+            common::uint16_t    ModifyTime;         // Last modification time. Same format as the creation time. 
+            common::uint16_t    ModifyDate;         // Last modification date. Same format as the creation date. 
+            common::uint16_t    LowFirstCluster;    // The low 16 bits of this entry's first cluster number. Use this number to find the first cluster for this entry. 
+            common::uint32_t    FileSize;           // The size of the file in bytes
+        } __attribute__((packed));
+
+        struct LFNEntry
+        {
+            common::uint8_t entryIndex;             // The order of this entry in the sequence of long file name entries.
+            common::uint8_t namePart1[10];          // The first 5, 2-byte characters of this entry. 
+            common::uint8_t Attributes;             // Attribute. Always equals 0x0F. (the long file name attribute) 
+            common::uint8_t reserved_1;             // Long entry type. Zero for name entries. 
+            common::uint8_t checksum;               // Checksum generated of the short file name when the file was created. 
+            common::uint8_t namePart2[12];          // The next 6, 2-byte characters of this entry. 
+            common::uint16_t reserved_2;            // Always Zero
+            common::uint8_t namePart3[4];           // The final 2, 2-byte characters of this entry. 
+        } __attribute__((packed));
+
+        struct FATEntryInfo
+        {
+            DirectoryEntry entry;                   // 8.3 Entry of this file/directory
+            char* filename;                         // Name of this file, could be LFN
+            common::uint32_t sector;                // Sector in which this entry is present (the 8.3 entry)
+            common::uint32_t offsetInSector;        // Offset of the main entry in the sector pointed by this->sector
+        } __attribute__((packed));
+
+        // Cluster Special Values
+        #define CLUSTER_END_32  0x0FFFFFF8
+        #define CLUSTER_BAD_32  0x0FFFFFF7
+        #define CLUSTER_FREE_32 0x00000000
+
+        #define CLUSTER_END_16  0xFFF8
+        #define CLUSTER_BAD_16  0xFFF7
+        #define CLUSTER_FREE_16 0x0000
+        
+        #define CLUSTER_END_12  0xFF8
+        #define CLUSTER_BAD_12  0xFF7
+        #define CLUSTER_FREE_12 0x000
+
+        // For easy Access
+        #define CLUSTER_END     (this->FatType == FAT12 ? CLUSTER_END_12 : (this->FatType == FAT16 ? CLUSTER_END_16 : CLUSTER_END_32))
+        #define CLUSTER_FREE    (this->FatType == FAT12 ? CLUSTER_FREE_12 : (this->FatType == FAT16 ? CLUSTER_FREE_16 : CLUSTER_FREE_32))
+        #define CLUSTER_BAD     (this->FatType == FAT12 ? CLUSTER_BAD_12 : (this->FatType == FAT16 ? CLUSTER_BAD_16 : CLUSTER_BAD_32))
+
+        #define ATTR_READ_ONLY  0x01
+        #define ATTR_HIDDEN 	0x02
+        #define ATTR_SYSTEM     0x04
+        #define ATTR_VOLUME_ID  0x08
+        #define ATTR_DIRECTORY	0x10
+        #define ATTR_ARCHIVE    0x20
+        #define ATTR_LONG_NAME 	(ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID)
+
+        #define ENTRY_END       0x00
+        #define ENTRY_UNUSED    0xE5
+        #define LFN_ENTRY_END   0x40
+
+        // Extract cluster from directory entry
+	    #define GET_CLUSTER(e) (e.LowFirstCluster | (e.HighFirstCluster << (16)))
+
+        enum FATType
+        {
+            FAT12,
+            FAT16,
+            FAT32
+        };
+        
+        class FAT : public VirtualFileSystem
+        {
+        private: // Variables
+            FATType FatType;                    // What type of filesystem is this?
+            char* FatTypeString = 0;            // String describing the filesystem type
+
+            uint16_t bytesPerSector = 0;        // Bytes per sector, usually 512
+            uint32_t rootDirSectors = 0;        // How many sectors does the root directory use?
+            uint8_t sectorsPerCluster = 0;      // How many sectors does one cluster contain?
+            uint32_t clusterSize = 0;           // Size of one cluster in bytes
+
+            uint32_t firstDataSector = 0;       // LBA Address of first sector of the data region
+            uint32_t firstFatSector = 0;        // The first sector in the File Allocation Table
+            uint32_t rootDirCluster = 0;        // Cluster of the root directory, only used by FAT32
+            uint32_t totalClusters = 0;         // Total amount of clusters used by data region
+
+            uint8_t* readBuffer = 0;            // Buffer used for reading the disk
+            FAT32_FSInfo fsInfo;                // Structure used by FAT32 for extra info
+        private:
+            ///////////////////////
+            /// Helper Functions
+            ///////////////////////
+
+            // Convert a cluster number to its corresponding start sector
+            common::uint32_t ClusterToSector(common::uint32_t cluster);
+
+            // Reads the FAT table and returns the value for the specific cluster
+            common::uint32_t ReadTable(common::uint32_t cluster);
+
+            // Writes a new value into the FAT table for the cluster
+            void WriteTable(common::uint32_t cluster, common::uint32_t value);
+
+            // Allocate a new cluster in the FAT Table
+            common::uint32_t AllocateCluster();
+
+            // Clear the data of a cluster
+            void ClearCluster(common::uint32_t cluster);
+
+            // Parse a list of long file name entries, also pass the 8.3 entry for the checksum
+            char* ParseLFNEntries(List<LFNEntry>* entries, DirectoryEntry sfnEntry);
+
+            // Turn a FAT filename into a readable one
+            char* ParseShortFilename(char* fatName);
+
+            // Calculate checksum for 8.3 filename
+            common::uint8_t Checksum(char* filename);
+
+            ///////////////////////
+            /// Read Functions
+            ///////////////////////
+
+            // Parse a directory and return its entries, rootDirectory is handled different on fat12/fat16
+            List<FATEntryInfo> GetDirectoryEntries(common::uint32_t dirCluster, bool rootDirectory = false);
+
+            // Search in a directory for a specific entry and return this entry if found
+            FATEntryInfo* SeachInDirectory(char* name, common::uint32_t dirCluster, bool rootDirectory = false);
+
+            // Return the entry specified by a complete filename path
+            FATEntryInfo* GetEntryByPath(char* path);
+
+            ///////////////////////
+            /// Write Functions
+            ///////////////////////
+
+            // Create a list of LFN entries from a filename
+            List<LFNEntry> CreateLFNEntriesFromName(char* name, int num, common::uint8_t checksum);
+
+            // Create a 8.3 filename from a regular filename
+            char* CreateShortFilename(char* name);
+
+            // Write a series of LFN entries to the disk
+            bool WriteLongFilenameEntries(List<LFNEntry>* entries, common::uint32_t targetCluster, common::uint32_t targetSector, common::uint32_t sectorOffset, bool rootDirectory);
+
+            // Write a regulair Directory entry to the disk
+            bool WriteDirectoryEntry(DirectoryEntry entry, common::uint32_t targetSector, common::uint32_t sectorOffset, bool rootDirectory);
+
+            // Find a starting point for entries in a directory. Returns cluster and sector offset inside cluster.
+            bool FindEntryStartpoint(common::uint32_t cluster, common::uint32_t entryCount, bool rootdir, common::uint32_t* targetCluster, common::uint32_t* targetSector, common::uint32_t* sectorOffset);
+
+            // Create a entry in the directory specified by parentCluster
+            // Returns pointer to created entry present in readbuffer
+            DirectoryEntry* CreateEntry(common::uint32_t parentCluster, char* name, common::uint8_t attr, bool rootdir, common::uint32_t targetCluster, common::uint32_t* sectorPlaced);
+
+            // Easy way to create a new file or directory by path, is almost the same for file/directory creation
+            int CreateNewDirFileEntry(const char* path, common::uint8_t attributes);
+
+            // Modify a existing entry on disk by applying the variables from newVersion
+            // Be Carefoul when using this to change cluster numbers and filenames
+            // You should get the original entry, modify some stuff, and then pass it as newVersion
+            bool ModifyEntry(FATEntryInfo* entry, DirectoryEntry newVersion);
+
+            ///////////////////////
+            /// Time/Date Functions
+            ///////////////////////
+            
+            // Returns current time in fat format
+            common::uint16_t FatTime();
+
+            // Returns current date in fat format
+            common::uint16_t FatDate();
+        public:
+            FAT(Disk* disk, common::uint32_t start, common::uint32_t size);
+            ~FAT();
+
+            bool Initialize();
+
+            //////////////
+            // VFS Implementations
+            //////////////
+
+            // Read file contents into buffer
+            int ReadFile(const char* filename, uint8_t* buffer, uint32_t offset = 0, uint32_t len = -1);
+            // Write buffer to file, file will be created when create equals true
+            int WriteFile(const char* filename, uint8_t* buffer, uint32_t len, bool create = true);
+
+            // Check if file exist
+            bool FileExists(const char* filename);
+            // Check if directory exist
+            bool DirectoryExists(const char* filename);
+
+            // Create a file at the filepath
+            int CreateFile(const char* path);
+            // Create a new directory
+            int CreateDirectory(const char* path);
+
+            // Get size of specified file in bytes
+            uint32_t GetFileSize(const char* filename);
+            // Returns list of context inside a directory
+            List<LIBCactusOS::VFSEntry>* DirectoryList(const char* path);
+        };
+    }
+}
+
+#endif
diff --git a/kernelz/include/system/vfs/iso9660.h b/kernelz/include/system/vfs/iso9660.h
new file mode 100644
index 0000000..d2db65b
--- /dev/null
+++ b/kernelz/include/system/vfs/iso9660.h
@@ -0,0 +1,149 @@
+#ifndef __CACTUSOS__SYSTEM__VFS__ISO9660_H
+#define __CACTUSOS__SYSTEM__VFS__ISO9660_H
+
+#include <common/types.h>
+#include <system/vfs/virtualfilesystem.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        struct DirectoryRecord
+        {
+            common::uint8_t length;
+            common::uint8_t ear_length;
+            common::uint32_t extent_location;
+            common::uint32_t extent_location_be; // big-endian, unused
+            common::uint32_t data_length;
+            common::uint32_t data_length_be; // big-endian, unused
+            common::uint8_t datetime[7];
+            common::uint8_t flags;
+            common::uint8_t unit_size;
+            common::uint8_t gap_size;
+            common::uint16_t vol_seq_number;
+            common::uint16_t vol_seq_number_be; // big-endian, unused
+            common::uint8_t name_length;
+            char name[222];
+        } __attribute__((packed));
+
+        struct PVDTimeFormat
+        {
+            char Year[4];
+            char Month[2];
+            char Day[2];
+            char Hour[2];
+            char Minute[2];
+            char Second[2];
+            char HundrdSecond[2];
+            common::int8_t TimeZone;
+        } __attribute__((packed));
+
+        struct VolumeDescriptor
+        {
+            common::uint8_t Type;
+            char Identifier[5];
+            common::uint8_t version;
+            char data[2041];
+        } __attribute__((packed));
+
+        #define ISODCL(from, to) (to - from + 1)
+
+        struct PrimaryVolumeDescriptor
+        {
+            common::uint8_t type;
+            char id                             [ISODCL (  2,     6)];
+            common::uint8_t version;
+            char reserved1                      [ISODCL (  8,     8)];
+            char system_id                      [ISODCL (  9,    40)]; /* achars */
+            char volume_id                      [ISODCL ( 41,    72)]; /* dchars */
+            char reserved2                      [ISODCL ( 73,    80)];
+            common::uint64_t volume_space_size;
+            char reserved3                      [ISODCL ( 89,   120)];
+            common::uint32_t volume_set_size;
+            common::uint32_t volume_sequence_number;
+            common::uint32_t logical_block_size;
+            common::uint64_t path_table_size;
+            common::uint32_t type_1_path_table;
+            common::uint32_t opt_type_1_path_table;
+            common::uint32_t type_m_path_table;
+            common::uint32_t opt_type_m_path_table;
+            DirectoryRecord root_directory_record;
+            char volume_set_id                  [ISODCL (191,   318)]; /* dchars */
+            char publisher_id                   [ISODCL (319,   446)]; /* achars */
+            char preparer_id                    [ISODCL (447,   574)]; /* achars */
+            char application_id                 [ISODCL (575,   702)]; /* achars */
+            char copyright_file_id              [ISODCL (703,   739)]; /* dchars */
+            char abstract_file_id               [ISODCL (740,   776)]; /* dchars */
+            char bibliographic_file_id          [ISODCL (777,   813)]; /* dchars */
+            PVDTimeFormat creation_date         ;
+            PVDTimeFormat modification_date     ;
+            PVDTimeFormat expiration_date       ;
+            PVDTimeFormat effective_date        ;
+            char file_structure_version         [ISODCL (882,   882)];
+            char reserved4                      [ISODCL (883,   883)];
+            common::uint8_t application_data    [ISODCL (884,  1395)];
+            char reserved5                      [ISODCL (1396,  2048)];            
+        } __attribute__((packed));
+
+        #define ISO_START_SECTOR 0x10
+        #define CDROM_SECTOR_SIZE 2048
+
+        enum VolumeDescriptorType
+        {
+            BootRecord = 0,
+            PVDescriptor = 1,
+            SupplementaryVolumeDescriptor = 2,
+            VolumePartitionDescriptor = 3,
+            VolumeDescriptorSetTerminator = 255
+        };
+
+        enum Iso_EntryType
+        {
+            Iso_File = 0,
+            Iso_Directory = 1
+        };
+
+
+        class ISO9660 : public VirtualFileSystem
+        {
+        private:
+            DirectoryRecord* rootDirectory;
+
+            DirectoryRecord* SearchInDirectory(DirectoryRecord* searchIn, const char* name);
+            Iso_EntryType GetEntryType(DirectoryRecord* entry);
+            DirectoryRecord* GetEntry(const char* path);
+
+            char* GetRecordName(DirectoryRecord* record);
+        public:
+            ISO9660(Disk* disk, common::uint32_t start, common::uint32_t size);
+
+            bool Initialize();
+
+            //////////////
+            // VFS Implementations
+            //////////////
+
+            // Read file contents into buffer
+            int ReadFile(const char* filename, uint8_t* buffer, uint32_t offset = 0, uint32_t len = -1);
+            // Write buffer to file, file will be created when create equals true
+            int WriteFile(const char* filename, uint8_t* buffer, uint32_t len, bool create = true);
+
+            // Check if file exist
+            bool FileExists(const char* filename);
+            // Check if directory exist
+            bool DirectoryExists(const char* filename);
+
+            // Create a file at the filepath
+            int CreateFile(const char* path);
+            // Create a new directory
+            int CreateDirectory(const char* path);
+
+            // Get size of specified file in bytes
+            uint32_t GetFileSize(const char* filename);
+            // Returns list of context inside a directory
+            List<LIBCactusOS::VFSEntry>* DirectoryList(const char* path);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/vfs/vfsmanager.h b/kernelz/include/system/vfs/vfsmanager.h
new file mode 100644
index 0000000..00dfc09
--- /dev/null
+++ b/kernelz/include/system/vfs/vfsmanager.h
@@ -0,0 +1,59 @@
+#ifndef __CACTUSOS__SYSTEM__VFS__VFSMANAGER_H
+#define __CACTUSOS__SYSTEM__VFS__VFSMANAGER_H
+
+#include <system/vfs/virtualfilesystem.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class VFSManager
+        {
+        public:
+            List<VirtualFileSystem*>* Filesystems;
+        public:
+            int bootPartitionID = -1;
+
+            VFSManager();
+            void Mount(VirtualFileSystem* vfs);
+            void Unmount(VirtualFileSystem* vfs);
+            void UnmountByDisk(Disk* disk);
+
+            int ExtractDiskNumber(const char* path, common::uint8_t* idSizeReturn);
+            bool SearchBootPartition();
+
+            /////////////
+            // Filesystem functions
+            /////////////
+
+            // Read file contents into buffer
+            int ReadFile(const char* filename, uint8_t* buffer, uint32_t offset = 0, uint32_t len = -1);
+            // Write buffer to file, file will be created when create equals true
+            int WriteFile(const char* filename, uint8_t* buffer, uint32_t len, bool create = true);
+
+            // Check if file exist
+            bool FileExists(const char* filename);
+            // Check if directory exist
+            bool DirectoryExists(const char* filename);
+
+            // Create a file at the filepath
+            int CreateFile(const char* path);
+            // Create a new directory
+            int CreateDirectory(const char* path);
+
+            // Get size of specified file in bytes
+            uint32_t GetFileSize(const char* filename);
+            // Returns list of context inside a directory
+            List<LIBCactusOS::VFSEntry>* DirectoryList(const char* path);
+
+            ///////////////////
+            // Higher Level Functions
+            ///////////////////
+
+            // Eject the drive given by a path
+            bool EjectDrive(const char* path);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/vfs/virtualfilesystem.h b/kernelz/include/system/vfs/virtualfilesystem.h
new file mode 100644
index 0000000..5a47556
--- /dev/null
+++ b/kernelz/include/system/vfs/virtualfilesystem.h
@@ -0,0 +1,60 @@
+#ifndef __CACTUSOS__SYSTEM__VFS__VIRTUALFILESYSTEM_H
+#define __CACTUSOS__SYSTEM__VFS__VIRTUALFILESYSTEM_H
+
+#include <common/types.h>
+#include <common/list.h>
+
+#include <system/disks/disk.h>
+#include <../../lib/include/shared.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        #define PATH_SEPERATOR_C '\\' //Path Seperator as char
+        #define PATH_SEPERATOR_S "\\" //Path Seperator as string
+
+        class VirtualFileSystem
+        {
+        friend class VFSManager;
+        public:
+            Disk* disk;
+        protected:
+            common::uint32_t StartLBA;
+            common::uint32_t SizeInSectors;
+            
+            char* Name = "Unkown";
+        public:
+            VirtualFileSystem(Disk* disk, common::uint32_t start, common::uint32_t size, char* name = 0);
+            virtual ~VirtualFileSystem();
+            
+            virtual bool Initialize();
+            
+            /////////////
+            // VFS Functions (Read, Write, etc.)
+            ///////////// 
+               
+            // Read file contents into buffer
+            virtual int ReadFile(const char* filename, uint8_t* buffer, uint32_t offset = 0, uint32_t len = -1);
+            // Write buffer to file, file will be created when create equals true
+            virtual int WriteFile(const char* filename, uint8_t* buffer, uint32_t len, bool create = true);
+
+            // Check if file exist
+            virtual bool FileExists(const char* filename);
+            // Check if directory exist
+            virtual bool DirectoryExists(const char* filename);
+
+            // Create a file at the filepath
+            virtual int CreateFile(const char* path);
+            // Create a new directory
+            virtual int CreateDirectory(const char* path);
+
+            // Get size of specified file in bytes
+            virtual uint32_t GetFileSize(const char* filename);
+            // Returns list of context inside a directory
+            virtual List<LIBCactusOS::VFSEntry>* DirectoryList(const char* path);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/virtual8086/VM86Args.h b/kernelz/include/system/virtual8086/VM86Args.h
new file mode 100644
index 0000000..3af00fc
--- /dev/null
+++ b/kernelz/include/system/virtual8086/VM86Args.h
@@ -0,0 +1,22 @@
+#ifndef __CACTUSOS__SYSTEM__VIRTUAL_8086__VM86ARGS_H
+#define __CACTUSOS__SYSTEM__VIRTUAL_8086__VM86ARGS_H
+
+#include <common/types.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        struct VM86Arguments
+        {
+            common::uint16_t AX;
+            common::uint16_t BX;
+            common::uint16_t CX;
+            common::uint16_t DX;
+
+            common::uint16_t DI;
+        } __attribute__((packed));
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/virtual8086/VM86Manager.h b/kernelz/include/system/virtual8086/VM86Manager.h
new file mode 100644
index 0000000..328f156
--- /dev/null
+++ b/kernelz/include/system/virtual8086/VM86Manager.h
@@ -0,0 +1,32 @@
+#ifndef __CACTUSOS__SYSTEM__VIRTUAL_8086__VM86MANAGER_H
+#define __CACTUSOS__SYSTEM__VIRTUAL_8086__VM86MANAGER_H
+
+#include <system/interruptmanager.h>
+#include <system/virtual8086/VM86Args.h>
+#include <core/registers.h>
+#include <core/idt.h>
+#include <core/tss.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class Virtual8086Manager : public InterruptHandler
+        {
+        private:
+            void vm86Enter(common::uint16_t ss, common::uint16_t sp, common::uint16_t cs, common::uint16_t ip, common::uint32_t arg);
+        public:
+            Virtual8086Manager();
+            common::uint32_t HandleInterrupt(common::uint32_t esp);
+            
+            // Call a bios interrupt while passing multiple arguments via the regs variable
+            void CallInterrupt(common::uint8_t intNumber, VM86Arguments* regs);
+            
+            // Execute a specific function defined in VM8086Code.asm
+            // Sometimes things can't be done using the CallInterrupt function
+            void ExecuteCode(common::uint32_t instructionStart, common::uint32_t args);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/include/system/virtual8086/VM86Monitor.h b/kernelz/include/system/virtual8086/VM86Monitor.h
new file mode 100644
index 0000000..9879fed
--- /dev/null
+++ b/kernelz/include/system/virtual8086/VM86Monitor.h
@@ -0,0 +1,23 @@
+#ifndef __CACTUSOS__SYSTEM__VIRTUAL_8086__VM86MONITOR_H
+#define __CACTUSOS__SYSTEM__VIRTUAL_8086__VM86MONITOR_H
+
+#include <system/interruptmanager.h>
+#include <core/registers.h>
+#include <core/port.h>
+#include <system/bootconsole.h>
+
+namespace CactusOS
+{
+    namespace system
+    {
+        class Virtual8086Monitor : public InterruptHandler
+        {
+        public:
+            Virtual8086Monitor();
+
+            common::uint32_t HandleInterrupt(common::uint32_t esp);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/kernelz/linker.ld b/kernelz/linker.ld
new file mode 100644
index 0000000..c89b4ac
--- /dev/null
+++ b/kernelz/linker.ld
@@ -0,0 +1,43 @@
+OUTPUT_FORMAT(elf32-i386)
+OUTPUT_ARCH(i386:i386)
+
+ENTRY(_entrypoint)
+
+SECTIONS
+{
+  . = 0xC0100000;
+
+  _kernel_base = .;
+
+	.text ALIGN(4K) : AT(ADDR(.text)-0xC0000000)
+	{
+		*(.multiboot)
+		*(.text*)
+  }
+
+  .rodata ALIGN (4K) : AT(ADDR(.rodata)-0xC0000000)
+	{
+		*(.rodata)
+  }
+
+  .bss ALIGN(4K) : AT(ADDR(.bss)-0xC0000000)
+  {
+    *(.COMMON)
+    *(.bss)
+    *(.bootstrap_stack)
+  }
+
+  .data ALIGN(4K) : AT(ADDR(.data)-0xC0000000)
+  {
+    start_ctors = .;
+    KEEP(*( .init_array ));
+    KEEP(*(SORT_BY_INIT_PRIORITY( .init_array.* )));
+    end_ctors = .;
+
+    *(.data*)
+  }
+
+  /DISCARD/ : { *(.fini_array*) *(.comment) }
+
+  _kernel_end = .;
+}
\ No newline at end of file
diff --git a/kernelz/obj/boot/loader.o b/kernelz/obj/boot/loader.o
new file mode 100644
index 0000000000000000000000000000000000000000..fa0a974df7a79877640e6fa1748b2f91d38b429f
GIT binary patch
literal 9260
zcmeHNy^9l35TAS)JwMoZU}a$pih>ZX5EMknCT?QLCKnSU7UH_eEnc`J8+KpB*ywS!
z_y_2ppkON~<PeeTY%K#8f>ppu57wF8eMz(sixaMxfqnCvk2m|?Z#Ix(9&36b5{ZD6
z2*hA+0lY{Dk&C`M4~Jn1-XP8@>CZ}PvbB>`(i0`My}5(Co+#<<r^n7>*qeMj5Nrfc
zB3B8%rR5zho9}TMf8F&wZ=Gy^sWp7ZkMG}h$;ZMBFayj0Gr$Zm1Iz$3zzi@0%m6dM
z3@`(G$H3O!mEuaw05iZ0Fayj0Gr$Zm1Iz$3u+JIb|Nr~EL3})B;Qul(j=p|%GKTN?
zxmy47w^z|*0L=!>=L4qRLA0Z@O;b-nOtk`;dM6N2eQ6Vzzh~;52?Apozf53OVCt2F
zK)5F0HljN-Uj*(F&IXPoB!XFjz=R|gdPF!W<1u&^#z-yWO`b2<l=kuun`RxPQ2c{5
zQ2S+7y;Q71MXQvmg;gl%YOw(owOGnS{<@YgH<}eFYxSz88@EdJn@v?Wa%w}9zM5Lp
zjB2xz)9T;~v%O)oY$5C(7_P7fp^H$?wnfdnZ(Zv+R$JK42#gKO>04dnLB|n8vum_W
z*8;=p3uiR2JADCdv)j$veOEX`+TqT21exJ>tG@;TteBmC(BGo~r|^C>7IKa>+LuTl
z0Vtx5Vv}{Uk$@YdkAvTr=rS4^chnPR3$<_py)Kbsbu+?xC?K<D3KKFd*M&@P*cF`?
z-VSYCG1na6<&g?3_HW{!6;l&oI?bxw3o)s9i0Ru~!Y3QrNt|sVOy4kl)0B4z9~xjG
zd-fUPJ>!0}(Mb~G3kWG+=EYNJEQtJ_te{U~3R50ZIum)mE9hCQmrS7}i%%%B2I;7D
qqNcnRbkbgIk$(?5BHdM<4IyMt1AHP7imZq2`z^1Ayik9o$h==AP^vZn

literal 0
HcmV?d00001

diff --git a/kernelz/obj/core/cpu.o b/kernelz/obj/core/cpu.o
new file mode 100644
index 0000000000000000000000000000000000000000..20e5879073144eaf5930cf118921824f2e7f25a7
GIT binary patch
literal 5092
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

literal 0
HcmV?d00001

diff --git a/kernelz/obj/core/cpuhelper.o b/kernelz/obj/core/cpuhelper.o
new file mode 100644
index 0000000000000000000000000000000000000000..0e8e30cf55ffa4fd15f337f2263c88bc1a4e59ef
GIT binary patch
literal 464
zcmb<-^>JflWMqH=Mh0dE1doBi0V-hvrZpH?8JJ*7Nuoh!f-oCYmjI9>iDZHRl+6yL
znUTZ|fa(;H_#iVtKoE$LU6KHlZ~%(205M2Ehz6MnvIE(?1weJ0KrtAAnFr(ZD;!8u
z{rx|Umx+O2=>WgNgEU?SHh!fChhYlzN>VFI81#xWic5-05|e<e%3KHy;ltG7ppork
zVfgqTSs5tg<&gvgKp~c$T9lWXqhDN<te>1;l&YUxP@0jNQ;=Gumsp(3;F_11l#?19
I><ZHc05B6MCIA2c

literal 0
HcmV?d00001

diff --git a/kernelz/obj/core/exceptions.o b/kernelz/obj/core/exceptions.o
new file mode 100644
index 0000000000000000000000000000000000000000..0d0ebb77e8e4b6d1311a9e00f1269eca116da953
GIT binary patch
literal 30032
zcmd^od3amZweQxkjx3L|rNoJc#Bvg6_8{AF?2v?bP#kA)Oq@UlAdzjwmSamsLrB6<
zXrK^63!%_b9;Ib$%S>AcrBG6!1v&r)KA?p{?rTZ|<Q57k!@cnGerum~q;q6hg!_H(
zujen)@2tJ{UVH7e*Is)#=O|zEu3m1jScLv(5g8&u332!wjng1uwkQ%4#fE)<-+Rpd
zTa}WmdynM~(#6rwPn<Zh_o)Jj8gVT5M9gkV-|w|Q`{dQK{A5FUx1l_;?DHNcsU4=&
z<NKF2A+<Y69+Dd_J><CLXUM!C<qkFM^L{|3*P2Ry;CM*vJ#2A2bjT<p>3VSUm@+RM
z-FrCWOG@=7mnt~)F3P;<cxajB*N4@t7aRx2t@UKBHCwZmP3CvFUx10Ep+4B}{Qwp~
z(_n;a4?)v?-eY>2vd?=|zqao49?`F1;KTZL!9MRBWUe7YBlcc!OhgMP^*mGRQBJ+Y
zlzN0yuQH_`=F}TZsc&%VZN^m8bI?qmh#l9vnY4J^z?FKN9D#B?W5^*(UUDevB*vc&
zjQ3=d-ZZ4#jB9b}p=g7=K>oOQA+dZ+;@(5uNY8wj#>ac=!&Dgc)KWc1aILGHs+>`_
z;~_b6P_$lJx(a@~&->btWyo?O_8R`_f=KZD2Epj@_ewS9I73StnN*Gju~Cl8KtoRI
z!Gyu7jZKm;-%!GF?^$w4b{W!Wv>7a>>ovI1lqY3PGOu3XBxA&=SuDqhlc)@O{{Imp
z?0YY;yUx83z5DCKib`I(Uz|9MJ~|Q0)m`D8Kf<4qk{%hG^rNv!*N#oPcudlJ=NO{;
zHRc{OI!n^^;ExSi!AtU?+*IBwTeRPstIa1`wU(>TlCz6O38wZQn~dpd(5?tE6dw~e
zLw6ebW%9zPPl_QvHa^Js3%?pg?jq@7qx(15QO&w|2)X*%Cs9R5DC%wx><sk#-Mzcr
zd;H;$+q<jJKN<~$f}{fRJN!X^*f;F%4u_)tKH|8S`(ndULr!mJ_ab-gF5%r3^@oGL
z;YDt--q$<q2X+Sg{kwo9soOW;=d!cKXxJa|2cvEg_WSy)Lc!tPZV`+4!&M_8XoFN-
z@AUV(MIac7hGSaA+x^kLLARLW_C={aw_dS(jejH*-tF!TMtyxzROjvr;cJsWf^R6^
z=Z{1vb$MVHM2<p_?bHOR)%vh+)X<hL|E?(HB<l1*9_o^Ldpg&&yO$4#e9=H~psG6*
zKm!s68`;$t2_thaTAe5_bNMNKmnH)$?r`_`2S%v*$)?;89P|bIhoPlk?+7Tq!Z%Dc
zx_fp<qW%#f?m>)x8=o@U$$dUU-b47jl%h;7WK_lf+&!dTH0<m1yW@#fRpP^9Ayi?p
zl2_DzF-3@qa=PTdIhoqU)DN?TP^>whO%!74%@{Tr*^VH1B_B=_f)cF-_adj-0X>9z
z`E(&H>UWAzL@mrkX0;L7tm;r1nCfb$5H|H5q-Uy+pkBLrGsZ}k+KY;_)k|GM<fzZ0
zid?mGvJiRd<t0MotK0I0a0thlC~UD#KM#D*(^(KYxA=TWo%6dqT+g5JPrx4Nm03e{
z&D#!4nb63R30*|y|0+eI=Wm6Sf`9pm#JU-7Atq8{iA=19Ol$qo8A8mBCl<)WhEFF5
zQE&rfSR3<lAoLxoY2gbHy@9e~sfxra?MQ5z37v=HiKQ7Zi*?b=)s^TM%H^Q=V^y=?
z1Sl879%^2pEN&%+>d4DSOX%`md@>rSi1nw$DRgdvJ)gkkGjYz`C8$z$?uGDI<B7sK
z4c8NF#RXL`vGOA*X)B$24RxyWFQnL}lnz6zRrx;p%{EmMcBLCGVJnx}a+M~CwYeox
zARLR)Sc`4?#0()^PT0UUucQNt*Fi`R<XNO>*I$s!Hh<bAR7c`R;+)Kz(3iH_Z^Lev
z>4{pIyw9kfx{}T4ev)=aoIL<aWF8@r^^Z&y;+MpsEFzDLWm{0<LkcCl6)!_-ShRxo
z!iQ{)MKH_pc)`+d!((kt#a~1JkY|+M2f4Q9%4gg{$QIN+0L~=4tE3h_N$#ClP>&|7
zZ^A8vaNb`a#0-07!9z$>ro&qHSw++%Lb(}Dw$Gk=0fbtWF66e)k%V1ohMDYh*{JJL
zk$qnADvZzq<yJ_u&o7C9n4r82DfX%<T@Wx?*@v3#HL^^Z@&pN}mD1e8xe>k}%`7f>
z76Zt69a?73oHpS-(q{$q$(%7w>*OfdnU#{T3g-}PVb7dB!G%=ij~Gdrb2;B(czWhM
z&Swwwi_B8Z6_stMD6>owR%LV=h$&98nO%7vEzX?kq5+euP>V9lOQt}B0;Pqdxl4!8
zr4y9fVZzJ`*@zj61KpcB)A1y-%~l%FqRjaY(z;eDq%u|WzKJ-~r2G<!X4XtxiyBra
z3*noYwUSt^%!dPI);lMG)2&Rx@Xl<UvL3{!D1Qdv*nti>k~M`atK16*&8nDwKdKSR
zGIU1P4Ce?k6)4@%DQi{{+2}Qe!a>#?*{C;^=TURkT-n^i?#*aa*8Jk7sIv#HtcN0P
z_+(Ip(rq;#D?0$Cv#Onch0~k?es4UF9L;4vfC5=H&XEcsc7k<voJ~$ELzCqj<goN5
ztki<6y1YvC{cXtk^LTDDv=+#$_mE->oDagl&wx+SUsH<wMp&;U5lzlrXyre^`cIuL
z(C^@!;@kv<Eih3gKC+;&J_H}iTI&221e7ARR_AE#lmm*oUCh0TTGMhjI_=bW9@$P&
zG7lBeXt7TqXIB3kwFtEUbBaZE<5E$l!vq<k<jv`vuk1R?cTnbQLI+vYF1UdrO18m?
zNm6$1LCWEVV4*$<`&!iVP`@JTbF=cZ-UaU%KFU?pU`K_F-O60*je-hN*{Up|o-VAQ
zP;VC%By7sV&?U>6L)VTn)MLpxy%u@r`~u>0wwHGzzF$IKf?gLnmtTa@S@0~pB4^({
zs6{li!{{53e?bTtb1RG9sT6_+zoiR_8B|h;#?_$#k?qQ_LG-my8!hBN3o&=T2jvu-
zV+5W%<qmkBl2ug>)|6$aLCL9_N!PEE4f3j}{SJXVmb{#^QEA@ak&u^P@^=`DTKW{~
z)25rei=kPbqvTf*PMkN1BLhI*WgznkOAa7~IG+-SCP<-ioF&<iOdKar^FWQ`DtVmC
z%qNZ}?FJ0ryor;4g%(klFDDKa7EM0rpI0=c4T?x#(UQfK1+b#xsM?53j{iXEg8WIB
zLrZG~jGbSS_boWb6_9c@J{hyfcGjEVS@~son_;@!kb0la$&gN#L-SF2;UIz+(Z2=t
z2R(<dW?*8;zu4A=l*9PEr*kaxrRaCyM)~_}d2qiIU}Yn;$x4|`lY0JxHtL(HV9n6k
zBB#qO#M2pfL4OYfodU*kovHOe&K*$Z<&5hwOHq!qz#UA=aU0t87j+&+04e@8aIc8x
z(A1j<XUxCNHiYDx@cBucEn9At?0ampA>c8vo{6(%X~hp6^XHYELM>ISXkPw&Nm!LT
zpm%;%Ijx!O$`7fLH8Q~Ex_6^@@_qRNqNv;i^vn!=5=OB|ab<Pz$o#8qcR=|j@Y~{f
zB)j~2NY0_i*H!c>9Dvwc@$u`~M5RC2FB;J~#M*<;MRC^5_0nQu)&Z#Om<toYMef2F
z*Indwc-B40{xd4Fj9RC=$a7HpX{5fWb4)IBF+1ry;J&Zth`Y!ekR!bXN=c~}uN2KL
zauf@KX<$_)vDrlw=+pvMhtAerBmn)th3-8YjDXHGxyV`!V#;w5xcifGXfAR-CRyt7
zTfn_1o<mcQU1T40{WVyBh_g*DatIO*gY{mVElcYzvXWY=y9f~{;UaE?LCU%iJwq$L
zgv~5cobDp~5frz8zdfEuvW+gX4FiGLU&rTiJ)7nt)8U-N`aV9l##wL?vY41<M>jf}
zF;T%qo<ji9U1TeYy@2emP?58#b-Igu57+M^_1`+j<RUaHkl}JMY@PUUS&ky#MVOdL
z16t=;`lM)fk%O>^7p(3iHoHg&F47Oykj~a!<R=(&|AKE`491l@)8rx@NTnRN0`E=A
zp}ELkG2lq?-+=o<Jcp(pyGRitD=nJekF!lK@)?G52E|}}WV5x#=`J!zE!ACwh?8&;
znnWq<W{4aziM2>^x{Le>W8^~c_r>!_w$VivST*+T$a0sSO>>b$Xcv_{gwJo|EVu|+
zOw8&*r_KA{7`=|%Ogr4d;kX%5;(cV)roGH7VLC@a20FotIIqoknT06pC>+9YDW*g@
z*=62B^RM$g2&|?=IcsW(u1$!CZHeMC=Y)^lLTro|Z<dJ@iyuH%i-qQI{4IJG%aO@;
zhx2tf@ydeif-5nPO|a(W-G*}ZjvhGnG`R}24-(;!gn}H-yx&re<w$htIf$4L&oL?Q
zDCO`Xak8F+h~jvTvb=2CX|yA8ik^drshlI<T2YA%S>E<eA$I~<xR@^0$+ym2CRsh5
zVis8^3m3DQHE)Y#wRVg7l7)*ZX4UT0N_7j5R;pXnF>3*hp9xBH;Y~n$>uOQ3s8X8P
z-nv2*oFcC+P^NXGXw<}R6bq^Bv<px`<XcbuR0?P-e2WCMLqIzVXomoATtNFqu}liU
zMT->hD@{OWGyG$MvZl}tw6{S(7Yk^EfVFV}Z5zc(DF7F%q<|BefSx^4z!`-;63_wx
z8(BaL1Z;{6XxS*%O98mpAO$Q#0W@LTb-*l~bqSy3<D!@N=x~4DK@!@A{@Jc~77+vS
z&Ki0N875QM+ChaUuYscu%hLJQ(EG$Io{4>t<UIhlJ4fRw(H!{P<cE<Gqm;?Tkg!wo
zvcC=w64~U7)@<o-+2m8X+2l6`+2kA(vdIr7XH%D#WmE6Ev#BFzWK(a<&L)%2S4gvh
zGv$`AR-sK?!C8`M$R>+5WmB^kXHx^0WmDevY|?jya6AIA6n1A|!7~3g1pC6C4>N=~
z2!-XCw5&kP(?X@|ICL-EQ28p_K~4M<<>{h$UT_&=ec>4&(=<_oab39SEUZilevc4P
zxOo{8N}C|Qa7*!X2r_a@<Lm-Yapo1A0!D5PzMPIJ<ck)OyBWdCSs*FJl6yML;Vhg=
z*2>Eej&?N7;+$BGInT8ObFOo8<!Y!v`uHG4izBX=k;_?J`6@Id&Up#WZfqT#C6x~#
z&=BXk1g8R>;w-H^iZDf-`x2aKXqU6B@^pkj;yjz+ybU#+Q!1xJN8<b~&YAx=7|}WP
z`%vK1cw$~1?CW$_ehu-7vQI*3&B#QFf;QxI&b$MAjRHID=bXF4jb!I2Ol5T~EO-Uk
za~q(gt66p}O!YXr!nH`FEV*TvU|gqYl#=@Z%;H+CQ5m_nL6mEWMp<*OA}LEXO3nQo
z)^eSyQMTN#!Kq!#G%7RqJ>s=!lsz{9i@RDSm64S@K=rjrYC^7<HwDddonG)UOzYY-
zAMG!oqbJwqJ~Sfp>r~^GClKzP;9JfiuOd(2W5VaCA!l09!dW_7<V}I+xXzxD3nNng
zZsL%o5(Tx=d8II%Yg@@D$VB`5A<8I+SKdKPJ+9u8^Wk^Ixr8`$Au@l9PIdMF0gn4)
zJyCKJ!a0xs7WBoR%z4aO;NS&fTmyH)x8A0VvO7zUqnvB7@>X^ZR65a`c?8v-VpVb2
zjk8bX8))!Ei|r{aT;zV)M$4m#7JDnqF;U4p9p<)CLl#?Yw3R5%-%?6Pz>u>MUSeB=
z+)HdRRA8G(1?`!w@UY?uHkr#tYS`$c(?-Ju^{ga$G|Hy>P-db%ht71I7vgJ1QC@B#
zP}zgcM3F-t^9iK`4Js;-gto0OLhM6DcI9p~vuI)w?U!?vpQ6&DB1se|uM=mIBqk__
ziI^;j$x0{uqo`OCWy-&ZQz8kssE}*TDr!7!NUK|LQ7&wBm^GV@v2An`SV6ly8|`Fm
zbYeA|)V0yB#YP8mHVQ2^Ivupp;nQq7qp;C}RZ6`;m-;kXZ4JXMZM1YMwy1?O(J#do
z&0@ut%u?El7F+D4bx2>Dj|gkYv5}*y5RD;AL;Pvm-H?6(NXw0%Kyr~kGAf>~BXcVU
z#PkorYyh+HLRkIx^4wTCFf2sPG|*4n1TMw`iq_Eh|JBuTdJ;v7Te7c#+k7E2tb|*f
z`k#<$xuu4M%c^c!rcqWgiDJ<e+5KpH75dq7<FzOv^IRckf2dQq-Yvvc4vN#zV)~=V
z`ZH3l1=U<zM){QkgRlop0Fx-_?a6)vO}$KN@Oxd{9=RYOag``{LB6KIu$V*vG@N|{
zO0>!n@9QPPRjjg@MB%p~I|v2m!}~2aUV#8Fm28;9c?$PHy+yjzLb{EzgjF6aq>#5P
zi~LSG&_5%5u4rLm+l*L5v@&sKAqB2BrZ&#NfoeMw>!)`^zbfcAV>B8Teg{PW<v=$Y
zOmjv__A;<E`@O8IRuXS8*{?iqzw43pXZT3_%}m&DSqCIp^5B^0Gkh#J$`<Cy^%?Aj
z6jgL0kCKN?z@nT}a+-5GT}`xGr1S>VYpu4NTCDSe`E?bR#l`(D3(BaoQKk%eZ4QxB
zVI?t{hRhYkoSX96A>VG4pCuD23Q%LkG%A{%hYG3Y9F|d$Puc|YJ6(o4u|d;y>2&4g
z>_GlJL!F82RB8SsOHR%rt&TiOa443Hd?ZmjD;$(kP%YxEiz^H}Hc&Mc7R?^C$#=RE
zMRTa6E4kXm#gsh36|Ylfn>a({<Sfmh9afP_HZTgERBh>SaY~`ZX<Ih=d?{qIY^A|C
z#fyYyyveAd#0piGR%A+>Yi-G=s!I)RNf-jlGqa|8_f07>m=eLa8B(=MNLaZ7?qc-6
z+g!TSrI)XmDLrQz^_vjWb1c*XI5SLVZe^vEfVBKmDqa%J6-7yXI<p2PNX9G|*EzdD
zcc?kCBcxwasZ)!kFW~UmpjCx4?v~i{$u6$2a35oE8*{=XwQj1iSURN>S64v&8n{tS
zwb1*b!lre`9yGtU&{CQ2%E>4%EvLi+1XhpP&Sa#z=D00!cR;!T>rA$6Af2>&7Z|kB
z`Y4C&iGyM`5*H((3*mO6DOCX>n$5{|kb+Q^=t4~A?0A^17Gr#(g-bBGiKPjHk~zt>
zPlaE`$37)2lWr+B(Y+ESF}35ko&FH4`A@$qOypCDW-54(;Tli${dayI0m3U*&vaFu
zwG`K9;WL8IUVOfX&p~`%#^)$LS;(kZ$`wcPEGp7SUtUUEgRcxa2hJG8mo<bhbthe2
zL|^;xm2oY7-9TTrQrdm^Qhq^Shv<v$j@n+PufNdOKj`Zd`uYN2nKm>lGZ$a>iTJXq
z7NN?9X5?AaX#;9$OszexmTp$dH>=K9)!a?0Wyw-zIF75620l_t?G>tHv#M@a%Pvt%
z52$D3$i(uY+Cp$Oz7*RLwbb@Yb&Hn1l;G}h((NmmQEPiFRjsu<RdtK%7*wYO)LGlr
ziHp^&jp~E}HETP6ml&=m4XP@1A5c{&nd*De@sD2p$UaS-_K~WRRvXpQRUk`_tE)Du
zZIrT7Ehn%$)etaar5a&!72#rhskW6H0k&!>!fqoOYRgBemov)pi&gb8wS-dcCgtk~
z)N<5Q0JThp^^lsAK2n!c&JWcXK(V{k+|4k$<e@o}R;i5|djqkLsFOA&=dazIB-hko
z$+`dEbloPS!<?$B1FGA;MxF7BI(M^L{fatevs&@WX0;NZIh^KEr^nRwvT4*XIL$0L
z&Ge7dby{;Twoo$6F?Exgy9E|GRh_g%wZv9yutv2Hs3ma4^5m{Vu?($~tXe18&`C>H
zsT1u>$#05Qsa4xm%O?t+y|wh<h<?Lpzc1=vA6gNLL`5L73eWubhXo!S2}kiA8Xfib
zi>;fxn%eLzPAsyvr?D?IG7<_ltPVt?o!wnMTN@+tIhMxtgY@u^*W0)bkMHdCd)KY%
zY1nEi+RzsY`|D~?4}_yJ->~+S&l+D45AcLNwVlC0G~gQ!?D2bdno5}}Ow{LDAfIIl
z^!4l>=?x8Uje5Q94JaD+4@A1L$QoDYE{|t*XRF>ERNURR22T`03$M3%G!_}$+KY!~
zNd5Y)LQ`@D8s<+DskOQuH~qX_J+)h#aIxCI(?9I(Ue&i}{Mu7lOzJ%v#+GdR3jZ!o
zqX^*1D_=Ae7Fs1@O)To)wK~+dL&&e4ngQ2`x(9bh0)4(=ae7C~*0!~)*RI>Ty0c@&
z`mO7{?c=ME)`kn^GhS=AbNltjqvUf>iHD=8^B3zTT(n42bJ3!t9$9MELCfW-)m#iV
z9re_s!v})?{x!bg;ZUD<XsCM#&z<%8`(jag<ZMj4T32uIif*!$)-mm|kx?<?8)cU=
zSfs6c1AI8@7qMVOR^g@{ZxGLenUvC8vY|5wi-%*Q(RP2NFB}+!?d3CXutp>b-I81~
zjUzX&^W%xK{<d}XNoCA#oW=(i^!f(^L6p9btgJnAw|2WpYaVi*2F>@|{k^dP8bk}E
zY3Rv3seQy75IuvTb72U63d|(sOWN+K@9`V#;T`H;zH=uejz6&Cu^`3RjJImUKhlFi
zZW5Emo}PtcyxrTq)8H8GE$dco?O5mCltSXT{pzW03H!Z4^09tcx;+q~OER2%l&~ch
z4dLlR*nWFR$Oi$17Tq+LibVU@#-gLKsDRU8lqN=B>*|)aRYG>)S5l`@(<SbP5h#Uc
zD$Ri~jg{(ZQw;(bs;6%2P;al0VQqUjgdx!3k5W6^17SS>iN`Ek`up*CW<<tK)QM3-
zL8!h?&$v7k*0Url`IVZukd16=<M_UmW`HzA#+@V<wuOQ_{o$y`(-TEg2G)mAowvJB
z80IeyLt~~7Q)_sHHOC`w8_g}_tDDaCJq>v36-vpL<AGW&v|=KlSp!473(v@QVzTji
zQ&kXe5;-%bY5y**Y2LxFlzT`7V<Wwo#8${BQsccKqQ1bed79=(HEzXGK^-7A1QD`#
zh@QSde}8N^d3yY^Rf2h@#X<qWW|Pp(kz#Jq2H@P(b4qd`tWAVGFU`1e=rrkbf)`T;
z%{QqGIR3gORW~+lP4319>PCJ@nWk^d&cmH)CgW7=0euCPGS+G_zBxWp;Rii^;n48#
z_^nB|;*o2QxY-R0qeY7n3!|mN$5BG_p2R|6ID`k8<(FxmH4PLVaLIktn7sPL0Mo?F
z`K%4gOt>ofMPgDGzVJXDJa0$n++eEq#(lP44i;^s)Yo~3gyxSzU$cl-a$YQL;|o5s
zIM&(I8VW@bQzD^Z|AMw*zb~9F3Z&}GdMvS1m(e=X<B9jA)H9Xkj4LMNI(cZwq;#73
z!Bf{l4v+N^#eNzRwOc(6@r8mn7!B|CVxCCMWNn*Tx<t>p0X(8_nl8j3)@}0HemTU(
zOy&C0#He$l9{F@7&>vnobMEvF$NcgEdkhn8VHZ~_lAt^3Ir)Tc+8S5R`OCXEw8pk?
zPl`TiERk-egaN$ESGV9U{NM%z?4BM$uM;Gkowg|Ys}3TuiZyit2Tv`Gq+MwTc40B4
zTZCFIe0}t4!&lvJNjaFM{R81pEZE-`8pe`jc_18#E)V<tVmp0d5N$N8nZm(63zDRG
zWjy}Uat#!^X{qTSmP-oRwQZQx3|)4{iq7?ji)f`>nM#LCDcI;Y4Q+$|z8z3XN~ASW
ze>i~YJt89UN#_h-IEaZ}U&6)bwMa_o$uX#DY`{T7BD+WQCACS4bSqD7+#w>Kh1wv{
zUjLA9f55e63*|OS7~-i(lF3U_g^iTKCY@W?kF%~zjy);*9Se&<)Y~h3+Nzg2Nv?vE
zOlX|Z)6FQU=E?do^W@m&j;2{-k33CS0K<l(P`+1-(;%^z)7AjvTQco<^VB9*!MwZW
z)na1Vi%_J!^rVl=G<Bs}p^hK)Pa-bJm8P6)<T`7shy{Ytrma|Y$%78*U7DULHmnIo
zm$uwXHJ_MfwKKvvZSb1cLTMb$vydGvu`lpqhhdyLTGy>Tqe~cO&hd?y%Jow%@5he3
z2J^-i!;U5<={2V6#+0n9<9FZ^ufXX8*Kas^;8sd&$M-+{Mx01&9)-3iijNt6=a|au
zhS1iiEkLoS9x?<;ZC=x6-o*Ar&<HTK>C2-Bv~P(blF`EMWY^MZI=zWz5^Cc(D+jZ7
zrh(iX57l1L77K^*nw-8m?u&)#QuKyG|HH+rry(rQ8ud}Dsh7N|8WW>asp~Ngie@<|
zRtJJ(&LTN{Ce0%lvfX{XX0az5F6Hzc4UG8P{lih8Fi&|}Wa<q>Bee4Mm}(f~+0E2L
zx-TPpJ(X#oh_F7St%NC|QN&NEgz5CnB;4d;X~XKt4c9vD#njf_oAFvI2CF<c(Z`k4
zFut)h3<xaoyj>zRs-1>zIZK>N!3wiLC^nF^{Y~95d?J=OEW{C`xu4Q_y{9=v5b#C~
z`q43KVl|+xY30Hv#qduYB{ZzYfX398*k7eFeVSP&u}wtp`h6qRyAhE(x`~0|P%jRO
zcMkZr_Q@4uKMs+1|IaFpFHUG?@-$*<N?x0<Y3cBGt#1+NRCxr03+x(9Rxyo_bjK(0
z+OS2CC%JN2i!->+ARWQ=4f?`ZSOx=q0&8~MLC{uS<JXnOqH^lhZeIv(9U?}36tc8H
zYFN#gcgHx>Z1qL3fagtCzqSU%X}xw&AWh5DXoC|fEsBrdmUMPIx!{;W_Lz;Srx9Mi
zJuvL=@{Qm?9i86TfKE3R9cTR2E)N9zwNq+2+4YBFbgpkc5F6t@+6p3ZN61{&$$L&J
z1C9xso_f<R55Xx_!wi#mb9{4^oLAFqAulVNbnmAFNb^a(h=gL{KHB-lV>3=%gJfRq
zew>gqkciO9Jx;3z;N2;-(ih9p{ZD44Py0YD3rwPn=1jF7i=W)bCq>aS?DvnZ=@BE^
zeKX#H(+mG{uEmN4r$VL!p+tbtLxV{N_8#LL+^C&uCADfy@72|%UV))p3w~x`r};($
zPiuM)c|3*=fL+$%K3}?+m~OZwqOq}MDfCT!OD(l4jei;`LzS_nlb^A9chb?d!QD1*
zo@b%kQ(s+IUF)tIsjtIVG#2zP8KB>Z2=syUh5H7Vj3NdGaIXzNDN!}xuG$_9RfR?Z
z(W>oXxNOxZ{d9sqtfj*Xs`_^Ms<2<%6^LqSy|DoO<bg)eDqH?0MMR^+(P%)s!ueW1
z{S*UEF|f&}o5e`S<UbOKM5rfmDATV^<z^3N?=cL~20Hbi`$Y1Fm^ru6-_!16$L<$-
z<q9XqW;D8c)NprEPD7(ufVId&9DQk%@ca0o6;?E+eoGxW8?`t9HzuLDTSNDH$pYb?
zZVh_mk8Nmif@~%9MY>76w!Xm@KlKex&w`};0lb7x9F?ci)i_QUNDU~&$!JR<3&u%=
zecG4xn{P0T9TfHB+<`;$`+Pwh+799jD{&Vy={~cm!Kn@)YZIQ66i;~67!TEHwT;mj
zh>)?h2O+-dk(}`+I&N*qQIb;0q<w^^UivGo<LSr~4%{0}nrDsPn<`p=>8vkrP?$Q^
zC^GF*Uk`EGqY=gxJx(g<HojYqg2-Sf95sjkSTIKCnwm``qxd}%vpGyEq*)Rf4U4BU
z#&1R%8Rk~NX;T~^n}TUdGbaTH^s;tx9KV&K-)TtmbcFu1IEM9)e86G+W~G~e%y-ma
z9lph(MXMAt$2k3<2#ogevoH~n>M<RJ9D24#Mibo0<O4amIbDF+v(Jw(jcrY;ju}&%
z*|EpO1U)jv_gC1uos`_&a)nx7hZQOv33+i3$<+81YYoGGA8{;IZo}N-sWWawXp-so
z<2j8~rHpZsHj|pCAq3F~mpk=T#S%NkM(rMJQq0mqdg{lhnp51eNnToL2564oxb-xc
z4`xsug+4DPni{%@)Zm<8BoH164f=3TuD?ciZLvc>ELIZ<_tnr0RFjz6tNTVrzhY@!
zS|Hdr9P9T(B0Xo8oT@3GI<+S1i|nAA0j!rUNh?!>T^gQuNM_2ZGpRszbq)Rv2YPE*
zL~<dPsNarAYIhPz3x!DaAa74c5gb9_&@0-f-B<)gM|=SCR{)k-bR!5?QTa?AF8cWq
zA6yQH2Jo$EKo|P05L`nbJ^etLaPS9^_ZES;IfMjsC9VVg#4+eNDEJW@%|Kud$Se`;
zto{8|Vzdw6T4Qm+Ef5`TZHwHqv5cI<D@Z)oi`P{Iew_1!MOe<a=UT0o<Dpx6nppp%
zHxpX&?UyR8dFpw;K?cw|e;KanB?z6LF~=fv=zRVCjW~a{V&d!Xfav@SljQ4fmFRqB
zua-fVufN2i^ONh>-;2@t%4g>C`inF=zcZ<R{l%N{`1(6NI$zn%0$>;8A50Ygvx<M6
zh!eOl|Dr0<cw5Hsmm%;rkKr$aeg?wumm%=(lHo5y;B5xOA6|eoP$a)l_BkbzUWIrn
zd>ZGVzIGxNuerqk$Uo?LaQ%<y2Xq2R^oL1wIRxvrA$e;J2B7?5(93}2JH)>;iBAuM
z>wlD=9t79_h@Oonz;)lE^6TUi;aU#jUy?-MnMD63iFV`Zc-<GJzMysABl<GX`X9-^
z2ej^c#6JvL_cfxO7$mxH5xo+$?n^}PO+2J8?RReyZ5-<qmeb$o8#@svpWS}hOqb$5
z@|P7Ee*)GfyYcrgU;bE`7Aa5ee1B}?$KGd3(Ux@QFk?ifxdD|zv`O#8UdxnIn<>W}
z+l_smM9Vnd>4#C~7_Ch=7mPVm?YG9>xKB}njb^+-lp<H!Wr{Js<|rvwMPKsF#~3N5
zTl{HH2gjJHuI{TG?~GX!n^(AFq^Ew~Aie&)!T0K?F3HR2F_ok_QA=A>U7Ah2u^>Cl
zNj*8wV>fx5{AG{#;q@NGRSTvv{I-CwAfDoVOM3B9;73A)f+=k}A*QlwLImMPLS$Y6
zq;jVbqTK0}j&cJ`<1JdD;2o|D3Gw#qHwYo;cIMy7{3i(U64rBsDF0{XzsdYhnQz5h
zM0^L3>YG3`<Tnwbd^_`36GHFP2vOgegwVU65PH)qQl$6!L?a)~c_i=8L_^-YOux@G
zz1~H9di#m^MNF46E#H#`-@|k(^E;TPIg-ks!L*+c_88^#7^l-OK2rKMoc>)-{{bOh
zu)B-X@8|T#n0|uk-w}=X)LvqIgVOQ-+fk<J2Q7(qK^M|zGCtHEnuDp_9HPN*B7~h=
zDIM>~`iRC`*uzBQa}LqqUq}f1?jwYK4-mq>^b<Uk?<Yhf-_M!;1<|PQ_k?KYON1!@
zHuL4LGa~<gF@1vg$e)inTA2d76C(dqAjzLjH2CymI3#Zg^IHkguN_RUBZPjN38CLG
zkorGH2swKw9rf;K`f8#f_ZC9Py^|32(wpm)pI%-k{@aA`yAKIb{tM<SSVj`Rj1c_U
zgy7T9BU1S$=AX&@LFSJVLhl$M>br;#dS6Zmy>ACndHTge1urf>O^Bac_zNKhE&Yt4
zf?os>c->UN;B^sV!9Ep8?VUx4^7APj`kg`u{W=Jt-#X@>!E`Uv14JYLZbI0DemIQu
z`vxKOlE2>vKe-h&`O8CusOK@_Ps5Ke5e@%(j`3AWho61K^yf^MW4WzN7vf<WfAG~u
z84oc&#Yk^068{g3FEGk+jP%!-euMEa;}OQAjK>&1U_8$FDdXpia{NQC6(6cs#!J{5
zCKDFuj4lusBvRZY#88p>rV*lTvj~x|o>9JW4!Vo!^^BVtw=r&Kq&Q0D!;HHaDXvob
zC5%@vUd{L&#v2)LVf-=UeT=_ke1h?5#^)GcW&A7SF-F>ZQ2q2WD`6&M5n~zSJVp;=
zBjaMm7RC<7(;3fX+`&kD7pmucM%phEeI4VCjP#N#r9Z?-zm-h%^NepX%Kk_CXH3)k
zu9VNk=w_^DT*TPIxSnwfV~{b*csb)$j6Y($hw)LyCm9bjzRmb=#?Kk)M=eOdT*e~C
zsf<;O4U8>}U5r~82N`3GUuV3E@kU09-&Eg0MtYN(=sz*O$#{(MGe#T5LF98YRxvJO
zq_|A{^^88oAme$Amor|+Nb#7;-N#73jzRSA7@uc+o$)B+zZoemQ+@{{#b=_YGqy9X
zV(eoaVm!cjJ>!Fnk21c@_&Vc18UM{_r+7#8GkO>oGOlLa!suh9_)FzR7^94P8TT<>
z#rPe@+Zpd-e1P#$Mj4kO_eG}PVx*r$q5A$0V>YgdE@UiWbTd{m&SUg2E@Et9Jc}{J
zcpl?rjNfMb0pneaKV|$4;~yB`VtkwNGe!!~q_2yygt3aTfw6;;ehroKZ)M!UcrN3G
zjPwJXl<#`R`xzf%{3GMbjK>&1V$8wu5tVl`Rx-|G>|k8O7+?%B?q|G)@lM7E7@uW)
zh4F8UA25EwXvG{&dQ>vbXKZKeWL(QQ#JG>~TZ}g_-pu%O#$PhN#Q0~%4;VjTbYKlb
zdK58MGcI6U!Pvz}KR-zMM;WhVyoT{!#s?Yy$oMkjF~-jrZCDeLJQpMVE)>zT7*{Z^
zWgK7}W(+falkslG2N)k?e2Vc^#y1&1X8fGdg#`uGU&2_&*vxnu<3`3EjOQ?ZlkwY(
z_c1=m_$S8K7(ZbAgwcVuC)HoZIES&3v5j#h;||6!;}wioF<!@bKjZU^FEhT*_#ccP
zFn-LaVvR}q<S>>nx*2O27cjOnu4LTAxQ#K$xRdd5tX)a|vy87Z{+;m?Mhg~rly5zw
zkMWy~-(&m%<HL-PGrq|98slFX|HgQf@t=$zG5!~$6>D#*zmTz<v5Ijq;|j*LjJ=Ej
z#`78XGJc2g`;7N99%TF-<DVFhFuu$98Kc0Sfb^TpIF)fa;~d5s#>I>)88<R+XN)p_
zo$+eMn;7qAe1!2C##b5NWIV$74&(cb#~J^N(S<z_>0it^o3V!RG{%jLI~c=^mon~W
z{0ZZIj4v|2#`q7$e=>f~n2imD>}SSljB^;<8MiR*X57no72}PJKVf``@kz!P82`%n
zE+hRSAJuQgSp(rkjCV2~Bt-0ff)H!cw-}Ey{|lz`u-7C0RK_Yo$UBYcAk*hFeJRsF
zWco3tUu61YMi=&sB&UM0hVcx>Fd^zaz<4jGKg#rPn0|w4EN_GbYeQ_Y6Z<vH)ia3(
z&Sk7-tYd6sT*SDPv6XQ(<7teiGj3tr#^`4pVhk}x8Fw?veIE4L%k<@p-(<Xo@w<$2
zzlZ!cGkpi+U5xiLKFIh8<Kv7^F+N8Kd&2y}g0%zP`y;xE>BUTMWco~|cQJiF)7LY7
zBhwEv{V3C~G5rS9pECV9)01g`M)ea?{Y)=rT2$k0pQx`F7!7MUs9%Ns!_|1WE-I?=
z%Pl@p-HW&Pt0^%Y(h}%e-Z0)8pdT>cYhQ0K{i1-(sd0T_UvR+Bg|(z%yz`(JKz;fp
zC2y59-9n%Tq77oS$D7cwll&`3J~We#bmU(HzKy>w1#`$hI`)By#4<_YjO$F?2ZL`T
zM9cEHl;;+eOk=Ai|7cBa{G+<)Zyr8yA>6an{^Z)7uL<;gqz_%|dTfKdxjKP#s+az1
z@iFT6`8FYbh&0j<+asBe>RX17E*qEfzX13c<5mCDd5e)?ly{>KKlqPz49TM=>Ft$c
zQ7;U<Xgc)Ml>)8HJKJzg+3%bsgqtq-PtQkZG{$=SF=#1%P`wC^@p{j}wO$67;&+hu
zjBZQ=Zv@vyc~QtCe<yiZ7RKdWz-7pe^mh$92){HJ|D(F-BVz+l&-XI~p)x~%==tQB
zG~|1}N2?P_@=woqJ1Dx=|BfKvdP9P4%A1kF*p4el6a9;2RJ<Kj)S!-N+JHVs0;b})
j{m7mq%U~|C>kRFj70L2XSAk?3^Ua6hf693X^nCvpOmzOz

literal 0
HcmV?d00001

diff --git a/kernelz/obj/core/fpu.o b/kernelz/obj/core/fpu.o
new file mode 100644
index 0000000000000000000000000000000000000000..ba85113dc5807644eb5f66bf7cf262361636c904
GIT binary patch
literal 3840
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
BkGB8-

literal 0
HcmV?d00001

diff --git a/kernelz/obj/core/gdt.o b/kernelz/obj/core/gdt.o
new file mode 100644
index 0000000000000000000000000000000000000000..9b22bb98175e45e9fa7295d95f7f45a1be3f9a83
GIT binary patch
literal 4584
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
V$U=Uokbl2j26y%gLgO{c?!SOq@0kDq

literal 0
HcmV?d00001

diff --git a/kernelz/obj/core/gdthelper.o b/kernelz/obj/core/gdthelper.o
new file mode 100644
index 0000000000000000000000000000000000000000..4c861159b50d9892f8717ae7b2f5520febd7cef5
GIT binary patch
literal 560
zcmb<-^>JflWMqH=Mh0dE1doBi0V-hvrZpJY7?@y6Nuoh!f-oCYmjRHYgk*vMl+6yL
znUTa3fa<i7_#iVtKoE$LT`~bE5daipLBb$2C4m^(yazyamOwEWfSIQV6ySsj0%--H
z;T%93q!*+HWG;x`?V`fM&nS?#Lx3Tz??zhRfwaB{X?-u!`YyZz8NtDD7)T-my^_?5
z5(d5EjN+1_lEfq+t1=ftL-|FiIS@6-y5MY>`#=IL3?Ki)C4dZ2OlbmXki`(d$RH16
z0%-w|%d=C9@=|m3i;I%=lk<yG_0v;IGE#F2Qj7Ewi*p%(y!f=7(&7vROAo?_nj;OQ
I8Ib}S0EQkox&QzG

literal 0
HcmV?d00001

diff --git a/kernelz/obj/core/idt.o b/kernelz/obj/core/idt.o
new file mode 100644
index 0000000000000000000000000000000000000000..726e1c78e4cc42ed94569cceb8e21ed9efd36b17
GIT binary patch
literal 14400
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

literal 0
HcmV?d00001

diff --git a/kernelz/obj/core/idthelper.o b/kernelz/obj/core/idthelper.o
new file mode 100644
index 0000000000000000000000000000000000000000..1d72e0ddc56510d832eefff4123224041bfed6f2
GIT binary patch
literal 2464
zcmai$T}V_x6vt;Zb?s|cgNTakL(Pxe?$)Lj(TDDeLTIT$^s=t&H5I?Qd#$aYf_kW+
zeXFPF!yxRTi0C1TKtg&c2zru&=pmwMD1xAeGVFhLcD9M8I&#naf9D)$cIVtXdrw4m
zHF-Q9rp&`~*)L+O%PTXX^iaXPtbh&Rj~Af|!o$5%<nURPAd<_!N->9jlp>G6l_H<N
zlA?gWAmQatB^UC?B<AvmG|c1oXqeA$(XfEupkX1uLIWG{@rzRU`FSad_-QGM#c>oY
z5=r=#!hv5U2H{tWUidYl3%*qBhc6SI@a3WveywPRuMiFJm0~M=m8gZU78d+EQ3YQk
zO5p=y1^jxk1b&Yw9$<Yxu&^kEI7xzi>spcTyXu?hz3*qK>C|NEP3nE;`<dC<*|Sr=
zo4#uWC9zXe-tW(!qxyHFJztvLcn>Sq(tdQL99)=*5pRK3HN>spWm>))x>Vys&@~#L
zgRa&1GW2$h??N|g`~<p9<CoC;H2wq~)i?*=rB~y{;318xz^=yIz{fOh2UAzc===48
zsoiA6N5OO-kP)ZAmn5cn96YY^Bk+XA)8N}0e*x27M@I84%wg<-#57leCp8X(X-~+g
zJ_>#&G0jK8bdQr!{sMSfVw&%OUu*mnOiu|J)xQIOkeFsqE@PiHUJm}MaUFO@<90Ch
zfQ;rF0@IVK_zajHVa3<M%KQ+Y!3|oT^$)wY<BW~EeX-%5LEB-?=`oUw+oNv($gq{P
zEJG}4h;1;$HX33fLu`{FR%?jW8DjN@*k(g)ry<s0h&38wVM8oph&BBg3mWz>XxP7?
zVgG_^|5{X=+U<j5cEZ)#Vo0gk4JoyVA@z^7RLczir8;LwsRkNSs*i@0YNsKkx@t(N
z<{DC}$A*+@wIQWCZb+%d8&azOf2KD6y(!_puT^WY=>FFF##r1POSE-_;v<f|A(Wjx
zY$xJQ|EN3SbjG>|?cgT)^k(ys-K`x~w7zlo-VQhB+7Z@rU>GxG^UT6okW-0+A&@vS
z<i@%&x{e(ClydCBfNLjR7U+q&F&5}fB-D}e-?0Q0bll`;D(QWrF?0S<NJ;vQqu;?D
zxX3E-enPJ(dAO)%4ld%d469@9u$lmIGKJO9RR6y^s>hL>wIl*`hSTSzIIT<PCVe(F
Z7bL5o1YH?Z>lT6aItw4dQbib5-A~D4Bn<!n

literal 0
HcmV?d00001

diff --git a/kernelz/obj/core/physicalmemory.o b/kernelz/obj/core/physicalmemory.o
new file mode 100644
index 0000000000000000000000000000000000000000..a038fe29185163a98850c069a2b1d7358f4d37ad
GIT binary patch
literal 22560
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

literal 0
HcmV?d00001

diff --git a/kernelz/obj/core/power.o b/kernelz/obj/core/power.o
new file mode 100644
index 0000000000000000000000000000000000000000..54ec897b6a370c3fccbbe5e084177070dc1c6835
GIT binary patch
literal 17368
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

literal 0
HcmV?d00001

diff --git a/kernelz/obj/core/tss.o b/kernelz/obj/core/tss.o
new file mode 100644
index 0000000000000000000000000000000000000000..4fa6db9b92136798a489311d45a4d2a9ce591a06
GIT binary patch
literal 5596
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

literal 0
HcmV?d00001

diff --git a/kernelz/obj/core/tsshelper.o b/kernelz/obj/core/tsshelper.o
new file mode 100644
index 0000000000000000000000000000000000000000..4d56569083d72c1bd5493143648a5538d2b2fd27
GIT binary patch
literal 448
zcmb<-^>JflWMqH=Mh0dE1doBi0V-hvrZpH?8JJ*7Nuoh!f-oCYmjIB%fn<UJl+6yL
znUTa5fa(;H_#iVtKoE$LT@nD4Z~%(205M2Ehz6M{3FQMRFqi;TrwQW#X_$F1p|l+u
z4Ezi?4#W5idL^k9B@BAS8O0?<C5cHuR%I@PhVbDEu``g(XJPpGA6XSBq~(zW1VFCI
sPA$qy&CxF|O4d)#FG|%fDK5@P%_&GN(n~DPWk|~@EzXDsiovu20OCU<S^xk5

literal 0
HcmV?d00001

diff --git a/kernelz/obj/core/virtualmemory.o b/kernelz/obj/core/virtualmemory.o
new file mode 100644
index 0000000000000000000000000000000000000000..244a04da94827d9a3f392bb8b2db465b785f3a53
GIT binary patch
literal 20200
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
H%;Nt7If_?f

literal 0
HcmV?d00001

diff --git a/kernelz/obj/gdb/gdbimpl.o b/kernelz/obj/gdb/gdbimpl.o
new file mode 100644
index 0000000000000000000000000000000000000000..e0e8d8cf5868b364d556276b9540766ca77bfd58
GIT binary patch
literal 8672
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

literal 0
HcmV?d00001

diff --git a/kernelz/obj/gdb/i386-stub.o b/kernelz/obj/gdb/i386-stub.o
new file mode 100644
index 0000000000000000000000000000000000000000..a5c1d99989391b19efe6af9f825e58c5aeda5736
GIT binary patch
literal 20808
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

literal 0
HcmV?d00001

diff --git a/kernelz/obj/kernel.o b/kernelz/obj/kernel.o
new file mode 100644
index 0000000000000000000000000000000000000000..e996a5f4617fae85ae53c67819ac1954eb80b37b
GIT binary patch
literal 68372
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
WvxDZ*L60@wdYh%?`#dYK_5K5?M2{2z

literal 0
HcmV?d00001

diff --git a/kernelz/obj/system/virtual8086/VM8086Code.o b/kernelz/obj/system/virtual8086/VM8086Code.o
new file mode 100644
index 0000000000000000000000000000000000000000..5ecef02281dde88028b3cd7a3631699af64cafe3
GIT binary patch
literal 672
zcmb7BJxc>Y5Pg>~twKZ)(<Iti-HAv@AtI3k18O5^>*<{slHA3;HJHjPJ+8@LQ2&IL
zg^kty82><YCijs=uyA1Z&3iNRc3~ge#~n@6kcNgl77RE@8oP7cLJ_%i^k2xHoTX%|
zLgZ9&s3i3gVP4TMX>L>D?7^`@slH@NjVWmb%3^}-S*29{HfZUNv@}w`l$Yx-RXoEF
zYdJqG7yNLo<cIsqeuP@N{t7=JJs>?GJz#zI^znwH&k{y0ykiutid-~f3Pdw<)usI)
zp?kNU6w<t+YBG#5=IO<Mp!&W7zP{Bl{;3uT>zSzGg6fXK^{fUeG{5(Y^B?Ra8ux9g
zS>s@izAYSkV0hx%@Ft$LhsL-k<h?m)ZZ{jo`3b|JYuUQ#4MB8H&ZH?Mx{ho%;#0R=
ZVz7E%zw6w%S<x2471>(bvErK-=MSQuRRjP4

literal 0
HcmV?d00001

diff --git a/kernelz/src/boot/loader.s b/kernelz/src/boot/loader.s
new file mode 100644
index 0000000..3125174
--- /dev/null
+++ b/kernelz/src/boot/loader.s
@@ -0,0 +1,91 @@
+.set ALIGN,    1<<0             # align loaded modules on page boundaries
+.set MEMINFO,  1<<1             # provide memory map
+.set FLAGS,    ALIGN | MEMINFO  # this is the Multiboot 'flag' field
+.set MAGIC,    0x1BADB002       # 'magic number' lets bootloader find the header
+.set CHECKSUM, -(MAGIC + FLAGS) # checksum of above, to prove we are multiboot
+
+.section .multiboot
+	.align 4
+	.long MAGIC
+	.long FLAGS
+	.long CHECKSUM
+
+.set KERNEL_VIRTUAL_BASE, 0xC0000000
+.set KERNEL_PAGE_NUMBER, (KERNEL_VIRTUAL_BASE >> 22)
+
+.section .bootstrap_stack, "aw", @nobits
+stack_bottom:
+.skip 16384 # 16 KiB
+.global stack_top
+stack_top:
+
+.section .data
+.align 0x1000
+.global BootPageDirectory
+BootPageDirectory:
+	# identity map the first 4 MB
+	.long 0x00000083
+	
+	# pages before kernel
+	.rept (KERNEL_PAGE_NUMBER - 1)
+	.long 0
+	.endr
+	
+	# this page contains the kernel
+	.long 0x00000083
+
+	# pages after kernel
+	.rept (1024 - KERNEL_PAGE_NUMBER - 1)
+	.long 0
+	.endr
+
+.global _kernel_virtual_base
+_kernel_virtual_base:
+	.long KERNEL_VIRTUAL_BASE
+
+.section .text
+.align 4
+.global _entrypoint
+.type _entrypoint, @function
+
+_entrypoint:
+	mov $(BootPageDirectory - KERNEL_VIRTUAL_BASE), %ecx
+	mov %ecx, %cr3
+
+	# enable 4 mb pages
+	mov %cr4, %ecx
+	or $0x00000010, %ecx
+	mov %ecx, %cr4
+
+	# enable paging
+	mov %cr0, %ecx
+	or $0x80000001, %ecx
+	mov %ecx, %cr0
+
+	# jump to higher half code
+	lea 4f, %ecx
+	jmp *%ecx
+
+4:
+	# Unmap the identity-mapped pages
+	movl $0, BootPageDirectory
+	invlpg 0
+
+	movl $stack_top, %esp
+	# Mark end of call stack for unwinding
+	movl $0, %ebp
+
+	add $KERNEL_VIRTUAL_BASE, %ebx
+
+    call callConstructors
+
+	push $_kernel_base
+	push $_kernel_end
+    push %eax
+    push %ebx
+    call kernelMain
+
+_stop:
+    cli
+    hlt
+    jmp _stop
diff --git a/kernelz/src/common/convert.cpp b/kernelz/src/common/convert.cpp
new file mode 100644
index 0000000..c1a22ec
--- /dev/null
+++ b/kernelz/src/common/convert.cpp
@@ -0,0 +1,163 @@
+#include <common/convert.h>
+#include <common/string.h>
+
+using namespace CactusOS::common;
+
+int IsSpace(char c)
+{
+    return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
+}
+
+char* Convert::IntToString(int n)
+{
+    static char ret[24];
+    int numChars = 0;
+    // Determine if integer is negative
+    bool isNegative = false;
+    if (n < 0)
+    {
+        n = -n;
+        isNegative = true;
+        numChars++;
+    }
+    // Count how much space we will need for the string
+    int temp = n;
+    do
+    {
+        numChars++;
+        temp /= 10;
+    } while (temp);
+
+    ret[numChars] = 0;
+    //Add the negative sign if needed
+    if (isNegative)
+        ret[0] = '-';
+    // Copy digits to string in reverse order
+    int i = numChars - 1;
+    do
+    {
+        ret[i--] = n % 10 + '0';
+        n /= 10;
+    } while (n);
+    return ret;
+}
+char* Convert::IntToString32(uint32_t n)
+{
+    static char ret[32];
+    int numChars = 0;
+    // Count how much space we will need for the string
+    int temp = n;
+    do
+    {
+        numChars++;
+        temp /= 10;
+    } while (temp);
+
+    ret[numChars] = 0;
+    
+    // Copy digits to string in reverse order
+    int i = numChars - 1;
+    do
+    {
+        ret[i--] = n % 10 + '0';
+        n /= 10;
+    } while (n);
+    return ret;
+}
+
+char* Convert::IntToHexString(uint8_t w)
+{
+    static const char* digits = "0123456789ABCDEF";
+    uint32_t hexSize = sizeof(uint8_t)<<1;
+    char* rc = new char[hexSize + 1]; //Terminate string with 0
+    MemoryOperations::memset(rc, 0, hexSize + 1);
+
+    for (uint32_t i=0, j=(hexSize-1)*4 ; i<hexSize; ++i,j-=4)
+        rc[i] = digits[(w>>j) & 0x0f];
+    return rc;
+}
+char* Convert::IntToHexString(uint16_t w)
+{
+    static const char* digits = "0123456789ABCDEF";
+    uint32_t hexSize = sizeof(uint16_t)<<1;
+    char* rc = new char[hexSize + 1]; //Terminate string with 0
+    MemoryOperations::memset(rc, 0, hexSize + 1);
+
+    for (uint32_t i=0, j=(hexSize-1)*4 ; i<hexSize; ++i,j-=4)
+        rc[i] = digits[(w>>j) & 0x0f];
+    return rc;
+}
+char* Convert::IntToHexString(uint32_t w)
+{
+    static const char* digits = "0123456789ABCDEF";
+    uint32_t hexSize = sizeof(uint32_t)<<1;
+    char* rc = new char[hexSize + 1]; //Terminate string with 0
+    MemoryOperations::memset(rc, 0, hexSize + 1);
+
+    for (uint32_t i=0, j=(hexSize-1)*4 ; i<hexSize; ++i,j-=4)
+        rc[i] = digits[(w>>j) & 0x0f];
+    return rc;
+}
+
+int Convert::StringToInt(char* string)
+{
+    int result = 0;
+    unsigned int digit;
+    int sign;
+
+    while (IsSpace(*string)) {
+        string += 1;
+    }
+
+    /*
+    * Check for a sign.
+    */
+
+    if (*string == '-') {
+        sign = 1;
+        string += 1;
+    } else {
+        sign = 0;
+        if (*string == '+') {
+            string += 1;
+        }
+    }
+
+    for ( ; ; string += 1) {
+        digit = *string - '0';
+        if (digit > 9) {
+            break;
+        }
+        result = (10*result) + digit;
+    }
+
+    if (sign) {
+        return -result;
+    }
+    return result;
+}
+uint32_t Convert::HexToInt(char* string)
+{
+    int length = String::strlen(string);
+
+	if (length>8)
+		length = 8;
+
+	int fact = 1;
+    uint32_t result = 0;
+	for(int i = length - 1; i >= 0; i--)
+	{
+		char digit = String::Lowercase(*(string + i));
+		if ((digit >= '0' && digit <= '9') || (digit >= 'a' && digit <= 'f'))
+		{
+			if (digit >= 97)
+				result += (digit - 87) * fact;
+			else
+				result += (digit - 48) * fact;
+			fact = fact << 4;
+		}
+		else
+			return 0;
+	}
+	return result;
+}
\ No newline at end of file
diff --git a/kernelz/src/common/memoryoperations.cpp b/kernelz/src/common/memoryoperations.cpp
new file mode 100644
index 0000000..f8eae17
--- /dev/null
+++ b/kernelz/src/common/memoryoperations.cpp
@@ -0,0 +1,44 @@
+#include <common/memoryoperations.h>
+
+using namespace CactusOS::common;
+
+void* MemoryOperations::memmove(void* dstptr, const void* srcptr, uint32_t size)
+{
+    unsigned char* dst = (unsigned char*) dstptr;
+	const unsigned char* src = (const unsigned char*) srcptr;
+	if (dst < src) {
+		for (uint32_t i = 0; i < size; i++)
+			dst[i] = src[i];
+	} else {
+		for (uint32_t i = size; i != 0; i--)
+			dst[i-1] = src[i-1];
+	}
+	return dstptr;
+}
+int MemoryOperations::memcmp(const void* aptr, const void* bptr, uint32_t size)
+{
+    const unsigned char* a = (const unsigned char*) aptr;
+	const unsigned char* b = (const unsigned char*) bptr;
+	for (uint32_t i = 0; i < size; i++) {
+		if (a[i] < b[i])
+			return -1;
+		else if (b[i] < a[i])
+			return 1;
+	}
+	return 0;
+}
+void* MemoryOperations::memset(void* bufptr, char value, uint32_t size)
+{
+    unsigned char* buf = (unsigned char*) bufptr;
+	for (uint32_t i = 0; i < size; i++)
+		buf[i] = (unsigned char) value;
+	return bufptr;
+}
+void* MemoryOperations::memcpy(void* dstptr, const void* srcptr, uint32_t size)
+{
+    unsigned char* dst = (unsigned char*) dstptr;
+	const unsigned char* src = (const unsigned char*) srcptr;
+	for (uint32_t i = 0; i < size; i++)
+		dst[i] = src[i];
+	return dstptr;
+}
\ No newline at end of file
diff --git a/kernelz/src/common/print.cpp b/kernelz/src/common/print.cpp
new file mode 100644
index 0000000..a2b9ea0
--- /dev/null
+++ b/kernelz/src/common/print.cpp
@@ -0,0 +1,59 @@
+#include <common/print.h>
+
+using namespace CactusOS;
+using namespace CactusOS::system;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+
+void Print::printfHex(uint8_t key)
+{
+    char *foo = "00";
+    char *hex = "0123456789ABCDEF";
+    foo[0] = hex[(key >> 4) & 0xF];
+    foo[1] = hex[key & 0xF];
+    system::BootConsole::Write(foo);
+}
+void Print::printfHex16(uint16_t key)
+{
+    printfHex((key >> 8) & 0xFF);
+    printfHex(key & 0xFF);
+}
+void Print::printfHex32(uint32_t key)
+{
+    printfHex((key >> 24) & 0xFF);
+    printfHex((key >> 16) & 0xFF);
+    printfHex((key >> 8) & 0xFF);
+    printfHex(key & 0xFF);
+}
+void Print::printbits(uint8_t key)
+{
+    for (unsigned int bit = 0; bit < (sizeof(key)*8); bit++)
+    {
+        BootConsole::Write(Convert::IntToString(key & 0x01));
+        key = key >> 1;
+    }
+}
+void Print::printbits(uint16_t key)
+{
+    for (unsigned int bit = 0; bit < (sizeof(key)*8); bit++)
+    {
+        BootConsole::Write(Convert::IntToString(key & 0x01));
+        key = key >> 1;
+    }
+}
+void Print::printbits(uint32_t key)
+{
+    for (unsigned int bit = 0; bit < (sizeof(key)*8); bit++)
+    {
+        BootConsole::Write(Convert::IntToString(key & 0x01));
+        key = key >> 1;
+    }
+}
+void Print::printbits(uint64_t key)
+{
+    for (unsigned int bit = 0; bit < (sizeof(key)*8); bit++)
+    {
+        BootConsole::Write(Convert::IntToString(key & 0x01));
+        key = key >> 1;
+    }
+}
\ No newline at end of file
diff --git a/kernelz/src/common/random.cpp b/kernelz/src/common/random.cpp
new file mode 100644
index 0000000..000410e
--- /dev/null
+++ b/kernelz/src/common/random.cpp
@@ -0,0 +1,21 @@
+#include <common/random.h>
+
+using namespace CactusOS::common;
+
+uint32_t Random::next;
+
+int Random::Next(uint32_t max)
+{
+    next = next * 1103515245 + 12345;
+    return (unsigned int)(next / 65536) % (max+1);
+}
+
+int Random::Next(uint32_t min, uint32_t max)
+{
+    return Next(max-min) + min;
+}
+
+void Random::SetSeed(uint32_t seed)
+{
+    next = seed;
+}
\ No newline at end of file
diff --git a/kernelz/src/common/string.cpp b/kernelz/src/common/string.cpp
new file mode 100644
index 0000000..308887a
--- /dev/null
+++ b/kernelz/src/common/string.cpp
@@ -0,0 +1,164 @@
+#include <common/string.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+
+int String::strlen(const char* str)
+{
+    uint32_t len = 0;
+	while (str[len])
+		len++;
+	return len;
+}
+
+bool String::strcmp(const char* strA, const char* strB)
+{
+    while(*strA == *strB)
+    {
+        if(*strA == '\0')
+            return true; //If we reach this the strings are equal
+        ++strA;
+        ++strB;
+    }
+    return false;
+}
+
+bool String::strncmp(const char* s1, const char* s2, int n)
+{
+    while(n--)
+        if(*s1++ != *s2++)
+            return false;
+    return true;
+}
+
+int String::IndexOf(const char* str, char c, uint32_t skip)
+{
+    uint32_t hits = 0;
+    int i = 0;
+    while(str[i])
+    {
+        if(str[i] == c && hits++ == skip)
+            return i;
+        i++;
+    }
+    return -1;
+}
+
+bool String::Contains(const char* str, char c)
+{
+    int i = 0;
+	while (str[i])
+    {
+        if(str[i] == c)
+            return true;
+		i++;
+    }
+    return false;
+}
+
+List<char*> String::Split(const char* str, char d)
+{
+    List<char*> result = List<char*>();
+    int len = String::strlen(str);
+    int pos = 0;
+
+    // Loop through string and everytime we find the delimiter make a substring of it
+    for(int i = 0; i < len; i++) {
+        if(str[i] == d) {
+            int itemLen = i - pos;
+            if(itemLen > 0) {
+                char* part = new char[itemLen + 1];
+                MemoryOperations::memcpy(part, str + pos, itemLen);
+                part[itemLen] = '\0';
+                result.push_back(part);
+            }
+
+            pos = i + 1;   
+        }
+    }
+
+    // Skip delimiter character
+    if(pos > 0) {
+        // Add remaining part (if available)
+        int lastLen = len - pos;
+        if(lastLen > 0) {
+            char* part = new char[lastLen + 1];
+            MemoryOperations::memcpy(part, str + pos, lastLen);
+            part[lastLen] = '\0';
+            result.push_back(part);
+        }
+    }
+    return result;
+}
+
+char* String::Uppercase(char* str)
+{ 
+    int len = strlen(str);
+    int i = 0;
+	while (i < len)
+	{
+		if ((short)str[i] >= 97 && (short)str[i] <= 122)
+			str[i] -= 32;
+		i++;
+	}
+    return str;
+}
+char* String::Lowercase(char* str)
+{
+    int len = strlen(str);
+    int i = 0;
+	while (i < len)
+	{
+		if ((short)str[i] >= 65 && (short)str[i] <= 90)
+			str[i] += 32;
+		i++;
+	}
+    return str;
+}
+char String::Uppercase(char c)
+{
+    if (c >= 97 && c <= 122)
+		return c - 32;
+    
+    return c;
+}
+char String::Lowercase(char c)
+{
+	if (c >= 65 && c <= 90)
+		return c + 32;
+    
+    return c;
+}
+
+char* String::strcpy(char *s1, const char *s2)
+{
+	strncpy(s1, s2, strlen(s2) + 1);
+	s1[strlen(s2)] = '\0'; //tack on the null terminating character if it wasn't already done
+	return s1;
+}
+
+char* String::strncpy(char *s1, const char *s2, unsigned int n)
+{
+	unsigned int extern_iter = 0;
+
+	unsigned int iterator = 0;
+	for (iterator = 0; iterator < n; iterator++) //iterate through s2 up to char n, copying them to s1
+	{
+		if (s2[iterator] != '\0')
+			s1[iterator] = s2[iterator];
+		else //the end of s2 was found prematurely - copy the null character, update external iterator and quit for loop
+		{
+			s1[iterator] = s2[iterator];
+			extern_iter = iterator + 1;
+			break;
+		}
+	}
+
+	while (extern_iter < n) //while there are still spaces that need to be filled with null characters, fill them
+	{
+		s1[extern_iter] = '\0';
+		extern_iter++;
+	}
+
+	return s1;
+}
\ No newline at end of file
diff --git a/kernelz/src/core/cpu.cpp b/kernelz/src/core/cpu.cpp
new file mode 100644
index 0000000..f3a839f
--- /dev/null
+++ b/kernelz/src/core/cpu.cpp
@@ -0,0 +1,55 @@
+#include <core/cpu.h>
+#include <system/bootconsole.h>
+
+using namespace CactusOS;
+using namespace CactusOS::core;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+extern "C" void EnableSSE();
+
+static inline void cpuid(uint32_t reg, uint32_t *eax, uint32_t *ebx, uint32_t *ecx, uint32_t *edx)
+{
+    asm volatile("cpuid"
+        : "=a" (*eax), "=b" (*ebx), "=c" (*ecx), "=d" (*edx)
+        : "0" (reg));
+}
+
+void CPU::PrintVendor()
+{
+    uint32_t largestStandardFunc;
+    char vendor[13];
+    cpuid(0, &largestStandardFunc, (uint32_t*)(vendor + 0), (uint32_t *)(vendor + 8), (uint32_t *)(vendor + 4));
+    vendor[12] = '\0';
+
+    BootConsole::Write("CPU Vendor: "); BootConsole::WriteLine(vendor);
+}
+
+void CPU::EnableFeatures()
+{
+    uint32_t eax, ebx, ecx, edx;
+
+    cpuid(0x01, &eax, &ebx, &ecx, &edx);
+
+    if (edx & EDX_SSE2) { 
+        BootConsole::WriteLine("CPU Has SSE2");
+
+        EnableSSE();
+    }
+    else
+    {
+        BootConsole::WriteLine("Error: CPU has no SSE2. This is needed");
+
+        while(1);
+    }
+
+    if(edx & EDX_FXSR) {
+        BootConsole::WriteLine("CPU Has FXSR");
+    }
+    else
+    {
+        BootConsole::WriteLine("Error: CPU has no FXSR. This is needed");
+
+        while(1);
+    } 
+}
\ No newline at end of file
diff --git a/kernelz/src/core/cpuhelper.asm b/kernelz/src/core/cpuhelper.asm
new file mode 100644
index 0000000..9891d31
--- /dev/null
+++ b/kernelz/src/core/cpuhelper.asm
@@ -0,0 +1,10 @@
+GLOBAL EnableSSE
+EnableSSE:
+    mov eax, cr0
+    and ax, 0xFFFB		;clear coprocessor emulation CR0.EM
+    or ax, 0x2			;set coprocessor monitoring  CR0.MP
+    mov cr0, eax
+    mov eax, cr4
+    or ax, 3 << 9		;set CR4.OSFXSR and CR4.OSXMMEXCPT at the same time
+    mov cr4, eax
+    ret
\ No newline at end of file
diff --git a/kernelz/src/core/exceptions.cpp b/kernelz/src/core/exceptions.cpp
new file mode 100644
index 0000000..1e91e5c
--- /dev/null
+++ b/kernelz/src/core/exceptions.cpp
@@ -0,0 +1,211 @@
+#include <core/exceptions.h>
+#include <system/system.h>
+#include <common/print.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+// Should we try to automaticaly fix pagefaults?
+bool autoFixPagefaults = false;
+
+uint32_t Exceptions::DivideByZero(uint32_t esp)
+{
+    BootConsole::ForegroundColor = VGA_COLOR_RED;
+    BootConsole::WriteLine("Got Divide by zero Exception");
+
+    InterruptDescriptorTable::DisableInterrupts();
+
+    BootConsole::WriteLine();
+
+    Exceptions::ShowStacktrace(esp);
+    System::Panic();
+    return esp; // We don't get here
+}
+uint32_t Exceptions::GeneralProtectionFault(uint32_t esp)
+{
+    BootConsole::ForegroundColor = VGA_COLOR_RED;
+    BootConsole::WriteLine("Got General Protection Fault Exception");
+
+    CPUState* state = (CPUState*)esp;
+    BootConsole::Write("EIP: 0x");
+    Print::printfHex32(state->EIP);
+    BootConsole::WriteLine();
+
+    if(state->ErrorCode != 0)
+    {
+        SelectorErrorCode* error = (SelectorErrorCode*)&state->ErrorCode;
+        BootConsole::Write("External: "); BootConsole::WriteLine(Convert::IntToString(error->External));
+        BootConsole::Write("Table: "); BootConsole::WriteLine(Convert::IntToString(error->Table));
+        BootConsole::Write("Index: "); BootConsole::WriteLine(Convert::IntToString(error->TableIndex));
+    }
+
+    InterruptDescriptorTable::DisableInterrupts();
+    
+    BootConsole::WriteLine();
+
+    Exceptions::ShowStacktrace(esp);
+    System::Panic();
+    return esp; // We don't get here
+}
+uint32_t Exceptions::PageFault(uint32_t esp)
+{
+    BootConsole::ForegroundColor = VGA_COLOR_BROWN;
+
+    InterruptDescriptorTable::DisableInterrupts();
+
+    uint32_t errorAddress;
+    asm volatile("mov %%cr2, %0" : "=r" (errorAddress));
+
+    CPUState* regs = (CPUState*)esp;
+
+    // The error code gives us details of what happened.
+    int present   = !(regs->ErrorCode & 0x1); // Page not present
+    int rw = regs->ErrorCode & 0x2;           // Write operation?
+    int us = regs->ErrorCode & 0x4;           // Processor was in user-mode?
+    int reserved = regs->ErrorCode & 0x8;     // Overwritten CPU-reserved bits of page entry?
+    int id = regs->ErrorCode & 0x10;          // Caused by an instruction fetch?
+
+    BootConsole::Write("Got Page Fault (");
+
+    if(present)
+        BootConsole::Write("present ");
+    if(rw)
+        BootConsole::Write("read-only ");
+    if(us)
+        BootConsole::Write("user-mode ");
+    if(reserved)
+        BootConsole::Write("reserved ");
+    if(id)
+        BootConsole::Write("instruction fetch ");
+
+    BootConsole::Write(") at 0x");
+    Print::printfHex32(errorAddress);
+    BootConsole::Write(" EIP: 0x");
+    Print::printfHex32(regs->EIP);
+
+    BootConsole::Write(" Memory Intact: ");
+    if(KernelHeap::CheckForErrors())
+        BootConsole::Write(" No ");
+    else
+        BootConsole::Write(" Yes ");
+    
+    if(System::scheduler != 0 && System::scheduler->CurrentProcess() != 0 && System::scheduler->CurrentProcess()->fileName != 0) {
+        BootConsole::Write(" Process: ");
+        BootConsole::WriteLine(System::scheduler->CurrentProcess()->fileName);
+    }
+
+    if(autoFixPagefaults && present) //Identity map error address
+    {
+        void* ptr = (void*)errorAddress;
+        VirtualMemoryManager::mapVirtualToPhysical(ptr, ptr, true, true); //Readonly is probably a good idea        
+        
+        BootConsole::WriteLine(" Fixed pagefault");
+        return esp;
+    }
+    BootConsole::WriteLine();
+
+    Exceptions::ShowStacktrace(esp);
+    System::Panic();
+    return esp; // We don't get here
+}
+
+uint32_t Exceptions::TrapException(uint32_t esp)
+{
+    BootConsole::WriteLine("Got Trap Exception");
+    BootConsole::Write("Next Instruction at: 0x"); Print::printfHex32(((CPUState*)esp)->EIP); BootConsole::WriteLine();
+
+    return esp;
+}
+
+uint32_t Exceptions::FloatingPointException(uint32_t esp)
+{
+    BootConsole::WriteLine("Got SIMD Floating-Point Exception");
+    uint32_t mxcsr;
+    asm volatile ("stmxcsr %0":"=m" (mxcsr));
+    BootConsole::Write("mxcsr: 0b"); Print::printbits(mxcsr); BootConsole::WriteLine();
+    BootConsole::Write("Instruction Pointer: 0x"); Print::printfHex32(((CPUState*)esp)->EIP); BootConsole::WriteLine();
+
+    InterruptDescriptorTable::DisableInterrupts();
+
+    BootConsole::WriteLine();
+
+    Exceptions::ShowStacktrace(esp);
+    System::Panic();
+    return esp; // We don't get here
+}
+uint32_t Exceptions::StackSegmentFault(uint32_t esp)
+{
+    BootConsole::ForegroundColor = VGA_COLOR_RED;
+    BootConsole::WriteLine("Got Stack Segment Fault Exception");
+
+    CPUState* state = (CPUState*)esp;
+    BootConsole::Write("Instruction Pointer: 0x"); Print::printfHex32(((CPUState*)esp)->EIP); BootConsole::WriteLine();
+
+    if(state->ErrorCode != 0)
+    {
+        SelectorErrorCode* error = (SelectorErrorCode*)&state->ErrorCode;
+        BootConsole::Write("External: "); BootConsole::WriteLine(Convert::IntToString(error->External));
+        BootConsole::Write("Table: "); BootConsole::WriteLine(Convert::IntToString(error->Table));
+        BootConsole::Write("Index: "); BootConsole::WriteLine(Convert::IntToString(error->TableIndex));
+    }
+
+    InterruptDescriptorTable::DisableInterrupts();
+    BootConsole::WriteLine();
+
+    Exceptions::ShowStacktrace(esp);
+    System::Panic();
+    return esp; // We don't get here
+}
+
+uint32_t Exceptions::HandleException(uint32_t number, uint32_t esp)
+{
+    switch(number)
+    {
+        case 0:
+            return DivideByZero(esp);
+        case 0xD:
+            return GeneralProtectionFault(esp);
+        case 0xE:
+            return PageFault(esp);
+        case 0x1:
+            return TrapException(esp);
+        case 0xC:
+            return StackSegmentFault(esp);
+        case 0x13:
+            return FloatingPointException(esp);
+        default:
+            {
+                BootConsole::ForegroundColor = VGA_COLOR_RED;
+                BootConsole::Write("Unhandled exception: "); BootConsole::WriteLine(Convert::IntToString(number));
+                BootConsole::WriteLine("Halting System");
+                BootConsole::Write("Instruction Pointer: 0x"); Print::printfHex32(((CPUState*)esp)->EIP); BootConsole::WriteLine();
+                System::Panic();
+            }
+    }
+    return esp;
+}
+
+void Exceptions::EnablePagefaultAutoFix()
+{
+    autoFixPagefaults = true;
+}
+void Exceptions::DisablePagefaultAutoFix()
+{
+    autoFixPagefaults = false;
+}
+
+void Exceptions::ShowStacktrace(common::uint32_t esp)
+{
+    Log(Info, "---------- Stacktrace -----------");
+    if(System::scheduler != 0 && System::scheduler->CurrentProcess() != 0) {
+        Process* curProc = System::scheduler->CurrentProcess();
+        #if ENABLE_ADV_DEBUG
+        if(curProc->symDebugger)
+            curProc->symDebugger->Stacktrace((CPUState*)esp);
+        #else
+        System::kernelDebugger->Stacktrace((CPUState*)esp);
+        #endif
+    }
+}
\ No newline at end of file
diff --git a/kernelz/src/core/fpu.cpp b/kernelz/src/core/fpu.cpp
new file mode 100644
index 0000000..01f3792
--- /dev/null
+++ b/kernelz/src/core/fpu.cpp
@@ -0,0 +1,33 @@
+#include <core/fpu.h>
+#include <common/memoryoperations.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+
+void FPU::Enable()
+{
+	uint32_t cr4;
+	asm volatile ("mov %%cr4, %0" : "=r"(cr4));
+	cr4 |= 0x200;
+	asm volatile ("mov %0, %%cr4" :: "r"(cr4));
+
+	////////////
+	// Set Control Word
+	////////////
+    FPUControlWord cw;
+	MemoryOperations::memset(&cw, 0, sizeof(FPUControlWord));
+
+	cw.InvalidOperand = 1;
+	cw.DenormalOperand = 1;
+	cw.ZeroDevide = 1;
+	cw.Overflow = 1;
+	cw.Underflow = 1;
+	cw.Precision = 1;
+
+	cw.PrecisionControl = 0b11;
+	cw.RoundingControl = 0b00;
+	cw.InfinityControl = 0;
+
+	asm volatile("fldcw %0" :: "m"(cw));
+}
\ No newline at end of file
diff --git a/kernelz/src/core/gdt.cpp b/kernelz/src/core/gdt.cpp
new file mode 100644
index 0000000..d9aee48
--- /dev/null
+++ b/kernelz/src/core/gdt.cpp
@@ -0,0 +1,48 @@
+#include <core/gdt.h>
+
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+
+/*/////////////////
+// Variables
+/*/////////////////
+GDTEntry gdtEntries[6];
+GDTPointer gdtPointer;
+
+extern "C" void gdt_flush(uint32_t);
+
+/*/////////////////
+// Public functions
+/*/////////////////
+void GlobalDescriptorTable::SetDescriptor(int number, uint32_t base, uint32_t limit, uint8_t access, uint8_t gran)
+{
+    gdtEntries[number].base_low    = (base & 0xFFFF);
+    gdtEntries[number].base_middle = (base >> 16) & 0xFF;
+    gdtEntries[number].base_high   = (base >> 24) & 0xFF;
+
+    gdtEntries[number].limit_low   = (limit & 0xFFFF);
+    gdtEntries[number].granularity = (limit >> 16) & 0x0F;
+
+    gdtEntries[number].granularity |= gran & 0xF0;
+    gdtEntries[number].access      = access;
+}
+
+GDTEntry* GlobalDescriptorTable::GetDescriptor(int number)
+{
+    return &gdtEntries[number];
+}
+
+void GlobalDescriptorTable::Init()
+{
+    gdtPointer.limit = (sizeof(GDTEntry) * 6) - 1;
+    gdtPointer.base = (uint32_t)&gdtEntries;
+
+    SetDescriptor(0, 0, 0, 0, 0);                // Null segment
+    SetDescriptor(1, 0, 0xFFFFFFFF, 0x9A, 0xCF); // Code segment
+    SetDescriptor(2, 0, 0xFFFFFFFF, 0x92, 0xCF); // Data segment
+    SetDescriptor(3, 0, 0xFFFFFFFF, 0xFA, 0xCF); // User mode code segment
+    SetDescriptor(4, 0, 0xFFFFFFFF, 0xF2, 0xCF); // User mode data segment
+    // TSS descriptor will be loaded by the TSS class
+
+    gdt_flush((uint32_t)&gdtPointer);
+}
\ No newline at end of file
diff --git a/kernelz/src/core/gdthelper.asm b/kernelz/src/core/gdthelper.asm
new file mode 100644
index 0000000..8856221
--- /dev/null
+++ b/kernelz/src/core/gdthelper.asm
@@ -0,0 +1,15 @@
+[GLOBAL gdt_flush]    ; Allows the C code to call gdt_flush().
+
+gdt_flush:
+   mov eax, [esp+4]  ; Get the pointer to the GDT, passed as a parameter.
+   lgdt [eax]        ; Load the new GDT pointer
+
+   mov ax, 0x10      ; 0x10 is the offset in the GDT to our data segment
+   mov ds, ax        ; Load all data segment selectors
+   mov es, ax
+   mov fs, ax
+   mov gs, ax
+   mov ss, ax
+   jmp 0x08:.flush   ; 0x08 is the offset to our code segment: Far jump!
+.flush:
+   ret
\ No newline at end of file
diff --git a/kernelz/src/core/idt.cpp b/kernelz/src/core/idt.cpp
new file mode 100644
index 0000000..f8cb572
--- /dev/null
+++ b/kernelz/src/core/idt.cpp
@@ -0,0 +1,144 @@
+#include <core/idt.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+/*/////////////////
+// Variables
+/*/////////////////
+IDTEntry idtEntries[IDT_ENTRY_SIZE];
+IDTPointer idtPointer;
+
+
+void InterruptDescriptorTable::SetDescriptor(uint32_t number, void (*handler)(), int accesLevel)
+{
+    uint32_t callerBase = (uint32_t)handler;
+
+    idtEntries[number].handlerLowBits = (uint16_t)(callerBase & 0xFFFF);
+    idtEntries[number].handlerHighBits = (uint16_t)((callerBase >> 16) & 0xFFFF);
+    idtEntries[number].reserved = 0;
+    idtEntries[number].access = IDT_PRESENT | ((accesLevel & 3) << 5) | IDT_INTERRUPT;
+    idtEntries[number].selector = 0x8;
+}
+
+void InterruptDescriptorTable::Install()
+{
+    idtPointer.size = sizeof(IDTEntry) * IDT_ENTRY_SIZE - 1;
+    idtPointer.base = (uint32_t)&idtEntries[0];
+
+    MemoryOperations::memset((void*)&idtEntries[0], 0, sizeof(IDTEntry) * IDT_ENTRY_SIZE - 1);
+
+    for(int i = 0; i < IDT_ENTRY_SIZE; i++)
+        SetDescriptor(i, IgnoreInterrupt);
+
+    SetDescriptor(0x00, HandleException0x00);
+    SetDescriptor(0x01, HandleException0x01);
+    SetDescriptor(0x02, HandleException0x02);
+    SetDescriptor(0x03, HandleException0x03);
+    SetDescriptor(0x04, HandleException0x04);
+    SetDescriptor(0x05, HandleException0x05);
+    SetDescriptor(0x06, HandleException0x06);
+    SetDescriptor(0x07, HandleException0x07);
+    SetDescriptor(0x08, HandleException0x08);
+    SetDescriptor(0x09, HandleException0x09);
+    SetDescriptor(0x0A, HandleException0x0A);
+    SetDescriptor(0x0B, HandleException0x0B);
+    SetDescriptor(0x0C, HandleException0x0C);
+    SetDescriptor(0x0D, HandleException0x0D);
+    SetDescriptor(0x0E, HandleException0x0E);
+    SetDescriptor(0x0F, HandleException0x0F);
+    SetDescriptor(0x10, HandleException0x10);
+    SetDescriptor(0x11, HandleException0x11);
+    SetDescriptor(0x12, HandleException0x12);
+    SetDescriptor(0x13, HandleException0x13);
+
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x00, HandleInterruptRequest0x00);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x01, HandleInterruptRequest0x01);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x02, HandleInterruptRequest0x02);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x03, HandleInterruptRequest0x03);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x04, HandleInterruptRequest0x04);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x05, HandleInterruptRequest0x05);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x06, HandleInterruptRequest0x06);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x07, HandleInterruptRequest0x07);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x08, HandleInterruptRequest0x08);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x09, HandleInterruptRequest0x09);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x0A, HandleInterruptRequest0x0A);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x0B, HandleInterruptRequest0x0B);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x0C, HandleInterruptRequest0x0C);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x0D, HandleInterruptRequest0x0D);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x0E, HandleInterruptRequest0x0E);
+    SetDescriptor(IDT_INTERRUPT_OFFSET + 0x0F, HandleInterruptRequest0x0F);
+
+    SetDescriptor((IDT_INTERRUPT_OFFSET + 0xDD), HandleInterruptRequest0xDD);
+    SetDescriptor(0x80, HandleInterruptRequest0x60, 3);
+
+    // Remap the PIC
+    outportb(0x20, 0x11);
+    outportb(0xA0, 0x11);
+
+    // remap
+    outportb(0x21, IDT_INTERRUPT_OFFSET);
+    outportb(0xA1, IDT_INTERRUPT_OFFSET+8);
+
+    outportb(0x21, 0x04);
+    outportb(0xA1, 0x02);
+
+    outportb(0x21, 0x01);
+    outportb(0xA1, 0x01);
+
+    outportb(0x21, 0x00);
+    outportb(0xA1, 0x00);
+
+    asm volatile("lidt %0" : : "m" (idtPointer));
+}
+        
+
+//Gets called for every interrupt from assembly code
+uint32_t InterruptDescriptorTable::HandleInterrupt(CPUState* state)
+{
+    uint8_t interrupt = state->InterruptNumber;
+    if(interrupt == 0xD && (state->EFLAGS & (1 << 17)))
+    {
+        //BootConsole::WriteLine("[IDT] VM86 Interrupt");
+        //VM86 Interrupt
+        state = (CPUState*)InterruptManager::HandleInterrupt(interrupt, (uint32_t)state);
+    }
+    else if(interrupt < IDT_INTERRUPT_OFFSET)
+    {
+        state = (CPUState*)Exceptions::HandleException(interrupt, (uint32_t)state);
+    }
+    else
+    {
+        //BootConsole::Write("Interrupt Handler for int: "); BootConsole::WriteLine(Convert::IntToString(interrupt));
+        state = (CPUState*)InterruptManager::HandleInterrupt(interrupt, (uint32_t)state);
+    }
+
+    // hardware interrupts must be acknowledged
+    if(IDT_INTERRUPT_OFFSET <= interrupt && interrupt < IDT_INTERRUPT_OFFSET+16)
+    {
+        outportb(0x20, 0x20);
+        if(IDT_INTERRUPT_OFFSET + 8 <= interrupt)
+            outportb(0xA0, 0x20);
+    }
+
+    return (uint32_t)state;
+}
+
+void InterruptDescriptorTable::EnableInterrupts()
+{
+    asm volatile ("sti");
+}
+void InterruptDescriptorTable::DisableInterrupts()
+{
+    asm volatile ("cli");
+}
+bool InterruptDescriptorTable::AreEnabled()
+{
+    unsigned long flags;
+    asm volatile ( "pushf\n\t"
+                   "pop %0"
+                   : "=g"(flags) );
+    return flags & (1 << 9);
+}
\ No newline at end of file
diff --git a/kernelz/src/core/idthelper.s b/kernelz/src/core/idthelper.s
new file mode 100644
index 0000000..ca49df6
--- /dev/null
+++ b/kernelz/src/core/idthelper.s
@@ -0,0 +1,104 @@
+.macro HandleExceptionWithError num
+.global HandleException\num\()
+HandleException\num\():
+    pushl $\num
+    jmp interrupthandler
+.endm
+
+.macro HandleExceptionNoError num
+.global HandleException\num\()
+HandleException\num\():
+    pushl $0 # Add empty error code
+    pushl $\num
+    jmp interrupthandler
+.endm
+
+
+.macro HandleInterruptRequest num
+.global HandleInterruptRequest\num\()
+HandleInterruptRequest\num\():
+    pushl $0
+    pushl $\num + 0x20
+    jmp interrupthandler
+.endm
+
+HandleExceptionNoError 0x00
+HandleExceptionNoError 0x01
+HandleExceptionNoError 0x02
+HandleExceptionNoError 0x03
+HandleExceptionNoError 0x04
+HandleExceptionNoError 0x05
+HandleExceptionNoError 0x06
+HandleExceptionNoError 0x07
+HandleExceptionWithError 0x08
+HandleExceptionNoError 0x09
+HandleExceptionWithError 0x0A
+HandleExceptionWithError 0x0B
+HandleExceptionWithError 0x0C
+HandleExceptionWithError 0x0D
+HandleExceptionWithError 0x0E
+HandleExceptionNoError 0x0F
+HandleExceptionNoError 0x10
+HandleExceptionNoError 0x11
+HandleExceptionNoError 0x12
+HandleExceptionNoError 0x13
+
+HandleInterruptRequest 0x00
+HandleInterruptRequest 0x01
+HandleInterruptRequest 0x02
+HandleInterruptRequest 0x03
+HandleInterruptRequest 0x04
+HandleInterruptRequest 0x05
+HandleInterruptRequest 0x06
+HandleInterruptRequest 0x07
+HandleInterruptRequest 0x08
+HandleInterruptRequest 0x09
+HandleInterruptRequest 0x0A
+HandleInterruptRequest 0x0B
+HandleInterruptRequest 0x0C
+HandleInterruptRequest 0x0D
+HandleInterruptRequest 0x0E
+HandleInterruptRequest 0x0F
+HandleInterruptRequest 0x31
+
+HandleInterruptRequest 0xDD
+HandleInterruptRequest 0x60
+
+interrupthandler:    
+	cli # Stop Interrupts
+	
+    # Save Registers
+    pusha
+	pushl %ds
+	pushl %es
+	pushl %fs
+	pushl %gs
+
+    # load the kernel data segment descriptor
+	mov $0x10, %ax
+	mov %ax, %ds
+	mov %ax, %es
+	mov %ax, %fs
+	mov %ax, %gs
+
+	pushl %esp
+	# Call the kernel IRQ handler
+	call _ZN8CactusOS4core24InterruptDescriptorTable15HandleInterruptEPNS0_8CPUStateE
+	mov %eax, %esp
+
+    # Restore Registers
+	popl %gs
+	popl %fs
+	popl %es
+	popl %ds
+	popa
+
+    # Clean up
+	add $8, %esp
+
+	sti # Restart Interrupts
+    iret
+
+.global IgnoreInterrupt
+IgnoreInterrupt:
+    iret
\ No newline at end of file
diff --git a/kernelz/src/core/physicalmemory.cpp b/kernelz/src/core/physicalmemory.cpp
new file mode 100644
index 0000000..0a26b0a
--- /dev/null
+++ b/kernelz/src/core/physicalmemory.cpp
@@ -0,0 +1,226 @@
+#include <core/physicalmemory.h>
+#include <common/print.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+uint32_t PhysicalMemoryManager::memorySize = 0;
+uint32_t PhysicalMemoryManager::usedBlocks = 0;
+uint32_t PhysicalMemoryManager::maximumBlocks = 0;
+uint32_t *PhysicalMemoryManager::memoryArray = 0;
+
+uint32_t PhysicalMemoryManager::FirstFree()
+{
+    for (uint32_t i = 0; i < TotalBlocks(); i++)
+        if (memoryArray[i] != 0xffffffff)
+            for (int j = 0; j < 32; j++)
+            { //! test each bit in the dword
+
+                int bit = 1 << j;
+                if (!(memoryArray[i] & bit))
+                    return i * 4 * 8 + j;
+            }
+
+    return -1;
+}
+uint32_t PhysicalMemoryManager::FirstFreeSize(uint32_t size)
+{
+    if (size == 0)
+        return -1;
+
+    if (size == 1)
+        return FirstFree();
+
+    for (uint32_t i = 0; i < TotalBlocks(); i++)
+        if (memoryArray[i] != 0xffffffff)
+            for (int j = 0; j < 32; j++)
+            { //! test each bit in the dword
+
+                int bit = 1 << j;
+                if (!(memoryArray[i] & bit))
+                {
+
+                    uint32_t startingBit = i * 32;
+                    startingBit += j; //get the free bit in the dword at index i
+
+                    uint32_t free = 0; //loop through each bit to see if its enough space
+                    for (uint32_t count = 0; count <= size; count++)
+                    {
+
+                        if (!TestBit(startingBit + count))
+                            free++; // this bit is clear (free frame)
+
+                        if (free == size)
+                            return i * 4 * 8 + j; //free count==size needed; return index
+                    }
+                }
+            }
+
+    return -1;
+}
+
+void PhysicalMemoryManager::Initialize(uint32_t size, uint32_t bitmap)
+{
+    BootConsole::Write("Memory Size: ");
+    BootConsole::Write(Convert::IntToString(size / 1_MB));
+    BootConsole::WriteLine(" Mb");
+    BootConsole::Write("Bitmap: 0x"); Print::printfHex32(bitmap); BootConsole::WriteLine();
+
+    memorySize = size;
+    memoryArray = (uint32_t *)bitmap;
+    maximumBlocks = size / BLOCK_SIZE;
+    usedBlocks = maximumBlocks; //We use all at startup
+
+    MemoryOperations::memset(memoryArray, 0xFF, usedBlocks / BLOCKS_PER_BYTE);
+
+    BootConsole::Write("Bitmap size: ");
+    BootConsole::Write(Convert::IntToString(GetBitmapSize() / 1_KB));
+    BootConsole::WriteLine(" Kb");
+    BootConsole::Write("Bitmap End: 0x"); Print::printfHex32(bitmap + GetBitmapSize()); BootConsole::WriteLine();
+}
+void PhysicalMemoryManager::SetRegionFree(uint32_t base, uint32_t size)
+{
+    uint32_t align = base / BLOCK_SIZE;
+
+    for (uint32_t blocks = size / BLOCK_SIZE; blocks > 0; blocks--)
+    {
+        UnsetBit(align++);
+        usedBlocks--;
+    }
+
+    SetBit(0);
+}
+void PhysicalMemoryManager::SetRegionUsed(uint32_t base, uint32_t size)
+{
+    uint32_t align = base / BLOCK_SIZE;
+
+    for (uint32_t blocks = size / BLOCK_SIZE; blocks > 0; blocks--)
+    {
+        SetBit(align++);
+        usedBlocks++;
+    }
+
+    SetBit(0);
+}
+void PhysicalMemoryManager::ParseMemoryMap(const multiboot_info_t* mbi)
+{
+    BootConsole::WriteLine("Parsing grub memory map");
+    BootConsole::Write("Address of mmap: 0x"); Print::printfHex32(phys2virt(mbi->mmap_addr)); BootConsole::WriteLine();
+
+    grub_multiboot_memory_map_t *mmap = (grub_multiboot_memory_map_t *)phys2virt(mbi->mmap_addr);
+    BootConsole::WriteLine("-------------------------------------------------");
+    while ((uint32_t)mmap < phys2virt(mbi->mmap_addr) + mbi->mmap_length)
+    {
+        BootConsole::Write("|->   0x"); Print::printfHex32(mmap->base_addr_low); BootConsole::Write("   ");
+        BootConsole::Write(Convert::IntToString(mmap->length_low / 1_KB)); BootConsole::Write(" Kb      ");
+        BootConsole::SetX(35);
+        BootConsole::Write("Type: "); BootConsole::Write(Convert::IntToString(mmap->type));
+
+        if (mmap->type == MULTIBOOT_MEMORY_AVAILABLE)
+        {
+            BootConsole::Write(" [Free]");
+            SetRegionFree(mmap->base_addr_low, mmap->length_low);
+        }
+        BootConsole::WriteLine();
+
+        mmap = (grub_multiboot_memory_map_t*)((uint32_t)mmap + mmap->size + sizeof(uint32_t));
+    }
+    BootConsole::WriteLine("-------------------------------------------------");
+}
+
+void* PhysicalMemoryManager::AllocateBlock()
+{
+    if (FreeBlocks() <= 0)
+        return 0;
+
+    uint32_t frame = FirstFree();
+
+    if (frame == (uint32_t)-1)
+        return 0;
+
+    SetBit(frame);
+
+    uint32_t addr = frame * BLOCK_SIZE;
+    usedBlocks++;
+
+    return (void *)addr;
+}
+void PhysicalMemoryManager::FreeBlock(void* ptr)
+{
+    uint32_t addr = (uint32_t)ptr;
+    uint32_t frame = addr / BLOCK_SIZE;
+
+    UnsetBit(frame);
+
+    usedBlocks--;
+}
+void* PhysicalMemoryManager::AllocateBlocks(uint32_t size)
+{
+    if (FreeBlocks() <= size)
+        return 0; //not enough space
+
+    uint32_t frame = FirstFreeSize(size);
+
+    if (frame == (uint32_t)-1)
+        return 0; //not enough space
+
+    for (uint32_t i = 0; i < size; i++)
+        SetBit(frame + i);
+
+    uint32_t addr = frame * BLOCK_SIZE;
+    usedBlocks += size;
+
+    return (void *)addr;
+}
+void PhysicalMemoryManager::FreeBlocks(void *ptr, uint32_t size)
+{
+    uint32_t addr = (uint32_t)ptr;
+    uint32_t frame = addr / BLOCK_SIZE;
+
+    for (uint32_t i = 0; i < size; i++)
+        UnsetBit(frame + i);
+
+    usedBlocks -= size;
+}
+
+uint32_t PhysicalMemoryManager::AmountOfMemory()
+{
+    return memorySize;
+}
+uint32_t PhysicalMemoryManager::UsedBlocks()
+{
+    return usedBlocks;
+}
+uint32_t PhysicalMemoryManager::FreeBlocks()
+{
+    return maximumBlocks - usedBlocks;
+}
+uint32_t PhysicalMemoryManager::TotalBlocks()
+{
+    return maximumBlocks;
+}
+uint32_t PhysicalMemoryManager::GetBitmapSize()
+{
+    return memorySize / BLOCK_SIZE / BLOCKS_PER_BYTE;
+}
+
+
+/*//////////////
+// Helper functions
+*///////////////
+uint32_t core::pageRoundUp(uint32_t address)
+{
+    if((address & 0xFFFFF000) != address)
+    {
+        address &= 0xFFFFF000;
+        address += 0x1000;
+    }
+    return address;
+}
+
+uint32_t core::pageRoundDown(uint32_t address)
+{
+    return address & 0xFFFFF000;
+}
\ No newline at end of file
diff --git a/kernelz/src/core/power.cpp b/kernelz/src/core/power.cpp
new file mode 100644
index 0000000..32b0375
--- /dev/null
+++ b/kernelz/src/core/power.cpp
@@ -0,0 +1,342 @@
+#include <core/power.h>
+#include <core/idt.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+////////////
+// Shutdown code from: https://forum.osdev.org/viewtopic.php?t=16990
+////////////
+
+uint32_t* SMI_CMD;
+uint8_t ACPI_ENABLE;
+uint8_t ACPI_DISABLE;
+uint32_t* PM1a_CNT;
+uint32_t* PM1b_CNT;
+uint16_t SLP_TYPa;
+uint16_t SLP_TYPb;
+uint16_t SLP_EN;
+uint16_t SCI_EN;
+uint8_t PM1_CNT_LEN;
+
+struct RSDPtr
+{
+    uint8_t Signature[8];
+    uint8_t CheckSum;
+    uint8_t OemID[6];
+    uint8_t Revision;
+    uint32_t* RsdtAddress;
+};
+
+struct FACP
+{
+    uint8_t Signature[4];
+    uint32_t Length;
+    uint8_t unneded1[40 - 8];
+    uint32_t* DSDT;
+    uint8_t unneded2[48 - 44];
+    uint32_t* SMI_CMD;
+    uint8_t ACPI_ENABLE;
+    uint8_t ACPI_DISABLE;
+    uint8_t unneded3[64 - 54];
+    uint32_t* PM1a_CNT_BLK;
+    uint32_t* PM1b_CNT_BLK;
+    uint8_t unneded4[89 - 72];
+    uint8_t PM1_CNT_LEN;
+};
+
+// check if the given address has a valid header
+unsigned int* acpiCheckRSDPtr(unsigned int* ptr)
+{
+    char* sig = "RSD PTR ";
+    struct RSDPtr* rsdp = (struct RSDPtr*)ptr;
+    uint8_t* bptr;
+    uint8_t check = 0;
+    int i;
+
+    if(MemoryOperations::memcmp(sig, rsdp, 8) == 0)
+    {
+        // check checksum rsdpd
+        bptr = (uint8_t*)ptr;
+        for (i = 0; i < (int)sizeof(struct RSDPtr); i++)
+        {
+            check += *bptr;
+            bptr++;
+        }
+
+        // found valid rsdpd   
+        if (check == 0) {
+            if (rsdp->Revision == 0)
+                Log(Info, "ACPI Version 1");
+            else
+                Log(Info, "ACPI Version 2");
+            
+            return (unsigned int*)rsdp->RsdtAddress;
+        }
+    }
+
+    return 0;
+}
+
+
+
+// finds the acpi header and returns the address of the rsdt
+unsigned int* acpiGetRSDPtr(void)
+{
+    unsigned int* addr;
+    unsigned int* rsdp;
+
+    // search below the 1mb mark for RSDP signature
+    for(addr = (unsigned int*)0x000E0000; (int)addr < 0x00100000; addr += 0x10/sizeof(addr))
+    {
+        rsdp = acpiCheckRSDPtr(addr);
+        if (rsdp != 0)
+            return rsdp;
+    }
+
+    // at address 0x40:0x0E is the RM segment of the ebda
+    int ebda = *((short*)0x40E);   // get pointer
+    ebda = ebda*0x10 & 0x000FFFFF;   // transform segment into linear address
+
+    // search Extended BIOS Data Area for the Root System Description Pointer signature
+    for(addr = (unsigned int*)ebda; (int)addr < ebda + 1024; addr += 0x10/sizeof(addr))
+    {
+        rsdp = acpiCheckRSDPtr(addr);
+        if (rsdp != 0)
+            return rsdp;
+    }
+
+    return 0;
+}
+
+
+
+// checks for a given header and validates checksum
+int acpiCheckHeader(unsigned int* ptr, char* sig)
+{
+    if(MemoryOperations::memcmp(ptr, sig, 4) == 0)
+    {
+        char* checkPtr = (char*)ptr;
+        int len = *(ptr + 1);
+        char check = 0;
+        while (0 < len--)
+        {
+            check += *checkPtr;
+            checkPtr++;
+        }
+        if (check == 0)
+            return 0;
+    }
+    return -1;
+}
+
+int acpiEnable(void)
+{
+    // check if acpi is enabled
+    if ((inportw((unsigned int) PM1a_CNT) & SCI_EN) == 0 )
+    {
+        // check if acpi can be enabled
+        if (SMI_CMD != 0 && ACPI_ENABLE != 0)
+        {
+            outportb((unsigned int)SMI_CMD, ACPI_ENABLE); // send acpi enable command
+            // give 3 seconds time to enable acpi
+            int i;
+            for (i = 0; i < 300; i++)
+            {
+                if ((inportw((unsigned int)PM1a_CNT) & SCI_EN) == 1)
+                    break;
+                
+                System::pit->Sleep(10);
+            }
+            if (PM1b_CNT != 0)
+                for (; i < 300; i++ )
+                {
+                    if ((inportw((unsigned int) PM1b_CNT) & SCI_EN) == 1)
+                        break;
+                    
+                    System::pit->Sleep(10);
+                }
+            if (i < 300) {
+                Log(Info, "Enabled ACPI");
+                return 0;
+            } else {
+                Log(Info, "Couldn't Enable ACPI");
+                return -1;
+            }
+        } else {
+            Log(Info, "No known way to Enable ACPI");
+            return -1;
+        }
+    } else {
+        Log(Info, "ACPI was already enabled");
+        return 0;
+    }
+}
+
+
+
+//
+// bytecode of the \_S5 object
+// -----------------------------------------
+//        | (optional) |    |    |    |   
+// NameOP | \          | _  | S  | 5  | _
+// 08     | 5A         | 5F | 53 | 35 | 5F
+//
+// -----------------------------------------------------------------------------------------------------------
+//           |           |              | ( SLP_TYPa   ) | ( SLP_TYPb   ) | ( Reserved   ) | (Reserved    )
+// PackageOP | PkgLength | NumElements  | byteprefix Num | byteprefix Num | byteprefix Num | byteprefix Num
+// 12        | 0A        | 04           | 0A         05  | 0A          05 | 0A         05  | 0A         05
+//
+//----this-structure-was-also-seen----------------------
+// PackageOP | PkgLength | NumElements |
+// 12        | 06        | 04          | 00 00 00 00
+//
+// (Pkglength bit 6-7 encode additional PkgLength bytes [shouldn't be the case here])
+//
+int initAcpi(void)
+{
+    unsigned int* ptr = acpiGetRSDPtr();
+
+    // check if address is correct  ( if acpi is available on this pc )
+    if (ptr != 0 && acpiCheckHeader(ptr, "RSDT") == 0)
+    {
+        // the RSDT contains an unknown number of pointers to acpi tables
+        int entrys = *(ptr + 1);
+        entrys = (entrys-36) / 4;
+        ptr += 36/4;   // skip header information
+
+        while (0<entrys--)
+        {
+            // check if the desired table is reached
+            if (acpiCheckHeader((unsigned int*)*ptr, "FACP") == 0)
+            {
+                entrys = -2;
+                struct FACP* facp = (struct FACP*)*ptr;
+                
+                if (acpiCheckHeader((unsigned int*)facp->DSDT, "DSDT") == 0)
+                {
+                    // search the \_S5 package in the DSDT
+                    char *S5Addr = (char*)facp->DSDT + 36; // skip header
+                    int dsdtLength = *(facp->DSDT+1) - 36;
+                    while (0 < dsdtLength--)
+                    {
+                        if (MemoryOperations::memcmp(S5Addr, "_S5_", 4) == 0)
+                            break;
+                        S5Addr++;
+                    }
+                    // check if \_S5 was found
+                    if (dsdtLength > 0)
+                    {
+                        // check for valid AML structure
+                        if ((*(S5Addr-1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr-1) == '\\') ) && *(S5Addr+4) == 0x12 )
+                        {
+                            S5Addr += 5;
+                            S5Addr += ((*S5Addr &0xC0) >> 6) + 2;   // calculate PkgLength size
+
+                            if (*S5Addr == 0x0A)
+                                S5Addr++;   // skip byteprefix
+                            SLP_TYPa = *(S5Addr) << 10;
+                            S5Addr++;
+
+                            if (*S5Addr == 0x0A)
+                                S5Addr++;   // skip byteprefix
+                            SLP_TYPb = *(S5Addr) << 10;
+
+                            SMI_CMD = facp->SMI_CMD;
+
+                            ACPI_ENABLE = facp->ACPI_ENABLE;
+                            ACPI_DISABLE = facp->ACPI_DISABLE;
+
+                            PM1a_CNT = facp->PM1a_CNT_BLK;
+                            PM1b_CNT = facp->PM1b_CNT_BLK;
+                            
+                            PM1_CNT_LEN = facp->PM1_CNT_LEN;
+
+                            SLP_EN = 1 << 13;
+                            SCI_EN = 1;
+
+                            return 0;
+                        } else {
+                            Log(Info, "\\_S5 parse error");
+                        }
+                    } else {
+                        Log(Info, "\\_S5 not present");
+                    }
+                } else {
+                    Log(Info, "DSDT invalid");
+                }
+            }
+            ptr++;
+        }
+        Log(Info, "no valid FACP present");
+    } else {
+        Log(Info, "no ACPI");
+    }
+
+    return -1;
+}
+
+void Power::Initialize()
+{
+    //TODO: Find a better way to access physical ACPI memory
+    Exceptions::EnablePagefaultAutoFix();
+    initAcpi();
+    Exceptions::DisablePagefaultAutoFix();
+}
+
+void Power::Poweroff()
+{
+    if(System::apm->Enabled) {
+        Log(Info, "Shutdown via APM");
+        System::apm->SetPowerState(APM_ALL_DEVICE, APM_POWER_OFF);
+    }
+    
+    // Else try ACPI
+
+    // SCI_EN is set to 1 if acpi shutdown is possible
+    if (SCI_EN == 0)
+    {
+        Log(Error, "ACPI poweroff not possible");
+        return;
+    }
+
+    acpiEnable();
+
+    Log(Info, "Sending Shutdown to ACPI");
+
+    // send the shutdown command
+    outportw((unsigned int)PM1a_CNT, SLP_TYPa | SLP_EN );
+    if (PM1b_CNT != 0)
+        outportw((unsigned int)PM1b_CNT, SLP_TYPb | SLP_EN );
+
+    Log(Error, "ACPI poweroff failed, rebooting instead");
+    for(int i = 5; i >= 0; i--)
+    {
+        Log(Info, "%d", i);
+        System::pit->Sleep(1000);
+    }
+    Power::Reboot();
+}
+
+void Power::Reboot()
+{
+    InterruptDescriptorTable::DisableInterrupts();
+
+    /* flush the keyboard controller */
+    unsigned temp;
+    do
+    {
+        temp = inportb(0x64);
+        if((temp & 0x01) != 0)
+        {
+            inportb(0x60);
+            continue;
+        }
+    } while((temp & 0x02) != 0);
+
+    /* Reset! */
+    outportb(0x64, 0xFE);
+}
\ No newline at end of file
diff --git a/kernelz/src/core/tss.cpp b/kernelz/src/core/tss.cpp
new file mode 100644
index 0000000..266cdc0
--- /dev/null
+++ b/kernelz/src/core/tss.cpp
@@ -0,0 +1,42 @@
+#include <core/tss.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+
+static TSSEntry tss;
+
+extern "C" void flush_tss();
+
+void TSS::Install(uint32_t idx, uint32_t kernelSS, uint32_t kernelESP)
+{
+	MemoryOperations::memset(&tss, 0, sizeof(TSSEntry));
+
+    //! install TSS descriptor
+	uint32_t base = (uint32_t) &tss;
+
+	//! install descriptor
+	GlobalDescriptorTable::SetDescriptor (idx, base, base + sizeof (TSSEntry), 0xE9, 0);
+
+	//! initialize TSS
+    MemoryOperations::memset ((void*) &tss, 0, sizeof (TSSEntry));
+
+	//! set stack and segments
+	tss.ss0 = kernelSS;
+	tss.esp0 = kernelESP;
+	tss.iomap = sizeof(TSSEntry);
+
+	//! flush tss
+	flush_tss();
+}
+
+void TSS::SetStack(uint32_t kernelSS, uint32_t kernelESP)
+{
+    tss.ss0 = kernelSS;
+    tss.esp0 = kernelESP;
+}
+
+TSSEntry* TSS::GetCurrent()
+{
+	return &tss;
+}
\ No newline at end of file
diff --git a/kernelz/src/core/tsshelper.asm b/kernelz/src/core/tsshelper.asm
new file mode 100644
index 0000000..0a9a71b
--- /dev/null
+++ b/kernelz/src/core/tsshelper.asm
@@ -0,0 +1,5 @@
+global flush_tss
+flush_tss:
+    mov ax, 0x28
+    ltr ax
+    ret
\ No newline at end of file
diff --git a/kernelz/src/core/virtualmemory.cpp b/kernelz/src/core/virtualmemory.cpp
new file mode 100644
index 0000000..94013ed
--- /dev/null
+++ b/kernelz/src/core/virtualmemory.cpp
@@ -0,0 +1,209 @@
+#include <core/virtualmemory.h>
+#include <system/log.h>
+#include <system/debugger.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+void VirtualMemoryManager::ReloadCR3()
+{
+    asm volatile("movl	%cr3,%eax");
+	asm volatile("movl	%eax,%cr3");
+}
+
+
+void VirtualMemoryManager::Initialize()
+{
+    BootConsole::WriteLine("Intializing Paging");
+    
+    // Re-use the page directory setup by the loader
+    PageDirectory* pageDirectory = (PageDirectory*)&BootPageDirectory;
+
+    // Set the last pde to the page directory itself
+    // With this we can use recursive page tables
+    PageDirectoryEntry lastPDE;
+    MemoryOperations::memset(&lastPDE, 0, sizeof(PageDirectoryEntry));
+    lastPDE.frame = virt2phys((uint32_t)&BootPageDirectory) / PAGE_SIZE;
+    lastPDE.readWrite = 1;
+    lastPDE.pageSize = FOUR_KB;
+    lastPDE.present = 1;
+    pageDirectory->entries[1023] = lastPDE;
+
+    /*
+        What we do here is create a new pagetable for the kernel, currently is mapped by a 4mb page by the bootloader
+        But because we can (at least should) not access the physical allocated block directly, we need to add
+        it to the page directory first. But when we do that the physical page table is empty or contains junk, here is where the problem occurs.
+        Because of the junk qemu sometimes crashes and this could be possible on real hardware as well.
+        So for now just use the 4mb page for the kernel setup by the loader until we find a solution to this.
+    */
+#if 0
+    //One pagetable for the kernel
+    void* kernelPageTablePhysAddress = PhysicalMemoryManager::AllocateBlock();
+    PageDirectoryEntry kernelPDE;
+    MemoryOperations::memset(&kernelPDE, 0, sizeof(PageDirectoryEntry));
+    kernelPDE.frame = (uint32_t)kernelPageTablePhysAddress  / PAGE_SIZE;
+    kernelPDE.readWrite = 1;
+    kernelPDE.pageSize = FOUR_KB;
+    kernelPDE.present = 1;
+    pageDirectory->entries[KERNEL_PTNUM] = kernelPDE;
+
+    //Fill in the page table
+    PageTable* kernelPageTable = (PageTable*)GetPageTableAddress(KERNEL_PTNUM);
+    for(uint16_t i = 0; i < 1024; i++)
+    {
+        kernelPageTable->entries[i].frame = i;
+        kernelPageTable->entries[i].isUser = 0;
+        kernelPageTable->entries[i].readWrite = 1;
+        kernelPageTable->entries[i].present = 1;
+    }
+#endif
+    // Here we map some pages for the initial kernel heap
+    for(uint32_t i = KERNEL_HEAP_START; i < KERNEL_HEAP_START + KERNEL_HEAP_SIZE; i += PAGE_SIZE)
+        AllocatePage(GetPageForAddress(i, true), true, true);
+        
+    // The first 4mb are identity mapped, this is needed for the smbios and the vm86 code
+    MemoryOperations::memset(&pageDirectory->entries[0], 0, sizeof(PageDirectoryEntry));
+    pageDirectory->entries[0].frame     = (uint32_t)PhysicalMemoryManager::AllocateBlock() / PAGE_SIZE;
+    pageDirectory->entries[0].pageSize  = FOUR_KB;
+    pageDirectory->entries[0].present   = 1;
+    pageDirectory->entries[0].readWrite = 1;
+    pageDirectory->entries[0].isUser    = 1;
+
+    // Create required entries for the first 4 MB of memory
+    PageTable* fourMB_PT = (PageTable*)GetPageTableAddress(0);
+    MemoryOperations::memset(fourMB_PT, 0, sizeof(PageTable));
+
+    // Make whole first block kernel accessable (except for the first 4096 bytes)
+    // This way we can catch null-pointers
+    for(uint16_t i = 1; i < 1024; i++)
+    {
+        fourMB_PT->entries[i].frame     = i;    // Identity map memory
+        fourMB_PT->entries[i].isUser    = 0;    // Only for kernel
+        fourMB_PT->entries[i].readWrite = 1;    // We should be able to write to it (for VESA and stuff)
+        fourMB_PT->entries[i].present   = 1;    // Makes sense I hope
+    }
+
+    // Create entries required for VM86
+    for(uint32_t i = PAGE_SIZE; i < pageRoundUp(1_MB); i += PAGE_SIZE) {
+        uint16_t index = PAGETBL_INDEX(i);
+        fourMB_PT->entries[index].isUser = 1;
+    }
+
+    // Create entry 0 as well, just don't mark it as present (yet)
+    fourMB_PT->entries[0].frame     = 0;
+    fourMB_PT->entries[0].isUser    = 1;
+    fourMB_PT->entries[0].readWrite = 1;
+    fourMB_PT->entries[0].present   = 0; // Very Important!
+
+    // Finally reload the cr3 register
+    ReloadCR3();
+}
+
+PageTableEntry* VirtualMemoryManager::GetPageForAddress(uint32_t virtualAddress, bool shouldCreate, bool readWrite, bool userPages)
+{
+    uint32_t pageDirIndex = PAGEDIR_INDEX(virtualAddress);
+    uint32_t pageTableIndex = PAGETBL_INDEX(virtualAddress);
+
+    PageDirectory* pageDir = (PageDirectory*)PAGE_DIRECTORY_ADDRESS;
+    if(pageDir->entries[pageDirIndex].present == 0 && shouldCreate)
+    {
+        void* pageTablePhys = PhysicalMemoryManager::AllocateBlock();
+        
+        MemoryOperations::memset(&pageDir->entries[pageDirIndex], 0, sizeof(PageDirectoryEntry));
+        pageDir->entries[pageDirIndex].frame = (uint32_t)pageTablePhys / PAGE_SIZE;
+        pageDir->entries[pageDirIndex].readWrite = readWrite;
+        pageDir->entries[pageDirIndex].isUser = userPages;
+        pageDir->entries[pageDirIndex].pageSize = FOUR_KB;
+        pageDir->entries[pageDirIndex].present = 1;
+
+        PageTable* pageTableVirt = (PageTable*)GetPageTableAddress(pageDirIndex);
+        MemoryOperations::memset(pageTableVirt, 0, sizeof(PageTable));
+
+        return &(pageTableVirt->entries[pageTableIndex]);
+    }
+
+    PageTable* pageTable = (PageTable*)GetPageTableAddress(pageDirIndex);
+    return &pageTable->entries[pageTableIndex];
+}
+
+void VirtualMemoryManager::AllocatePage(PageTableEntry* page, bool kernel, bool writeable)
+{
+    void* p = PhysicalMemoryManager::AllocateBlock();
+    if(!p)
+        return;
+
+    page->present = 1;
+    page->readWrite = writeable ? 1 : 0;
+    page->isUser = kernel ? 0 : 1;
+    page->frame = (uint32_t)p / PAGE_SIZE;
+}
+
+void VirtualMemoryManager::FreePage(PageTableEntry* page)
+{
+    void* addr = (void*)(page->frame * PAGE_SIZE);
+    if(addr)
+        PhysicalMemoryManager::FreeBlock(addr);
+    
+    page->present = 0;
+}
+
+
+void* VirtualMemoryManager::GetPageTableAddress(uint16_t pageTableNumber)
+{
+    uint32_t ret = PAGE_TABLE_ADDRESS;
+    ret |= (pageTableNumber << PAGE_OFFSET_BITS);
+    return (void*)ret;
+}
+
+void* VirtualMemoryManager::virtualToPhysical(void* virtAddress)
+{
+    uint32_t pd_offset = PAGEDIR_INDEX(virtAddress);
+    uint32_t pt_offset = PAGETBL_INDEX(virtAddress);
+    uint32_t p_offset = PAGEFRAME_INDEX(virtAddress);
+
+    PageTable* pageTable = (PageTable*)(PAGE_TABLE_ADDRESS + (PAGE_SIZE * pd_offset));
+    PageTableEntry pageTableEntry = pageTable->entries[pt_offset];
+
+    uint32_t physAddress = (pageTableEntry.frame * PAGE_SIZE) | p_offset;
+
+    return (void*)physAddress;
+}
+
+void VirtualMemoryManager::mapVirtualToPhysical(void* physAddress, void* virtAddress, bool kernel, bool writeable)
+{
+    PageTableEntry* page = GetPageForAddress((uint32_t)virtAddress, true, writeable, !kernel);
+
+    page->frame = (uint32_t)physAddress / PAGE_SIZE;
+    page->isUser = kernel ? 0 : 1;
+    page->readWrite = writeable ? 1 : 0;
+    page->present = 1;
+
+    invlpg(virtAddress);
+}
+
+void VirtualMemoryManager::mapVirtualToPhysical(void* physAddress, void* virtAddress, uint32_t size, bool kernel, bool writeable)
+{
+    if(size % PAGE_SIZE != 0) {
+        Log(Error, "mapVirtualToPhysical(): Size is not devisible by PAGE_SIZE. Size = %d.", size);
+        return;
+    }
+    
+    for(uint32_t i = 0; i < size; i += PAGE_SIZE)
+    {
+        mapVirtualToPhysical((void*)((uint32_t)physAddress + i), (void*)((uint32_t)virtAddress + i), kernel, writeable);
+    }
+}
+
+void VirtualMemoryManager::SwitchPageDirectory(uint32_t physAddr)
+{
+    asm volatile("mov %0, %%cr3" :: "r"(physAddr));
+}
+
+uint32_t VirtualMemoryManager::GetPageDirectoryAddress()
+{
+    uint32_t cr3;
+    asm volatile("mov %%cr3, %0" : "=r"(cr3));
+    return cr3;
+}
\ No newline at end of file
diff --git a/kernelz/src/gdb/gdbimpl.cpp b/kernelz/src/gdb/gdbimpl.cpp
new file mode 100644
index 0000000..b37409e
--- /dev/null
+++ b/kernelz/src/gdb/gdbimpl.cpp
@@ -0,0 +1,90 @@
+#include <system/serialport.h>
+#include <system/log.h>
+#include <stdarg.h>
+#include <common/convert.h>
+#include <common/string.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+extern "C" void _putDebugChar(char a)
+{
+    Serialport::Write(a);
+}
+extern "C" int _getDebugChar()
+{
+    return Serialport::Read();
+}
+
+extern "C" void _fprintf(int stream, const char * format, ...)
+{
+    va_list args;
+    va_start(args, format);
+    
+    while (*format != '\0') { 
+		if (format[0] != '%' || format[1] == '%') {
+			if (format[0] == '%')
+				format++;
+			uint32_t amount = 1;
+			while (format[amount] && format[amount] != '%')
+				amount++;
+			Print(format, amount);
+			format += amount;
+			continue;
+		}
+ 
+		const char* format_begun_at = format++;
+ 
+		if (*format == 'c') {
+			format++;
+			char c = (char) va_arg(args, int /* char promotes to int */);
+			Print(&c, sizeof(c));
+		} else if (*format == 's') {
+			format++;
+			const char* str = va_arg(args, const char*);
+			uint32_t len = String::strlen(str);
+			Print(str, len);
+         } else if(*format == 'd') {
+            format++;
+            int n = va_arg(args, int);
+            int numChars = 0;
+            if (n < 0) { n = -n; numChars++; Print("-", 1); }
+
+            int temp = n;
+            do
+            {
+                numChars++;
+                temp /= 10;
+            } while (temp);
+
+            Print(Convert::IntToString(n), numChars);
+        } else if(*format == 'b') {
+            format++;
+            uint8_t n = va_arg(args, int);
+            char* str = Convert::IntToHexString(n);
+            Print("0x", 2); Print(str, sizeof(uint8_t)<<1);
+            delete str;
+        } else if(*format == 'w') {
+            format++;
+            uint16_t n = va_arg(args, int);
+            char* str = Convert::IntToHexString(n);
+            Print("0x", 2); Print(str, sizeof(uint16_t)<<1);
+            delete str;
+        } else if(*format == 'x') {
+            format++;
+            uint32_t n = va_arg(args, int);
+            char* str = Convert::IntToHexString(n);
+            Print("0x", 2); Print(str, sizeof(uint32_t)<<1);
+            delete str;
+        } else {
+			format = format_begun_at;
+			uint32_t len = String::strlen(format);
+			Print(format, len);
+			format += len;
+		}
+	}
+
+    va_end(args);
+}
\ No newline at end of file
diff --git a/kernelz/src/gdb/i386-stub.c b/kernelz/src/gdb/i386-stub.c
new file mode 100644
index 0000000..7975f08
--- /dev/null
+++ b/kernelz/src/gdb/i386-stub.c
@@ -0,0 +1,964 @@
+/****************************************************************************
+		THIS SOFTWARE IS NOT COPYRIGHTED
+   HP offers the following for use in the public domain.  HP makes no
+   warranty with regard to the software or it's performance and the
+   user accepts the software "AS IS" with all faults.
+   HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD
+   TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+****************************************************************************/
+
+/****************************************************************************
+ *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $
+ *
+ *  Module name: remcom.c $
+ *  Revision: 1.34 $
+ *  Date: 91/03/09 12:29:49 $
+ *  Contributor:     Lake Stevens Instrument Division$
+ *
+ *  Description:     low level support for gdb debugger. $
+ *
+ *  Considerations:  only works on target hardware $
+ *
+ *  Written by:      Glenn Engel $
+ *  ModuleState:     Experimental $
+ *
+ *  NOTES:           See Below $
+ *
+ *  Modified for 386 by Jim Kingdon, Cygnus Support.
+ *
+ *  To enable debugger support, two things need to happen.  One, a
+ *  call to set_debug_traps() is necessary in order to allow any breakpoints
+ *  or error conditions to be properly intercepted and reported to gdb.
+ *  Two, a breakpoint needs to be generated to begin communication.  This
+ *  is most easily accomplished by a call to breakpoint().  Breakpoint()
+ *  simulates a breakpoint by executing a trap #1.
+ *
+ *  The external function exceptionHandler() is
+ *  used to attach a specific handler to a specific 386 vector number.
+ *  It should use the same privilege level it runs at.  It should
+ *  install it as an interrupt gate so that interrupts are masked
+ *  while the handler runs.
+ *
+ *  Because gdb will sometimes write to the stack area to execute function
+ *  calls, this program cannot rely on using the supervisor stack so it
+ *  uses it's own stack area reserved in the int array remcomStack.
+ *
+ *************
+ *
+ *    The following gdb commands are supported:
+ *
+ * command          function                               Return value
+ *
+ *    g             return the value of the CPU registers  hex data or ENN
+ *    G             set the value of the CPU registers     OK or ENN
+ *
+ *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN
+ *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN
+ *
+ *    c             Resume at current address              SNN   ( signal NN)
+ *    cAA..AA       Continue at address AA..AA             SNN
+ *
+ *    s             Step one instruction                   SNN
+ *    sAA..AA       Step one instruction from AA..AA       SNN
+ *
+ *    k             kill
+ *
+ *    ?             What was the last sigval ?             SNN   (signal NN)
+ *
+ * All commands and responses are sent with a packet which includes a
+ * checksum.  A packet consists of
+ *
+ * $<packet info>#<checksum>.
+ *
+ * where
+ * <packet info> :: <characters representing the command or response>
+ * <checksum>    :: < two hex digits computed as modulo 256 sum of <packetinfo>>
+ *
+ * When a packet is received, it is first acknowledged with either '+' or '-'.
+ * '+' indicates a successful transfer.  '-' indicates a failed transfer.
+ *
+ * Example:
+ *
+ * Host:                  Reply:
+ * $m0,10#2a               +$00010203040506070809101112131415#42
+ *
+ ****************************************************************************/
+
+const int stderr = -1;
+extern void fprintf(int stream, const char* format, ...);
+
+char* strcpy(char* dst, const char* src)
+{
+    char c;
+    char* pointer = dst;
+
+    while ((c = *src++)) {
+        *pointer++ = c;
+    }
+
+    *pointer = '\0';
+    return dst;
+}
+
+/************************************************************************
+ *
+ * external low-level support routines
+*/
+
+extern void putDebugChar(char a); /* write a single character */
+extern int getDebugChar(); /* read and return a single char */
+
+//IDT Functions
+struct idt_entry {
+    unsigned short base_low;
+    unsigned short sel;
+    unsigned char zero;
+    unsigned char flags;
+    unsigned short base_high;
+} __attribute__((packed));
+
+unsigned int get_idt_base(void)
+{
+    unsigned char idtr[6];
+    unsigned int idt = 0;
+
+    asm volatile("sidt %0"
+                 :
+                 : "m"(idtr));
+    idt = *((unsigned int*)&idtr[2]);
+
+    return (idt);
+}
+
+void exceptionHandler(int exception_number, void* exception_address) /* assign an exception handler   */
+{
+    struct idt_entry* entries = (struct idt_entry*)get_idt_base();
+
+    unsigned int base = (unsigned int)exception_address;
+
+    entries[exception_number].base_low = (base & 0xFFFF);
+    entries[exception_number].base_high = (base >> 16) & 0xFFFF;
+}
+
+/************************************************************************/
+/* BUFMAX defines the maximum number of characters in inbound/outbound buffers*/
+/* at least NUMREGBYTES*2 are needed for register packets */
+#define BUFMAX 400
+
+static char initialized; /* boolean flag. != 0 means we've been initialized */
+
+int remote_debug = 1;
+/*  debug >  0 prints ill-formed commands in valid packets & checksum errors */
+
+static const char hexchars[] = "0123456789abcdef";
+
+/* Number of registers.  */
+#define NUMREGS 16
+
+/* Number of bytes of registers.  */
+#define NUMREGBYTES (NUMREGS * 4)
+
+enum regnames { EAX,
+    ECX,
+    EDX,
+    EBX,
+    ESP,
+    EBP,
+    ESI,
+    EDI,
+    PC /* also known as eip */,
+    PS /* also known as eflags */,
+    CS,
+    SS,
+    DS,
+    ES,
+    FS,
+    GS };
+
+/*
+ * these should not be static cuz they can be used outside this module
+ */
+int registers[NUMREGS];
+
+#define STACKSIZE 10000
+int remcomStack[STACKSIZE / sizeof(int)];
+static int* stackPtr = &remcomStack[STACKSIZE / sizeof(int) - 1];
+
+/***************************  ASSEMBLY CODE MACROS *************************/
+/* 									   */
+
+extern void
+return_to_prog();
+
+/* Restore the program's registers (including the stack pointer, which
+   means we get the right stack and don't have to worry about popping our
+   return address and any stack frames and so on) and return.  */
+asm(".text");
+asm(".globl _return_to_prog");
+asm("_return_to_prog:");
+asm("        movw _registers+44, %ss");
+asm("        movl _registers+16, %esp");
+asm("        movl _registers+4, %ecx");
+asm("        movl _registers+8, %edx");
+asm("        movl _registers+12, %ebx");
+asm("        movl _registers+20, %ebp");
+asm("        movl _registers+24, %esi");
+asm("        movl _registers+28, %edi");
+asm("        movw _registers+48, %ds");
+asm("        movw _registers+52, %es");
+asm("        movw _registers+56, %fs");
+asm("        movw _registers+60, %gs");
+asm("        movl _registers+36, %eax");
+asm("        pushl %eax"); /* saved eflags */
+asm("        movl _registers+40, %eax");
+asm("        pushl %eax"); /* saved cs */
+asm("        movl _registers+32, %eax");
+asm("        pushl %eax"); /* saved eip */
+asm("        movl _registers, %eax");
+/* use iret to restore pc and flags together so
+   that trace flag works right.  */
+asm("        iret");
+
+#define BREAKPOINT() asm("   int $3");
+
+/* Put the error code here just in case the user cares.  */
+int gdb_i386errcode;
+/* Likewise, the vector number here (since GDB only gets the signal
+   number through the usual means, and that's not very specific).  */
+int gdb_i386vector = -1;
+
+/* GDB stores segment registers in 32-bit words (that's just the way
+   m-i386v.h is written).  So zero the appropriate areas in registers.  */
+#define SAVE_REGISTERS1()            \
+    asm("movl %eax, _registers");    \
+    asm("movl %ecx, _registers+4");  \
+    asm("movl %edx, _registers+8");  \
+    asm("movl %ebx, _registers+12"); \
+    asm("movl %ebp, _registers+20"); \
+    asm("movl %esi, _registers+24"); \
+    asm("movl %edi, _registers+28"); \
+    asm("movw $0, %ax");             \
+    asm("movw %ds, _registers+48");  \
+    asm("movw %ax, _registers+50");  \
+    asm("movw %es, _registers+52");  \
+    asm("movw %ax, _registers+54");  \
+    asm("movw %fs, _registers+56");  \
+    asm("movw %ax, _registers+58");  \
+    asm("movw %gs, _registers+60");  \
+    asm("movw %ax, _registers+62");
+#define SAVE_ERRCODE() \
+    asm("popl %ebx");  \
+    asm("movl %ebx, _gdb_i386errcode");
+#define SAVE_REGISTERS2()                                                  \
+    asm("popl %ebx"); /* old eip */                                        \
+    asm("movl %ebx, _registers+32");                                       \
+    asm("popl %ebx"); /* old cs */                                         \
+    asm("movl %ebx, _registers+40");                                       \
+    asm("movw %ax, _registers+42");                                        \
+    asm("popl %ebx"); /* old eflags */                                     \
+    asm("movl %ebx, _registers+36");                                       \
+    /* Now that we've done the pops, we can save the stack pointer.");  */ \
+    asm("movw %ss, _registers+44");                                        \
+    asm("movw %ax, _registers+46");                                        \
+    asm("movl %esp, _registers+16");
+
+/* See if mem_fault_routine is set, if so just IRET to that address.  */
+#define CHECK_FAULT()                   \
+    asm("cmpl $0, _mem_fault_routine"); \
+    asm("jne mem_fault");
+
+asm(".text");
+asm("mem_fault:");
+/* OK to clobber temp registers; we're just going to end up in set_mem_err.  */
+/* Pop error code from the stack and save it.  */
+asm("     popl %eax");
+asm("     movl %eax, _gdb_i386errcode");
+
+asm("     popl %eax"); /* eip */
+/* We don't want to return there, we want to return to the function
+   pointed to by mem_fault_routine instead.  */
+asm("     movl _mem_fault_routine, %eax");
+asm("     popl %ecx"); /* cs (low 16 bits; junk in hi 16 bits).  */
+asm("     popl %edx"); /* eflags */
+
+/* Remove this stack frame; when we do the iret, we will be going to
+   the start of a function, so we want the stack to look just like it
+   would after a "call" instruction.  */
+asm("     leave");
+
+/* Push the stuff that iret wants.  */
+asm("     pushl %edx"); /* eflags */
+asm("     pushl %ecx"); /* cs */
+asm("     pushl %eax"); /* eip */
+
+/* Zero mem_fault_routine.  */
+asm("     movl $0, %eax");
+asm("     movl %eax, _mem_fault_routine");
+
+asm("iret");
+
+#define CALL_HOOK() asm("call _remcomHandler");
+
+/* This function is called when a i386 exception occurs.  It saves
+ * all the cpu regs in the _registers array, munges the stack a bit,
+ * and invokes an exception handler (remcom_handler).
+ *
+ * stack on entry:                       stack on exit:
+ *   old eflags                          vector number
+ *   old cs (zero-filled to 32 bits)
+ *   old eip
+ *
+ */
+extern void _catchException3();
+asm(".text");
+asm(".globl __catchException3");
+asm("__catchException3:");
+SAVE_REGISTERS1();
+SAVE_REGISTERS2();
+asm("pushl $3");
+CALL_HOOK();
+
+/* Same thing for exception 1.  */
+extern void _catchException1();
+asm(".text");
+asm(".globl __catchException1");
+asm("__catchException1:");
+SAVE_REGISTERS1();
+SAVE_REGISTERS2();
+asm("pushl $1");
+CALL_HOOK();
+
+/* Same thing for exception 0.  */
+extern void _catchException0();
+asm(".text");
+asm(".globl __catchException0");
+asm("__catchException0:");
+SAVE_REGISTERS1();
+SAVE_REGISTERS2();
+asm("pushl $0");
+CALL_HOOK();
+
+/* Same thing for exception 4.  */
+extern void _catchException4();
+asm(".text");
+asm(".globl __catchException4");
+asm("__catchException4:");
+SAVE_REGISTERS1();
+SAVE_REGISTERS2();
+asm("pushl $4");
+CALL_HOOK();
+
+/* Same thing for exception 5.  */
+extern void _catchException5();
+asm(".text");
+asm(".globl __catchException5");
+asm("__catchException5:");
+SAVE_REGISTERS1();
+SAVE_REGISTERS2();
+asm("pushl $5");
+CALL_HOOK();
+
+/* Same thing for exception 6.  */
+extern void _catchException6();
+asm(".text");
+asm(".globl __catchException6");
+asm("__catchException6:");
+SAVE_REGISTERS1();
+SAVE_REGISTERS2();
+asm("pushl $6");
+CALL_HOOK();
+
+/* Same thing for exception 7.  */
+extern void _catchException7();
+asm(".text");
+asm(".globl __catchException7");
+asm("__catchException7:");
+SAVE_REGISTERS1();
+SAVE_REGISTERS2();
+asm("pushl $7");
+CALL_HOOK();
+
+/* Same thing for exception 8.  */
+extern void _catchException8();
+asm(".text");
+asm(".globl __catchException8");
+asm("__catchException8:");
+SAVE_REGISTERS1();
+SAVE_ERRCODE();
+SAVE_REGISTERS2();
+asm("pushl $8");
+CALL_HOOK();
+
+/* Same thing for exception 9.  */
+extern void _catchException9();
+asm(".text");
+asm(".globl __catchException9");
+asm("__catchException9:");
+SAVE_REGISTERS1();
+SAVE_REGISTERS2();
+asm("pushl $9");
+CALL_HOOK();
+
+/* Same thing for exception 10.  */
+extern void _catchException10();
+asm(".text");
+asm(".globl __catchException10");
+asm("__catchException10:");
+SAVE_REGISTERS1();
+SAVE_ERRCODE();
+SAVE_REGISTERS2();
+asm("pushl $10");
+CALL_HOOK();
+
+/* Same thing for exception 12.  */
+extern void _catchException12();
+asm(".text");
+asm(".globl __catchException12");
+asm("__catchException12:");
+SAVE_REGISTERS1();
+SAVE_ERRCODE();
+SAVE_REGISTERS2();
+asm("pushl $12");
+CALL_HOOK();
+
+/* Same thing for exception 16.  */
+extern void _catchException16();
+asm(".text");
+asm(".globl __catchException16");
+asm("__catchException16:");
+SAVE_REGISTERS1();
+SAVE_REGISTERS2();
+asm("pushl $16");
+CALL_HOOK();
+
+/* For 13, 11, and 14 we have to deal with the CHECK_FAULT stuff.  */
+
+/* Same thing for exception 13.  */
+extern void _catchException13();
+asm(".text");
+asm(".globl __catchException13");
+asm("__catchException13:");
+CHECK_FAULT();
+SAVE_REGISTERS1();
+SAVE_ERRCODE();
+SAVE_REGISTERS2();
+asm("pushl $13");
+CALL_HOOK();
+
+/* Same thing for exception 11.  */
+extern void _catchException11();
+asm(".text");
+asm(".globl __catchException11");
+asm("__catchException11:");
+CHECK_FAULT();
+SAVE_REGISTERS1();
+SAVE_ERRCODE();
+SAVE_REGISTERS2();
+asm("pushl $11");
+CALL_HOOK();
+
+/* Same thing for exception 14.  */
+extern void _catchException14();
+asm(".text");
+asm(".globl __catchException14");
+asm("__catchException14:");
+CHECK_FAULT();
+SAVE_REGISTERS1();
+SAVE_ERRCODE();
+SAVE_REGISTERS2();
+asm("pushl $14");
+CALL_HOOK();
+
+/*
+ * remcomHandler is a front end for handle_exception.  It moves the
+ * stack pointer into an area reserved for debugger use.
+ */
+asm("_remcomHandler:");
+asm("           popl %eax"); /* pop off return address     */
+asm("           popl %eax"); /* get the exception number   */
+asm("		movl _stackPtr, %esp"); /* move to remcom stack area  */
+asm("		pushl %eax"); /* push exception onto stack  */
+asm("		call  _handle_exception"); /* this never returns */
+
+void _returnFromException()
+{
+    return_to_prog();
+}
+
+int
+    hex(ch) char ch;
+{
+    if ((ch >= 'a') && (ch <= 'f'))
+        return (ch - 'a' + 10);
+    if ((ch >= '0') && (ch <= '9'))
+        return (ch - '0');
+    if ((ch >= 'A') && (ch <= 'F'))
+        return (ch - 'A' + 10);
+    return (-1);
+}
+
+static char remcomInBuffer[BUFMAX];
+static char remcomOutBuffer[BUFMAX];
+
+/* scan for the sequence $<data>#<checksum>     */
+
+unsigned char*
+getpacket(void)
+{
+    unsigned char* buffer = (unsigned char*)&remcomInBuffer[0];
+    unsigned char checksum;
+    unsigned char xmitcsum;
+    int count;
+    char ch;
+
+    while (1) {
+        /* wait around for the start character, ignore all other characters */
+        while ((ch = getDebugChar()) != '$')
+            ;
+
+    retry:
+        checksum = 0;
+        xmitcsum = -1;
+        count = 0;
+
+        /* now, read until a # or end of buffer is found */
+        while (count < BUFMAX - 1) {
+            ch = getDebugChar();
+            if (ch == '$')
+                goto retry;
+            if (ch == '#')
+                break;
+            checksum = checksum + ch;
+            buffer[count] = ch;
+            count = count + 1;
+        }
+        buffer[count] = 0;
+
+        if (ch == '#') {
+            ch = getDebugChar();
+            xmitcsum = hex(ch) << 4;
+            ch = getDebugChar();
+            xmitcsum += hex(ch);
+
+            if (checksum != xmitcsum) {
+                if (remote_debug) {
+                    fprintf(stderr,
+                        "bad checksum.  My count = 0x%x, sent=0x%x. buf=%s\n",
+                        checksum, xmitcsum, buffer);
+                }
+                putDebugChar('-'); /* failed checksum */
+            } else {
+                putDebugChar('+'); /* successful transfer */
+
+                /* if a sequence char is present, reply the sequence ID */
+                if (buffer[2] == ':') {
+                    putDebugChar(buffer[0]);
+                    putDebugChar(buffer[1]);
+
+                    return &buffer[3];
+                }
+
+                return &buffer[0];
+            }
+        }
+    }
+}
+
+/* send the packet in buffer.  */
+
+void putpacket(unsigned char* buffer)
+{
+    unsigned char checksum;
+    int count;
+    char ch;
+
+    /*  $<packet info>#<checksum>.  */
+    do {
+        putDebugChar('$');
+        checksum = 0;
+        count = 0;
+
+        while ((ch = buffer[count])) {
+            putDebugChar(ch);
+            checksum += ch;
+            count += 1;
+        }
+
+        putDebugChar('#');
+        putDebugChar(hexchars[checksum >> 4]);
+        putDebugChar(hexchars[checksum % 16]);
+
+    } while (getDebugChar() != '+');
+}
+
+void
+    debug_error(format, parm) char* format;
+char* parm;
+{
+    if (remote_debug)
+        fprintf(stderr, format, parm);
+}
+
+/* Address of a routine to RTE to if we get a memory fault.  */
+static void (*volatile mem_fault_routine)() = 0;
+
+/* Indicate to caller of mem2hex or hex2mem that there has been an
+   error.  */
+static volatile int mem_err = 0;
+
+void set_mem_err(void)
+{
+    mem_err = 1;
+}
+
+/* These are separate functions so that they are so short and sweet
+   that the compiler won't save any registers (if there is a fault
+   to mem_fault, they won't get restored, so there better not be any
+   saved).  */
+int get_char(char* addr)
+{
+    return *addr;
+}
+
+void set_char(char* addr, int val)
+{
+    *addr = val;
+}
+
+/* convert the memory pointed to by mem into hex, placing result in buf */
+/* return a pointer to the last char put in buf (null) */
+/* If MAY_FAULT is non-zero, then we should set mem_err in response to
+   a fault; if zero treat a fault like any other fault in the stub.  */
+char*
+    mem2hex(mem, buf, count, may_fault) char* mem;
+char* buf;
+int count;
+int may_fault;
+{
+    int i;
+    unsigned char ch;
+
+    if (may_fault)
+        mem_fault_routine = set_mem_err;
+    for (i = 0; i < count; i++) {
+        ch = get_char(mem++);
+        if (may_fault && mem_err)
+            return (buf);
+        *buf++ = hexchars[ch >> 4];
+        *buf++ = hexchars[ch % 16];
+    }
+    *buf = 0;
+    if (may_fault)
+        mem_fault_routine = 0;
+    return (buf);
+}
+
+/* convert the hex array pointed to by buf into binary to be placed in mem */
+/* return a pointer to the character AFTER the last byte written */
+char*
+    hex2mem(buf, mem, count, may_fault) char* buf;
+char* mem;
+int count;
+int may_fault;
+{
+    int i;
+    unsigned char ch;
+
+    if (may_fault)
+        mem_fault_routine = set_mem_err;
+    for (i = 0; i < count; i++) {
+        ch = hex(*buf++) << 4;
+        ch = ch + hex(*buf++);
+        set_char(mem++, ch);
+        if (may_fault && mem_err)
+            return (mem);
+    }
+    if (may_fault)
+        mem_fault_routine = 0;
+    return (mem);
+}
+
+/* this function takes the 386 exception vector and attempts to
+   translate this number into a unix compatible signal value */
+int computeSignal(int exceptionVector)
+{
+    int sigval;
+    switch (exceptionVector) {
+    case 0:
+        sigval = 8;
+        break; /* divide by zero */
+    case 1:
+        sigval = 5;
+        break; /* debug exception */
+    case 3:
+        sigval = 5;
+        break; /* breakpoint */
+    case 4:
+        sigval = 16;
+        break; /* into instruction (overflow) */
+    case 5:
+        sigval = 16;
+        break; /* bound instruction */
+    case 6:
+        sigval = 4;
+        break; /* Invalid opcode */
+    case 7:
+        sigval = 8;
+        break; /* coprocessor not available */
+    case 8:
+        sigval = 7;
+        break; /* double fault */
+    case 9:
+        sigval = 11;
+        break; /* coprocessor segment overrun */
+    case 10:
+        sigval = 11;
+        break; /* Invalid TSS */
+    case 11:
+        sigval = 11;
+        break; /* Segment not present */
+    case 12:
+        sigval = 11;
+        break; /* stack exception */
+    case 13:
+        sigval = 11;
+        break; /* general protection */
+    case 14:
+        sigval = 11;
+        break; /* page fault */
+    case 16:
+        sigval = 7;
+        break; /* coprocessor error */
+    default:
+        sigval = 7; /* "software generated" */
+    }
+    return (sigval);
+}
+
+/**********************************************/
+/* WHILE WE FIND NICE HEX CHARS, BUILD AN INT */
+/* RETURN NUMBER OF CHARS PROCESSED           */
+/**********************************************/
+int hexToInt(char** ptr, int* intValue)
+{
+    int numChars = 0;
+    int hexValue;
+
+    *intValue = 0;
+
+    while (**ptr) {
+        hexValue = hex(**ptr);
+        if (hexValue >= 0) {
+            *intValue = (*intValue << 4) | hexValue;
+            numChars++;
+        } else
+            break;
+
+        (*ptr)++;
+    }
+
+    return (numChars);
+}
+
+/*
+ * This function does all command procesing for interfacing to gdb.
+ */
+void handle_exception(int exceptionVector)
+{
+    int sigval, stepping;
+    int addr, length;
+    char* ptr;
+    int newPC;
+
+    gdb_i386vector = exceptionVector;
+
+    /*
+  if (remote_debug)
+    {
+      fprintf (stderr, "vector=%d, sr=0x%x, pc=0x%x\n",
+	      exceptionVector, registers[PS], registers[PC]);
+    }
+  */
+
+    /* reply to host that an exception has occurred */
+    sigval = computeSignal(exceptionVector);
+
+    ptr = remcomOutBuffer;
+
+    *ptr++ = 'T'; /* notify gdb with signo, PC, FP and SP */
+    *ptr++ = hexchars[sigval >> 4];
+    *ptr++ = hexchars[sigval & 0xf];
+
+    *ptr++ = hexchars[ESP];
+    *ptr++ = ':';
+    ptr = mem2hex((char*)&registers[ESP], ptr, 4, 0); /* SP */
+    *ptr++ = ';';
+
+    *ptr++ = hexchars[EBP];
+    *ptr++ = ':';
+    ptr = mem2hex((char*)&registers[EBP], ptr, 4, 0); /* FP */
+    *ptr++ = ';';
+
+    *ptr++ = hexchars[PC];
+    *ptr++ = ':';
+    ptr = mem2hex((char*)&registers[PC], ptr, 4, 0); /* PC */
+    *ptr++ = ';';
+
+    *ptr = '\0';
+
+    putpacket((unsigned char*)remcomOutBuffer);
+
+    stepping = 0;
+
+    while (1 == 1) {
+        remcomOutBuffer[0] = 0;
+        ptr = getpacket();
+
+        switch (*ptr++) {
+        case '?':
+            remcomOutBuffer[0] = 'S';
+            remcomOutBuffer[1] = hexchars[sigval >> 4];
+            remcomOutBuffer[2] = hexchars[sigval % 16];
+            remcomOutBuffer[3] = 0;
+            break;
+        case 'd':
+            remote_debug = !(remote_debug); /* toggle debug flag */
+            break;
+        case 'g': /* return the value of the CPU registers */
+            mem2hex((char*)registers, remcomOutBuffer, NUMREGBYTES, 0);
+            break;
+        case 'G': /* set the value of the CPU registers - return OK */
+            hex2mem(ptr, (char*)registers, NUMREGBYTES, 0);
+            strcpy(remcomOutBuffer, "OK");
+            break;
+        case 'P': /* set the value of a single CPU register - return OK */
+        {
+            int regno;
+
+            if (hexToInt(&ptr, &regno) && *ptr++ == '=')
+                if (regno >= 0 && regno < NUMREGS) {
+                    hex2mem(ptr, (char*)&registers[regno], 4, 0);
+                    strcpy(remcomOutBuffer, "OK");
+                    break;
+                }
+
+            strcpy(remcomOutBuffer, "E01");
+            break;
+        }
+
+            /* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
+        case 'm':
+            /* TRY TO READ %x,%x.  IF SUCCEED, SET PTR = 0 */
+            if (hexToInt(&ptr, &addr))
+                if (*(ptr++) == ',')
+                    if (hexToInt(&ptr, &length)) {
+                        ptr = 0;
+                        mem_err = 0;
+                        mem2hex((char*)addr, remcomOutBuffer, length, 1);
+                        if (mem_err) {
+                            strcpy(remcomOutBuffer, "E03");
+                            debug_error("memory fault");
+                        }
+                    }
+
+            if (ptr) {
+                strcpy(remcomOutBuffer, "E01");
+            }
+            break;
+
+            /* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
+        case 'M':
+            /* TRY TO READ '%x,%x:'.  IF SUCCEED, SET PTR = 0 */
+            if (hexToInt(&ptr, &addr))
+                if (*(ptr++) == ',')
+                    if (hexToInt(&ptr, &length))
+                        if (*(ptr++) == ':') {
+                            mem_err = 0;
+                            hex2mem(ptr, (char*)addr, length, 1);
+
+                            if (mem_err) {
+                                strcpy(remcomOutBuffer, "E03");
+                                debug_error("memory fault");
+                            } else {
+                                strcpy(remcomOutBuffer, "OK");
+                            }
+
+                            ptr = 0;
+                        }
+            if (ptr) {
+                strcpy(remcomOutBuffer, "E02");
+            }
+            break;
+
+            /* cAA..AA    Continue at address AA..AA(optional) */
+            /* sAA..AA   Step one instruction from AA..AA(optional) */
+        case 's':
+            stepping = 1;
+        case 'c':
+            /* try to read optional parameter, pc unchanged if no parm */
+            if (hexToInt(&ptr, &addr))
+                registers[PC] = addr;
+
+            newPC = registers[PC];
+
+            /* clear the trace bit */
+            registers[PS] &= 0xfffffeff;
+
+            /* set the trace bit if we're stepping */
+            if (stepping)
+                registers[PS] |= 0x100;
+
+            _returnFromException(); /* this is a jump */
+            break;
+
+            /* kill the program */
+        case 'k': /* do nothing */
+#if 0
+	  /* Huh? This doesn't look like "nothing".
+	     m68k-stub.c and sparc-stub.c don't have it.  */
+	  BREAKPOINT ();
+#endif
+            break;
+        } /* switch */
+
+        /* reply to the request */
+        putpacket(remcomOutBuffer);
+    }
+}
+
+/* this function is used to set up exception handlers for tracing and
+   breakpoints */
+void set_debug_traps(void)
+{
+    stackPtr = &remcomStack[STACKSIZE / sizeof(int) - 1];
+
+    exceptionHandler(0, _catchException0);
+    exceptionHandler(1, _catchException1);
+    exceptionHandler(3, _catchException3);
+    exceptionHandler(4, _catchException4);
+    exceptionHandler(5, _catchException5);
+    exceptionHandler(6, _catchException6);
+    exceptionHandler(7, _catchException7);
+    exceptionHandler(8, _catchException8);
+    exceptionHandler(9, _catchException9);
+    exceptionHandler(10, _catchException10);
+    exceptionHandler(11, _catchException11);
+    exceptionHandler(12, _catchException12);
+    //exceptionHandler (13, _catchException13); //Needed for virtual8086
+    //exceptionHandler(14, _catchException14);
+    exceptionHandler(16, _catchException16);
+
+    initialized = 1;
+}
+
+/* This function will generate a breakpoint exception.  It is used at the
+   beginning of a program to sync up with a debugger and can be used
+   otherwise as a quick means to stop program execution and "break" into
+   the debugger.  */
+
+void breakpoint(void)
+{
+    if (initialized)
+        BREAKPOINT();
+}
\ No newline at end of file
diff --git a/kernelz/src/installer/installer.cpp b/kernelz/src/installer/installer.cpp
new file mode 100644
index 0000000..812ec01
--- /dev/null
+++ b/kernelz/src/installer/installer.cpp
@@ -0,0 +1,590 @@
+#include <installer/installer.h>
+#include <installer/textgui.h>
+#include <system/system.h>
+#include <core/power.h>
+#include <system/vfs/fat.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+#define SECTORS_PER_TRACK 80
+
+char* AsciiLogo[] = {
+"    ######     ###     ######  ######## ##     ##  ######   #######   ######   ",
+"   ##    ##   ## ##   ##    ##    ##    ##     ## ##    ## ##     ## ##    ##  ",
+"   ##        ##   ##  ##          ##    ##     ## ##       ##     ## ##        ",
+"   ##       ##     ## ##          ##    ##     ##  ######  ##     ##  ######   ",
+"   ##       ######### ##          ##    ##     ##       ## ##     ##       ##  ",
+"   ##    ## ##     ## ##    ##    ##    ##     ## ##    ## ##     ## ##    ##  ",
+"    ######  ##     ##  ######     ##     #######   ######   #######   ######   "
+};
+
+// Files required for setup
+char* FileList[] = {
+    "B:\\setup\\boot.img",
+    "B:\\setup\\welcome.txt",
+    "B:\\setup\\warning.txt",
+};
+
+// Modules required by grub in order to boot CactusOS
+char* GrubModules[] = {
+    "B:\\boot\\grub\\i386-pc\\bufio.mod",
+    "B:\\boot\\grub\\i386-pc\\gettext.mod",
+    "B:\\boot\\grub\\i386-pc\\terminal.mod",
+    "B:\\boot\\grub\\i386-pc\\crypto.mod",
+    "B:\\boot\\grub\\i386-pc\\extcmd.mod",
+    "B:\\boot\\grub\\i386-pc\\boot.mod",
+    "B:\\boot\\grub\\i386-pc\\normal.mod",
+    "B:\\boot\\grub\\i386-pc\\configfile.mod",
+    "B:\\boot\\grub\\i386-pc\\biosdisk.mod",
+    "B:\\boot\\grub\\i386-pc\\part_msdos.mod",
+    "B:\\boot\\grub\\i386-pc\\fshelp.mod",
+    "B:\\boot\\grub\\i386-pc\\fat.mod",
+    "B:\\boot\\grub\\i386-pc\\video_fb.mod",
+    "B:\\boot\\grub\\i386-pc\\video.mod",
+    "B:\\boot\\grub\\i386-pc\\vbe.mod",
+    "B:\\boot\\grub\\i386-pc\\lsapm.mod",
+    "B:\\boot\\grub\\i386-pc\\mmap.mod",
+    "B:\\boot\\grub\\i386-pc\\relocator.mod",
+    "B:\\boot\\grub\\i386-pc\\datetime.mod",
+    "B:\\boot\\grub\\i386-pc\\priority_queue.mod",
+    "B:\\boot\\grub\\i386-pc\\net.mod",
+    "B:\\boot\\grub\\i386-pc\\multiboot.mod",
+    "B:\\boot\\grub\\i386-pc\\echo.mod",
+};
+
+Disk* selectedDisk = 0;
+
+void LBAToCHS(int lba, int *head, int *track, int *sector)
+{
+	(*head) = (lba % (SECTORS_PER_TRACK * 2)) / SECTORS_PER_TRACK;
+	(*track) = (lba / (SECTORS_PER_TRACK * 2));
+	(*sector) = (lba % SECTORS_PER_TRACK + 1);
+}
+
+void Installer::Run()
+{
+    TextGUI::DisableCursor();
+    TextGUI::ClearScreen(VGA_COLOR_BLUE);
+
+    // Draw Ascii logo
+    for(uint32_t i = 0; i < sizeof(AsciiLogo) / sizeof(char*); i++)
+        TextGUI::DrawString(AsciiLogo[i], 0, i + 1, VGA_COLOR_GREEN);
+
+    TextGUI::StatusBar("Initializing Setup...", 0);
+    TextGUI::StatusBar("Checking Setup Files...", 5);
+    for(uint32_t i = 0; i< sizeof(FileList) / sizeof(char*); i++) {
+        TextGUI::StatusBar(FileList[i], 5);
+        if(System::vfs->FileExists(FileList[i]) == false)
+            SetupError();
+    }
+
+    TextGUI::StatusBar("Checking Grub Modules...", 5);
+    for(uint32_t i = 0; i < sizeof(GrubModules) / sizeof(char*); i++) {
+        TextGUI::StatusBar(GrubModules[i], 5);
+        if(System::vfs->FileExists(GrubModules[i]) == false)
+            SetupError();
+    }
+
+    // Display welcome at start of setup
+    ShowWelcomeMessage();
+
+    // Next show warning message
+    ShowWarningMessage();
+
+    // Show disk selection menu
+    ShowDiskSelection();
+
+    // Ask user for disk wipe
+    ShowDiskEraseMenu();
+
+    // Start the installation
+    ShowInstallScreen();
+
+    TextGUI::ClearScreen();
+    TextGUI::DrawString("Remove installation media.", 0, 0);
+    TextGUI::DrawString("Setup is complete, press enter to reboot", 0, 1);
+
+    TextGUI::StatusBar("Waiting for enter key....", 60);
+    while(GetKey() != KEY_ENTER)
+        TextGUI::StatusBar("Waiting for enter key.... [Wrong Key]", 60);
+    
+    Log(Info, "Rebooting System");
+    Power::Reboot();
+}
+
+char Installer::GetKey()
+{
+    while(System::keyboardManager->Available() == 0)
+        asm ("hlt");
+
+    return System::keyboardManager->Read();
+}
+
+void Installer::ShowWelcomeMessage()
+{
+    int fileSize = System::vfs->GetFileSize("B:\\setup\\welcome.txt");
+    char* buf = new char[fileSize + 1];
+    buf[fileSize] = '\0';
+    if(System::vfs->ReadFile("B:\\setup\\welcome.txt", (uint8_t*)buf) == -1)
+        SetupError();
+    
+    TextGUI::ClearScreen(VGA_COLOR_BLUE);
+    TextGUI::DrawString(buf, 0, 0);
+
+    delete buf;
+    TextGUI::StatusBar("Waiting for Keypress...", 10);
+    while(GetKey() != KEY_ENTER) //Enter Key
+        TextGUI::StatusBar("Waiting for Keypress... [Incorrect]", 10);
+}
+
+void Installer::ShowWarningMessage()
+{
+    int fileSize = System::vfs->GetFileSize("B:\\setup\\warning.txt");
+    char* buf = new char[fileSize + 1];
+    buf[fileSize] = '\0';
+    if(System::vfs->ReadFile("B:\\setup\\warning.txt", (uint8_t*)buf) == -1)
+        SetupError();
+    
+    TextGUI::ClearScreen(VGA_COLOR_BLUE);
+    TextGUI::DrawString(buf, 0, 0);
+
+    delete buf;
+    TextGUI::StatusBar("Waiting for Keypress...", 10);
+    while(GetKey() != KEY_ENTER) //Enter Key
+        TextGUI::StatusBar("Waiting for Keypress... [Incorrect]", 10);
+}
+
+void Installer::ShowDiskSelection()
+{
+    TextGUI::ClearScreen(VGA_COLOR_BLUE);
+    TextGUI::DrawString("Select a disk to install CactusOS to:", 0, 0);
+    TextGUI::StatusBar("Select disk.    [Up/Down/Enter]", 10);
+
+    const int optionStart = 5; //Rows between options to start
+    int count = 0;
+    for(Disk* d : System::diskManager->allDisks) {
+        if(d->type != HardDisk)
+            continue;
+        
+        char* nameString = d->identifier ? d->identifier : (char*)"Unnamed Hard Disk";
+        TextGUI::DrawString(nameString, 3, optionStart + count);
+        TextGUI::DrawString(Convert::IntToString32(divide64(d->size, 1_MB)), VGA_WIDTH - 8, optionStart + count);
+        TextGUI::DrawString("MB", VGA_WIDTH - 2, optionStart + count);
+
+        count++;
+    }
+    if(count == 0)
+        SetupError();
+
+    int selectIndex = 0;
+    while(selectedDisk == 0) {
+        TextGUI::DrawString("-->", 0, optionStart + selectIndex);
+        switch(GetKey()) {
+            case KEY_ARROW_UP: //Arrow Up
+                if(selectIndex > 0) {
+                    TextGUI::DrawString("   ", 0, optionStart + selectIndex);
+                    selectIndex = 0;
+                }
+                break;
+            case KEY_ARROW_DOWN: //Arrow Down
+                if(selectIndex < (count - 1)) {
+                    TextGUI::DrawString("   ", 0, optionStart + selectIndex);
+                    selectIndex++;
+                }
+                break;
+            case KEY_ENTER: //Enter
+                selectedDisk = System::diskManager->allDisks[selectIndex];
+                break;
+            default:
+                continue;
+        }
+    }
+}
+
+void Installer::ShowDiskEraseMenu()
+{
+    TextGUI::ClearScreen(VGA_COLOR_BLUE);
+    TextGUI::DrawString(selectedDisk->identifier ? selectedDisk->identifier : (char*)"Unnamed Hard Disk", 0, 0);
+    TextGUI::DrawString("Would you like to completely wipe the selected disk?", 0, 3);
+    TextGUI::DrawString("This can be usefull when you want to completely overwrite the system", 0, 4);
+    TextGUI::DrawString("Press [Y] for wipe and [N] to continue the setup", 0, 5);
+    TextGUI::StatusBar("Waiting for key", 20);
+
+    if(GetKey() != 0x15) //Key is not Y key
+        return;
+
+    uint32_t sectors = divide64(selectedDisk->size, 512);
+    uint8_t buf[512];
+    MemoryOperations::memset(buf, 0, 512);
+
+    TextGUI::StatusBar("Cleaning Disk....   [Press any key to cancel]", 30);
+    for(uint32_t s = 0; s < sectors; s++) {
+        if(selectedDisk->WriteSector(s, buf) != 0)
+            SetupError();
+        
+        if(s % 100 == 0) {
+            TextGUI::DrawString(Convert::IntToString32(sectors), 0, VGA_HEIGHT - 3);
+            TextGUI::DrawString("/", 10, VGA_HEIGHT - 3);
+            TextGUI::DrawString(Convert::IntToString32(s), 13, VGA_HEIGHT - 3);
+            TextGUI::SetPixel(((double)s/(double)sectors) * (double)VGA_WIDTH, VGA_HEIGHT - 2, TEXT_COLOR, '#', VGA_COLOR_GREEN);
+        }
+        if(System::keyboardManager->Available() > 0) {
+            System::keyboardManager->Read();
+            break;
+        }
+    }
+}
+
+// Perform the installation
+void Installer::ShowInstallScreen()
+{
+    TextGUI::ClearScreen();
+    TextGUI::DrawString("You are about to start the installation of CactusOS to your hard drive", 0, 0);
+    TextGUI::DrawString("The installation process will contain the following:", 0, 1);
+    TextGUI::DrawString("   - Replace the MBR with grub stage1 boot code + partition table", 0, 2);
+    TextGUI::DrawString("   - Copy rest of the bootloader to harddisk", 0, 3);
+    TextGUI::DrawString("   - Create FAT32 partition as main filesystem", 0, 4);
+    TextGUI::DrawString("   - Copy system files to new partition", 0, 5);
+
+    TextGUI::DrawString("Press enter to start the installation", 0, 7);
+    TextGUI::StatusBar("Waiting for enter key....", 40);
+    while(GetKey() != KEY_ENTER)
+        TextGUI::StatusBar("Waiting for enter key.... [Wrong Key]", 40);
+    
+    /////////////////////////
+    // Start of installation
+    /////////////////////////
+
+    /////////////////////////
+    // Create new MBR with bootloader
+    /////////////////////////
+    TextGUI::StatusBar("Creating new MBR in memory....", 45);
+    MasterBootRecord newMBR;
+    MemoryOperations::memset(&newMBR, 0x0, sizeof(MasterBootRecord));
+
+    // Fill in some values
+    char sign[4] = { 'C', 'A', (char)System::rtc->GetMonth(), (char)(System::rtc->GetYear() - 2000) };
+    newMBR.signature = *(uint32_t*)sign;
+    newMBR.unused = 0;
+    newMBR.magicnumber = 0xAA55;
+    
+    // Read bootloader stage1 from cdrom
+    uint8_t bootloader[440];
+    TextGUI::StatusBar("Reading bootloader stage1 from CD", 50);
+    if(System::vfs->ReadFile("B:\\setup\\boot.img", bootloader) != 0)
+        SetupError();
+    
+    // Copy it to our MBR
+    MemoryOperations::memcpy(newMBR.bootloader, bootloader, 440);
+
+    //////////////////////////
+    // Read core.img from cdrom
+    //////////////////////////
+    TextGUI::StatusBar("Reading bootloader from CD to disk", 55);
+    uint32_t coreSize = System::vfs->GetFileSize("B:\\setup\\core.img");
+    if((int)coreSize == -1)
+        SetupError();
+    
+    // Check if size is alligned
+    if(coreSize % 512 != 0)
+        coreSize = align_up(coreSize, 512);
+    
+    // Create memory for core image
+    uint8_t* coreBuffer = new uint8_t[coreSize];
+    MemoryOperations::memset(coreBuffer, 0, coreSize);
+
+    // And read the file
+    if(System::vfs->ReadFile("B:\\setup\\core.img", coreBuffer) != 0)
+        SetupError();
+
+    /////////////////////
+    // Create FAT32 Partition
+    /////////////////////
+    TextGUI::StatusBar("Creating FAT32 Partition", 60);
+    CreateFatPartition(newMBR.primaryPartitions);  //We use entry 0, makes the most sense.
+
+    ////////////////////
+    // Write new MBR to disk
+    ////////////////////
+    TextGUI::StatusBar("Writing new MBR + Bootloader to disk", 80);
+    if(selectedDisk->WriteSector(0, (uint8_t*)&newMBR) != 0)
+        SetupError();
+
+    ////////////////////
+    // Write core.img to disk
+    ////////////////////
+    TextGUI::StatusBar("Writing core.img to disk", 85);
+    for(uint32_t sector = 0; sector < (coreSize/512); sector++)
+        if(selectedDisk->WriteSector(sector + 1, coreBuffer + sector*512) != 0)
+            SetupError();
+    
+    TextGUI::StatusBar("Cleaning up....", 90);
+
+    //Free buffer
+    delete coreBuffer;
+
+    // Create new FAT32 filesystem module
+    FAT* fatFS = new FAT(selectedDisk, newMBR.primaryPartitions[0].start_lba, newMBR.primaryPartitions[0].length);
+    if(fatFS->Initialize() == false)
+        SetupError();
+
+    BootConsole::WriteLine();
+    
+    // Start the file copying
+    ShowSystemCopyScreen(fatFS);
+
+    // We don't need this anymore
+    delete fatFS;
+}
+
+void CopyFile(VirtualFileSystem* src, VirtualFileSystem* dest, char* path)
+{
+    if(src->FileExists(path) == false)
+        Installer::SetupError();
+    
+    uint32_t fileSize = src->GetFileSize(path);
+    
+    uint8_t* buffer = new uint8_t[fileSize];
+    if(src->ReadFile(path, buffer) != 0)
+        Installer::SetupError();
+    
+    if(dest->WriteFile(path, buffer, fileSize, true) != 0)
+        Installer::SetupError();
+
+    delete buffer;
+}
+
+void CopyDirectory(VirtualFileSystem* src, VirtualFileSystem* dest, char* path)
+{
+    auto content = src->DirectoryList(path);
+    for(LIBCactusOS::VFSEntry item : *content)
+    {
+        char itemPath[255];
+        MemoryOperations::memset(itemPath, 0, 255);
+
+        int i1 = String::strlen(path);
+        int i2 = String::strlen(item.name);
+
+        if(i1 != 0) { // Not in the root directory
+            MemoryOperations::memcpy(itemPath, path, i1);
+            itemPath[i1] = '\\';
+            MemoryOperations::memcpy(itemPath + i1 + 1, item.name, i2);
+        }
+        else
+            MemoryOperations::memcpy(itemPath + i1, item.name, i2);
+
+        if(src->FileExists(itemPath)) {
+            if(String::strncmp(itemPath, "boot\\grub\\i386-pc\\", 17) == true) // We only need a couple of grub modules, not all from the liveCD
+            {
+                bool shouldCopy = false;
+                for(uint32_t i = 0; i < sizeof(GrubModules) / sizeof(char*); i++)
+                    if(String::strcmp(GrubModules[i] + 3 /* Skip B:\ */, itemPath)) // Check if we need to copy this module
+                        shouldCopy = true;
+                
+                if(!shouldCopy) {
+                    Log(Info, "Skipping File: %s", itemPath);
+                    continue;
+                }
+            }
+
+            Log(Info, "Copying File: %s", itemPath);
+
+            CopyFile(src, dest, itemPath);
+        }
+        else if(src->DirectoryExists(itemPath)) {
+            if(String::strncmp(itemPath, "setup", 5) == false) { // No need to copy the setup directory
+                dest->CreateDirectory(itemPath);
+                
+                CopyDirectory(src, dest, itemPath);
+            }
+        }
+        else {
+            Installer::SetupError();
+        }
+    }
+
+    delete content;
+}
+
+void Installer::ShowSystemCopyScreen(FAT* fatFS)
+{
+    TextGUI::ClearScreen();
+    TextGUI::DrawString("Copying system files to new filesystem", 0, 0);
+
+    CopyDirectory(System::vfs->Filesystems->GetAt(System::vfs->bootPartitionID), fatFS, "");
+}
+
+void Installer::SetupError()
+{
+    //TextGUI::ClearScreen(VGA_COLOR_BLUE);
+    TextGUI::DrawString("Error while installing", 0, 0);
+    while(1);
+}
+
+uint32_t alignSector(uint32_t sectors, uint32_t clusterSize)
+{
+	return (sectors + clusterSize - 1) & ~(clusterSize - 1);
+}
+
+inline uint32_t cdiv(uint32_t a, uint32_t b)
+{
+    return (a + b - 1) / b;
+}
+
+void setClusterValue(uint8_t* fat, int cluster, uint32_t value)
+{
+    value &= 0xFFFFFFF;
+	fat[4 * cluster] = (uint8_t)(value & 0x000000FF);
+	fat[(4 * cluster) + 1] = (uint8_t)((value & 0x0000FF00) >> 8);
+	fat[(4 * cluster) + 2] = (uint8_t)((value & 0x00FF0000) >> 16);
+	fat[(4 * cluster) + 3] = (uint8_t)((value & 0xFF000000) >> 24);
+}
+
+void Installer::CreateFatPartition(PartitionTableEntry* pEntry)
+{
+    // First fill in the new values for partition entry
+    pEntry->bootable = (1<<7);
+    pEntry->start_lba = 2048;
+    pEntry->length = divide64(selectedDisk->size, 512) - pEntry->start_lba - (1_MB / 512);
+    pEntry->partition_id = 0x0B;
+    // Legacy CHS Values
+    { // Begin
+        int head,track,sector;
+        LBAToCHS(pEntry->start_lba, &head, &track, &sector);
+        pEntry->start_head = head;
+        pEntry->start_cylinder = track;
+        pEntry->start_sector = sector;
+    }
+    { // End
+        int head,track,sector;
+        LBAToCHS(pEntry->start_lba + pEntry->length, &head, &track, &sector);
+        pEntry->end_head = head;
+        pEntry->end_cylinder = track;
+        pEntry->end_sector = sector;
+    }
+
+
+    // Create BIOS Parameter Block structure in memory
+    FAT32_BPB biosParameterBlock;
+    MemoryOperations::memset(&biosParameterBlock, 0, sizeof(FAT32_BPB));
+
+    uint32_t sizeMB = ((pEntry->length / 1024) * 512) / 1024;
+
+    ///////////////////////
+    // BIOS Parameter Block values
+    ///////////////////////
+    biosParameterBlock.bootCode[0] = 0xEB;
+    biosParameterBlock.bootCode[1] = 0x3C;
+    biosParameterBlock.bootCode[2] = 0x90;
+
+    MemoryOperations::memcpy(biosParameterBlock.Oem_Id, "CactusOS", 8);
+    biosParameterBlock.bytesPerSector = 512;
+    biosParameterBlock.SectorsPerCluster = sizeMB > 32_KB ? 64 : sizeMB > 16_KB ? 32 : sizeMB > 8_KB ? 16 : sizeMB > 260 ? 8 : 1; //_KB Can be a bit misleading, we are comparing MB with MB
+    biosParameterBlock.ReservedSectors = 32;
+    biosParameterBlock.NumOfFats = 2;
+    biosParameterBlock.NumDirEntries = 0;
+    biosParameterBlock.TotalSectorsSmall = 0;
+    biosParameterBlock.MediaDescriptorType = 0xF8;
+    biosParameterBlock.SectorsPerFat12_16 = 0;
+    biosParameterBlock.SectorsPerTrack = 32;
+    biosParameterBlock.NumHeads = 64;
+    biosParameterBlock.HiddenSectors = pEntry->start_lba;
+    biosParameterBlock.TotalSectorsBig = pEntry->length;
+
+    // FAT32 Specific values
+    // Calculate Sectors Per Fat
+    uint32_t nClusters = divide64(((long long)biosParameterBlock.TotalSectorsBig * 512 + biosParameterBlock.NumOfFats * 8), ((int)biosParameterBlock.SectorsPerCluster * 512 + biosParameterBlock.NumOfFats * 4));
+    biosParameterBlock.SectorsPerFat32 = cdiv((nClusters + 2) * 4, 512);
+    biosParameterBlock.SectorsPerFat32 = alignSector(biosParameterBlock.SectorsPerFat32, biosParameterBlock.SectorsPerCluster);
+    
+    biosParameterBlock.Flags = 0; // Active = 0 and No Mirroring
+    biosParameterBlock.FATVersionNum = 0; // 0.0
+    biosParameterBlock.RootDirCluster = 2;
+    biosParameterBlock.FSInfoSector = 1;
+    biosParameterBlock.BackupBootSector = 0; // We do not provide a backup of the boot sector
+    biosParameterBlock.DriveNum = 0x80;
+    biosParameterBlock.WinNTFlags = 0;
+    biosParameterBlock.Signature = 0x29;
+
+    char volumeID[4] = { (char)System::rtc->GetSecond(), (char)System::rtc->GetDay(), (char)System::rtc->GetMonth(), (char)(System::rtc->GetYear() - 2000) };
+    biosParameterBlock.VolumeIDSerial = *(uint32_t*)volumeID;
+    MemoryOperations::memcpy(biosParameterBlock.VolumeLabel, "CactusOS HD", 11);
+    MemoryOperations::memcpy(biosParameterBlock.SystemIDString, "FAT32   ", 8);
+    biosParameterBlock.BootSignature = 0xAA55;
+
+    // Create FSInfo Structure
+    FAT32_FSInfo fsInfo;
+    MemoryOperations::memset(&fsInfo, 0, sizeof(FAT32_FSInfo));
+
+    ///////////////////////
+    // FSInfo values
+    ///////////////////////
+    fsInfo.signature1 = 0x41615252;
+    fsInfo.signature2 = 0x61417272;
+    fsInfo.lastFreeCluster = 0xFFFFFFFF; //Unknown
+    fsInfo.startSearchCluster = 0xFFFFFFFF; //Unknown, perhaps change those values in the future
+    fsInfo.signature3 = 0xAA550000;
+
+
+
+    ///////////////////////
+    // Create FAT Tables
+    ///////////////////////
+    uint8_t fatTable[512];
+    MemoryOperations::memset(fatTable, 0, 512);
+
+    // Set first to entries
+    setClusterValue(fatTable, 0, 0xFFFFFFFF);
+    setClusterValue(fatTable, 1, 0xFFFFFFFF);
+    fatTable[0] = (uint8_t)biosParameterBlock.MediaDescriptorType; // Not sure why this is needed
+    setClusterValue(fatTable, 2, CLUSTER_END_32);
+
+    //uint32_t rootDirSize = biosParameterBlock.SectorsPerCluster * biosParameterBlock.bytesPerSector;
+    DirectoryEntry rootDir;
+    MemoryOperations::memset(&rootDir, 0, sizeof(DirectoryEntry));
+
+    // Fill in root dir values
+    rootDir.Attributes = ATTR_VOLUME_ID;
+
+    ///////////////////////
+    // Write changes to disk
+    // Clear reserved sectors first
+    uint8_t zeroBuffer[512];
+    MemoryOperations::memset(zeroBuffer, 0, 512);
+    TextGUI::StatusBar("Cleaning Reserved Sectors", 65);
+    for(int i = 0; i < biosParameterBlock.ReservedSectors; i++)
+        if(selectedDisk->WriteSector(pEntry->start_lba + i, zeroBuffer) != 0)
+            SetupError();
+
+    // Copy FAT's
+    TextGUI::StatusBar("Writing FAT Tables", 70);
+    for(int i = 0; i < biosParameterBlock.NumOfFats; i++) {
+        if(selectedDisk->WriteSector(pEntry->start_lba + biosParameterBlock.ReservedSectors + (i*biosParameterBlock.SectorsPerFat32), fatTable) != 0)
+            SetupError();
+
+        // Set rest of FAT to 0
+        for(uint32_t c = 0; c < (biosParameterBlock.SectorsPerFat32 - 1); c++)
+            if(selectedDisk->WriteSector(pEntry->start_lba + biosParameterBlock.ReservedSectors + (i*biosParameterBlock.SectorsPerFat32) + c + 1, zeroBuffer) != 0)
+                SetupError();
+    }
+
+    // Copy root directory
+    // Use zerobuffer since it is not needed anymore
+    TextGUI::StatusBar("Writing root directory", 75);
+    MemoryOperations::memcpy(zeroBuffer, &rootDir, sizeof(DirectoryEntry));
+    if(selectedDisk->WriteSector(pEntry->start_lba + biosParameterBlock.ReservedSectors + (biosParameterBlock.NumOfFats * biosParameterBlock.SectorsPerFat32), zeroBuffer) != 0)
+        SetupError();
+
+    ///////////////////////
+    // Write Bios Parameter Block and FSInfo structure to disk
+    ///////////////////////
+    TextGUI::StatusBar("Writing BPB and FSInfo", 80);
+    if(selectedDisk->WriteSector(pEntry->start_lba, (uint8_t*)&biosParameterBlock) != 0)
+        SetupError();
+    if(selectedDisk->WriteSector(pEntry->start_lba + biosParameterBlock.FSInfoSector, (uint8_t*)&fsInfo) != 0)
+        SetupError();
+}
\ No newline at end of file
diff --git a/kernelz/src/installer/textgui.cpp b/kernelz/src/installer/textgui.cpp
new file mode 100644
index 0000000..366fa65
--- /dev/null
+++ b/kernelz/src/installer/textgui.cpp
@@ -0,0 +1,61 @@
+#include <installer/textgui.h>
+#include <common/types.h>
+#include <core/port.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+using namespace CactusOS::core;
+
+volatile uint16_t* videoMemory = (uint16_t*)0xC00B8000;
+
+void TextGUI::DisableCursor()
+{
+    outportb(0x3D4, 0x0A);
+	outportb(0x3D5, 0x20);
+}
+void TextGUI::SetPixel(int x, int y, char color, uint16_t character, char background)
+{
+    uint16_t attrib = (background << 4) | (color & 0x0F);
+    *(videoMemory + (y * VGA_WIDTH + x)) = character | (attrib << 8);
+}
+void TextGUI::ClearScreen(char color)
+{
+    for(int y = 0; y < VGA_HEIGHT; y++)
+        for(int x = 0; x < VGA_WIDTH; x++)
+                SetPixel(x, y, color, ' ');
+}
+void TextGUI::StatusBar(char* text, int percentage)
+{
+    for(int x = 0; x < VGA_WIDTH; x++)
+        SetPixel(x, VGA_HEIGHT - 1, TEXT_COLOR, ' ', VGA_COLOR_LIGHT_GREY);
+    
+    DrawString(text, 0, VGA_HEIGHT - 1, TEXT_COLOR, VGA_COLOR_LIGHT_GREY);
+
+    const int barWidth = 20; //Amount of characters for status bar
+    const int startX = VGA_WIDTH - barWidth - 1; //Start of progress bar
+    int width = ((double)percentage / 100.0) * (double)barWidth;
+
+    SetPixel(startX, VGA_HEIGHT - 1, VGA_COLOR_BLACK, '[', VGA_COLOR_LIGHT_GREY);
+    for(int i = 0; i < width; i++)
+        SetPixel(startX + i + 1, VGA_HEIGHT - 1, VGA_COLOR_BLACK, '#', VGA_COLOR_LIGHT_GREY);
+    
+    SetPixel(startX + barWidth, VGA_HEIGHT - 1, VGA_COLOR_BLACK, ']', VGA_COLOR_LIGHT_GREY);
+}
+void TextGUI::DrawString(char* text, int x, int y, char color, char background)
+{
+    int px = x;
+    int py = y;
+    for(int i = 0; text[i] != '\0'; ++i) {
+        switch(text[i]) {
+            case '\n':
+                px = x;
+                py += 1;
+                break;
+            default:
+                SetPixel(px, py, color, text[i], background);
+                px++;
+                break;
+        }
+    }
+}
\ No newline at end of file
diff --git a/kernelz/src/kernel.cpp b/kernelz/src/kernel.cpp
new file mode 100644
index 0000000..14bc051
--- /dev/null
+++ b/kernelz/src/kernel.cpp
@@ -0,0 +1,265 @@
+#include <multiboot/multiboot.h>
+#include <core/gdt.h>
+#include <core/tss.h>
+#include <core/idt.h>
+#include <core/physicalmemory.h>
+#include <core/virtualmemory.h>
+#include <system/bootconsole.h>
+#include <system/memory/heap.h>
+#include <system/memory/new.h>
+#include <system/system.h>
+#include <common/list.h>
+#include <common/print.h>
+#include <common/convert.h>
+#include <core/cpu.h>
+#include <core/fpu.h>
+#include <core/power.h>
+#include <installer/installer.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+extern "C" uint32_t _kernel_base;
+extern "C" uint32_t _kernel_end;
+extern "C" uint32_t _kernel_virtual_base;
+extern "C" uint32_t stack_top;
+
+typedef void (*constructor)();
+extern "C" constructor start_ctors;
+extern "C" constructor end_ctors;
+extern "C" void callConstructors()
+{
+    for(constructor* i = &start_ctors; i != &end_ctors; i++)
+        (*i)();
+}
+
+extern "C" void _set_debug_traps();
+
+PowerRequest powerRequestState;
+void IdleThread()
+{
+    powerRequestState = None;
+    uint64_t prevTicks = System::pit->Ticks();
+    while(1) {
+        uint64_t ticks = System::pit->Ticks();
+        if(System::usbManager)
+            System::usbManager->USBPoll();
+                
+        if(ticks - prevTicks > 500) {
+            if(System::apm->Enabled)
+                System::apm->CheckAndHandleEvents();
+
+            #if ENABLE_MEMORY_CHECKS
+            if(KernelHeap::CheckForErrors() == true) {
+                Log(Error, "Memory is not intact anymore, halting system!");
+                System::Panic();
+            }
+            #endif
+
+            prevTicks = ticks;
+        }
+
+        // Handle power state requests from userspace
+        // Processes can not do this themself because the first mb of memory is not mapped for them
+        // And that should not be the case due to security issues :)
+        if(powerRequestState == Reboot) {
+            Power::Reboot();
+        }
+        if(powerRequestState == Shutdown) {
+            Power::Poweroff();
+        }
+#if ENABLE_ADV_DEBUG
+        // If we are sending messages over the serial port that don't go to gdb
+        // We can send debug statistics to the debugging system
+        if(Serialport::Initialized && !System::gdbEnabled) {
+            System::kernelDebugger->Update();
+        }
+
+        // Calculate system utilisation by measuring how much the idle process is active
+        System::statistics.idleProcCounter += 1;
+        if (ticks - System::statistics.idleProcStartTime > 1000) {
+            System::statistics.idleProcActive = System::statistics.idleProcCounter;
+            System::statistics.idleProcCounter = 0;
+            System::statistics.idleProcStartTime = ticks;
+        }
+#endif
+        // Move onto other threads since there is nothing else to do here
+        System::scheduler->ForceSwitch();
+    }
+}
+
+extern "C" void kernelMain(const multiboot_info_t* mbi, unsigned int multiboot_magic)
+{
+    // Basic kernel information gathered from the linker script
+    uint32_t kernel_base = (uint32_t) &_kernel_base;
+    uint32_t kernel_end = (uint32_t) &_kernel_end;
+    uint32_t kernel_size = kernel_end - kernel_base;
+
+    //////////////
+    // Check Kernel Arguments
+    //////////////
+    const char* args = (const char*)phys2virt(mbi->cmdline);
+
+    if(String::strncmp(args, "gdb", 4)) {
+        System::gdbEnabled = true;
+        
+        Serialport::Init(COM1); // Init serial port
+        BootConsole::Init(false); // But don't use it for debug messages
+    }
+    else if(String::strncmp(args, "serial", 7))
+        BootConsole::Init(true);
+
+    BootConsole::ForegroundColor = VGA_COLOR_BLUE;
+    BootConsole::BackgroundColor = VGA_COLOR_LIGHT_GREY;
+    BootConsole::Clear();
+
+    if(multiboot_magic != MULTIBOOT_BOOTLOADER_MAGIC)
+    {
+        BootConsole::WriteLine("Error: not booted by a multiboot bootloader");
+        return;
+    }
+
+    BootConsole::WriteLine("Starting Kernel");
+    BootConsole::Write("Built on: "); BootConsole::WriteLine(__DATE__ "  " __TIME__);
+
+    BootConsole::Write("Kernel virtual base: 0x"); Print::printfHex32(_kernel_virtual_base); BootConsole::WriteLine();
+    BootConsole::Write("Kernel Base: 0x"); Print::printfHex32(kernel_base); BootConsole::WriteLine();
+    BootConsole::Write("Kernel End: 0x"); Print::printfHex32(kernel_end); BootConsole::WriteLine();
+    BootConsole::Write("Kernel Size: "); BootConsole::Write(Convert::IntToString(kernel_size / 1_KB)); BootConsole::Write(" Kb      ("); BootConsole::Write(Convert::IntToString(kernel_size)); BootConsole::WriteLine(")");
+
+    BootConsole::Write("GRUB Command Line Arguments: ");
+    BootConsole::WriteLine((char*)phys2virt(mbi->cmdline));
+
+    BootConsole::Write("Boot Device: "); Print::printfHex((mbi->boot_device & 0xFF000000) >> 24);
+    BootConsole::WriteLine();
+
+    GlobalDescriptorTable::Init();
+    BootConsole::WriteLine("GDT Loaded");
+
+    TSS::Install(5, 0x10, (uint32_t)&stack_top);
+    BootConsole::WriteLine("TSS Loaded");
+
+    InterruptDescriptorTable::Install();
+    BootConsole::WriteLine("IDT Loaded");
+
+    if (System::gdbEnabled) {
+        BootConsole::WriteLine("Starting GDB Interrupts");
+        _set_debug_traps();
+
+        InterruptDescriptorTable::EnableInterrupts();
+        
+        BootConsole::WriteLine("Waiting for GDB connection");
+        GDB_BREAK();
+    }
+
+    PhysicalMemoryManager::Initialize(mbi->mem_upper * 1_KB, kernel_end);
+    BootConsole::WriteLine("Physical Memory Loaded");
+
+    BootConsole::WriteLine("Reading CPU Info");
+    CPU::PrintVendor();
+    CPU::EnableFeatures();
+
+    BootConsole::WriteLine("Enabling FPU");
+    FPU::Enable();
+
+    // Parse the memory map handled by grub
+    PhysicalMemoryManager::ParseMemoryMap(mbi);
+
+    // Protect the first 1mb of physical memory + the end of kernel. 
+    // We also add the size of the bitmap so that it does not have to be staticly allocated, this makes the kernel way smaller. 
+    // Also round it to page bounds.
+    PhysicalMemoryManager::SetRegionUsed(0x0, pageRoundUp(1_MB + kernel_size + PhysicalMemoryManager::GetBitmapSize()));
+    PhysicalMemoryManager::SetRegionUsed(*(uint32_t*)phys2virt(mbi->mods_addr), *(uint32_t*)phys2virt(mbi->mods_addr + 4) - *(uint32_t*)phys2virt(mbi->mods_addr));
+
+    InterruptDescriptorTable::EnableInterrupts();
+    BootConsole::WriteLine("Interrupts Enabled");
+
+    VirtualMemoryManager::Initialize();
+    BootConsole::WriteLine("Virtual Memory Loaded");
+
+    KernelHeap::Initialize(KERNEL_HEAP_START, KERNEL_HEAP_START + KERNEL_HEAP_SIZE);
+    Log(Info, "Kernel Heap Initialized");
+
+    // From here we (should) only use the Log function for logging
+    Log(Info, "Switching to log function based output");
+
+    Power::Initialize();
+    Log(Info, "Power Control Loaded");
+
+    Log(Info, "Passing mbi to system");
+    System::mbi = (multiboot_info_t*)KernelHeap::malloc(sizeof(multiboot_info_t));
+    MemoryOperations::memcpy(System::mbi, mbi, sizeof(multiboot_info_t));
+
+    BootConsole::ForegroundColor = VGA_COLOR_MAGENTA;
+    Log(Info, "-Kernel core intialized-");
+
+    // Further intialisation is done in the system class
+    System::Start();
+
+    Log(Info, "Loading Kernel Process");
+    Process* kernelProcess = ProcessHelper::CreateKernelProcess();
+    kernelProcess->Threads.push_back(ThreadHelper::CreateFromFunction(IdleThread, true));
+    kernelProcess->Threads[0]->parent = kernelProcess;
+    System::scheduler->AddThread(kernelProcess->Threads[0], false);
+
+    // Check if we have found the directory with all the required stuff
+    if(System::vfs->bootPartitionID == -1) {
+        Log(Error, "Boot partition not found/present");
+        
+        // Just start running the idle thread so we at least detect device changes
+        System::scheduler->ForceSwitch();
+    }
+
+    // Check if kernel is run from HardDisk
+    // If not than ask the user if they would like to run the installer
+    // Otherwise we run the liveCD
+    if(System::vfs->Filesystems->GetAt(System::vfs->bootPartitionID)->disk->type != HardDisk) {
+        // Prompt user
+        BootConsole::ForegroundColor = VGA_COLOR_BLUE;
+        System::setupMode = true;
+        BootConsole::WriteLine("Press Enter to run Installer\nStarting LiveCD in 5 seconds....");
+
+        int timeout = 0;
+        while(System::keyboardManager->Available() == 0 && timeout < 5000) {
+            System::pit->Sleep(100);
+            timeout += 100;
+            BootConsole::Write("#");
+        }
+        BootConsole::WriteLine();
+
+        if(System::keyboardManager->Available() > 0) { // User pressed key
+            uint8_t keyCode = System::keyboardManager->Read();    
+            
+            if(keyCode == KEY_ENTER) { // Return key
+                BootConsole::WriteLine("Running Installer...");
+                Installer::Run();
+            }
+        }
+        BootConsole::ForegroundColor = VGA_COLOR_BLACK;
+        BootConsole::WriteLine("Running LiveCD....");
+        System::setupMode = false;
+    }
+
+    Log(Info, "Loading Init.bin");
+    Process* proc = ProcessHelper::Create("B:\\apps\\init.bin");
+    if(proc != 0)
+    {
+        if(System::gfxDevice->SelectBestVideoMode() == false) {
+            Log(Error, "Could not set a video mode, halting system");
+            System::Panic();
+        }
+
+        Log(Info, "Switched to graphics mode, phys=%x", System::gfxDevice->framebufferPhys);
+        System::screenMode = ScreenMode::GraphicsMode;
+
+        System::systemInfo->MouseX = System::gfxDevice->width/2;
+        System::systemInfo->MouseY = System::gfxDevice->height/2;
+
+        System::scheduler->AddThread(proc->Threads[0], true);
+    }
+    
+    Log(Error, "Could not load process init.bin, halting system");
+    System::Panic();
+}
\ No newline at end of file
diff --git a/kernelz/src/system/bootconsole.cpp b/kernelz/src/system/bootconsole.cpp
new file mode 100644
index 0000000..0b4ff8f
--- /dev/null
+++ b/kernelz/src/system/bootconsole.cpp
@@ -0,0 +1,137 @@
+#include <system/bootconsole.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+/*/////////////////
+// Static variable initialisations
+/*/////////////////
+int BootConsole::XOffset = 0;
+int BootConsole::YOffset = 0;
+uint8_t BootConsole::BackgroundColor = VGA_COLOR_BLACK; //Default console background color
+uint8_t BootConsole::ForegroundColor = VGA_COLOR_WHITE; //Default console foreground color
+bool BootConsole::writeToSerial = false;
+
+/*/////////////////
+// Variables
+/*/////////////////
+static uint16_t* videoMemory = (uint16_t*)0xC00B8000;
+
+
+/*/////////////////
+// Private functions
+/*/////////////////
+void BootConsole::Scroll()
+{
+    for(int i = 0; i < 24; i++){
+        for (int m = 0; m < 80; m++){
+            videoMemory[i * 80 + m] = videoMemory[(i + 1) * 80 + m];
+        }
+    }
+
+    for(int x = 0; x < 80; x++)
+    {
+        uint16_t attrib = (BackgroundColor << 4) | (ForegroundColor & 0x0F);
+        volatile uint16_t * where;
+        where = (volatile uint16_t *)videoMemory + (24 * VGA_WIDTH + x) ;
+        *where = ' ' | (attrib << 8);
+    }
+}
+
+
+
+/*/////////////////
+// Public functions
+/*/////////////////
+void BootConsole::Init(bool enableSerial)
+{
+    BootConsole::writeToSerial = enableSerial;
+    if(enableSerial)
+    {
+        Serialport::Init(COMPort::COM1);
+        BootConsole::WriteLine("Start of serial log for CactusOS");
+    }
+}
+
+void BootConsole::Write(char c)
+{
+    static char* str = " ";
+    str[0] = c;
+    Write(str);
+}
+
+void BootConsole::Write(char* str)
+{
+    if (writeToSerial)
+        Serialport::WriteStr(str);
+
+    for(int i = 0; str[i] != '\0'; ++i)
+    {
+        switch(str[i])
+        {
+            case '\n':
+                XOffset = 0;
+                YOffset++;
+                break;
+            case '\t':
+                Write("    "); //4 spaces for tab
+                break;
+            default:
+                uint16_t attrib = (BackgroundColor << 4) | (ForegroundColor & 0x0F);
+                volatile uint16_t * where;
+                where = (volatile uint16_t *)videoMemory + (YOffset * 80 + XOffset) ;
+                *where = str[i] | (attrib << 8);
+                XOffset++;
+                break;
+        }
+
+        if(XOffset >= 80)
+        {
+            XOffset = 0;
+            YOffset++;
+        }
+
+        if(YOffset >= 25)
+        {
+            Scroll();
+            XOffset = 0;
+            YOffset = 24;
+        }
+    }
+}
+void BootConsole::WriteLine(char* str)
+{
+    BootConsole::Write(str);
+    BootConsole::Write("\n");
+}
+void BootConsole::WriteLine()
+{
+    BootConsole::Write("\n");
+}
+void BootConsole::Clear()
+{
+    for(int y = 0; y < VGA_HEIGHT; y++)
+        for(int x = 0; x < VGA_WIDTH; x++) {
+                uint16_t attrib = (BackgroundColor << 4) | (ForegroundColor & 0x0F);
+                volatile uint16_t * where;
+                where = (volatile uint16_t *)videoMemory + (y * VGA_WIDTH + x) ;
+                *where = ' ' | (attrib << 8);
+        }
+
+    XOffset = 0;
+    YOffset = 0;
+}
+uint16_t* BootConsole::GetBuffer()
+{
+    return videoMemory;
+}
+
+void BootConsole::SetX(int x)
+{
+    XOffset = x;
+}
+void BootConsole::SetY(int y)
+{
+    YOffset = y;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/components/apm.cpp b/kernelz/src/system/components/apm.cpp
new file mode 100644
index 0000000..6ee93cb
--- /dev/null
+++ b/kernelz/src/system/components/apm.cpp
@@ -0,0 +1,118 @@
+#include <system/components/apm.h>
+
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+APMController::APMController()
+: SystemComponent("APM Controller", "Controls Advanced Power Management via BIOS calls")
+{
+    Log(Info, "Initializing APM Controller");
+    this->Enabled = false;
+
+    // Check if APM is even availible
+    VM86Arguments args;
+    MemoryOperations::memset(&args, 0, sizeof(VM86Arguments));
+    args.AX = (uint16_t)0x5300 | (uint16_t)APM_FUNC_INSTALL_CHECK;
+    System::vm86Manager->CallInterrupt(0x15, &args);
+
+    if(args.BX == APM_SIGNATURE)
+        Log(Info, "APM %d.%d Present", (args.AX & 0xFF00) >> 8, (args.AX & 0x00FF));
+    else {
+        Log(Info, "APM not found on system, error = %b", (args.AX & 0xFF00) >> 8);
+        return;
+    }
+
+    // Disconnect any interface
+    MemoryOperations::memset(&args, 0, sizeof(VM86Arguments));
+    args.AX = (uint16_t)0x5300 | (uint16_t)APM_FUNC_DISCONNECT;
+    System::vm86Manager->CallInterrupt(0x15, &args);
+
+    // Connect to APM BIOS Interface
+    MemoryOperations::memset(&args, 0, sizeof(VM86Arguments));
+    args.AX = (uint16_t)0x5300 | (uint16_t)APM_FUNC_CONNECT_REALMODE;
+    System::vm86Manager->CallInterrupt(0x15, &args);
+
+    // Set driver version to 1.2
+    MemoryOperations::memset(&args, 0, sizeof(VM86Arguments));
+    args.AX = (uint16_t)0x5300 | (uint16_t)APM_FUNC_DRIVER_VERSION;
+    args.CX = 0x0102;
+    System::vm86Manager->CallInterrupt(0x15, &args);
+    if(args.AX != 0x0102) { //Error setting version 1.2
+        Log(Error, "Could not set APM to version 1.2. Error = %b", (args.AX & 0xFF00) >> 8);
+        return;
+    }
+
+    // Enable power management for all devices
+    MemoryOperations::memset(&args, 0, sizeof(VM86Arguments));
+    args.AX = (uint16_t)0x5300 | (uint16_t)APM_FUNC_ENABLE_POWER_MANAGEMENT;
+    args.BX = APM_ALL_DEVICE; //All Devices
+    args.CX = 0x1; //Enable power control by APM BIOS
+    System::vm86Manager->CallInterrupt(0x15, &args);
+
+    // Apply some OS specific settings
+    DisableRingIndicator();
+    DisableResumeTimer();
+
+    // Indicate that power management is enabled
+    this->Enabled = true;
+}
+void APMController::CheckAndHandleEvents()
+{
+    //Log(Info, "APM Event check");
+
+    // Request Event info from BIOS
+    VM86Arguments args;
+    MemoryOperations::memset(&args, 0, sizeof(VM86Arguments));
+    args.AX = (uint16_t)0x5300 | (uint16_t)APM_FUNC_GET_PM_EVENT;
+    System::vm86Manager->CallInterrupt(0x15, &args);
+
+    uint8_t errorCode = (args.AX & 0xFF00) >> 8;
+    if(errorCode == 0x3 || errorCode == 0xB || errorCode == 0x80) // Error or no events
+        return;
+    
+    uint16_t eventCode = args.BX;
+    Log(Info, "APM Event %w", eventCode);
+
+    switch(eventCode)
+    {
+        case 0x000A: //Suspend Request from user
+            SetPowerState(APM_ALL_DEVICE, APM_POWER_REJECT); //TODO: Implement proper suspend. Right now system wakes up again after a few seconds.
+            break;
+        case 0x0003: //Normal Resume System Notification
+            
+            break;
+        default:
+            break;
+    }
+
+
+    // Check for remaining events until error
+    CheckAndHandleEvents();
+}
+void APMController::SetPowerState(uint16_t device, uint8_t state)
+{
+    VM86Arguments args;
+    MemoryOperations::memset(&args, 0, sizeof(VM86Arguments));
+    args.AX = (uint16_t)0x5300 | (uint16_t)APM_FUNC_SET_POWER_STATE;
+    args.BX = device;
+    args.CX = state;
+    System::vm86Manager->CallInterrupt(0x15, &args);
+}
+void APMController::DisableResumeTimer()
+{
+    VM86Arguments args;
+    MemoryOperations::memset(&args, 0, sizeof(VM86Arguments));
+    args.AX = (uint16_t)0x5300 | (uint16_t)APM_FUNC_SET_RESUME_TIMER;
+    System::vm86Manager->CallInterrupt(0x15, &args);
+}
+void APMController::DisableRingIndicator()
+{
+    VM86Arguments args;
+    MemoryOperations::memset(&args, 0, sizeof(VM86Arguments));
+    args.AX = (uint16_t)0x5300 | (uint16_t)APM_FUNC_SET_RESUME_RING;
+    System::vm86Manager->CallInterrupt(0x15, &args);
+}
\ No newline at end of file
diff --git a/kernelz/src/system/components/bochsvbe.cpp b/kernelz/src/system/components/bochsvbe.cpp
new file mode 100644
index 0000000..df4b0a4
--- /dev/null
+++ b/kernelz/src/system/components/bochsvbe.cpp
@@ -0,0 +1,60 @@
+/*
+https://wiki.osdev.org/Bochs_VBE_Extensions
+*/ 
+
+#include <system/components/bochsvbe.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+using namespace CactusOS::core;
+
+BochsVBE::BochsVBE()
+: GraphicsDevice("Bochs VBE Adapter"),
+SystemComponent("BOCHS VBE", "Bochs VBE Extensions")
+{ }
+
+void WriteRegister(uint16_t IndexValue, uint16_t DataValue)
+{
+    outportw(VBE_DISPI_IOPORT_INDEX, IndexValue);
+    outportw(VBE_DISPI_IOPORT_DATA, DataValue);
+}
+ 
+uint16_t ReadRegister(uint16_t IndexValue)
+{
+    outportw(VBE_DISPI_IOPORT_INDEX, IndexValue);
+    return inportw(VBE_DISPI_IOPORT_DATA);
+}
+ 
+bool BochsVBE::IsAvailable()
+{
+    uint16_t id = ReadRegister(VBE_DISPI_INDEX_ID);
+    return (id >= VBE_DISPI_ID0 && id <= VBE_DISPI_ID5);
+}
+ 
+void SetVideoMode(uint32_t Width, uint32_t Height, uint32_t BitDepth, int UseLinearFrameBuffer, int ClearVideoMemory)
+{
+    WriteRegister(VBE_DISPI_INDEX_ENABLE, VBE_DISPI_DISABLED);
+    WriteRegister(VBE_DISPI_INDEX_XRES, Width);
+    WriteRegister(VBE_DISPI_INDEX_YRES, Height);
+    WriteRegister(VBE_DISPI_INDEX_BPP, BitDepth);
+    WriteRegister(VBE_DISPI_INDEX_ENABLE, VBE_DISPI_ENABLED |
+        (UseLinearFrameBuffer ? VBE_DISPI_LFB_ENABLED : 0) |
+        (ClearVideoMemory ? 0 : VBE_DISPI_NOCLEARMEM));
+}
+            
+bool BochsVBE::SelectBestVideoMode()
+{
+    if(!IsAvailable())
+        return false;
+    
+    SetVideoMode(VBE_DISPI_MAX_XRES, VBE_DISPI_MAX_YRES, 32, true, true);
+
+    this->width = VBE_DISPI_MAX_XRES;
+    this->height = VBE_DISPI_MAX_YRES;
+    this->bpp = 32;
+    this->framebufferPhys = VBE_DISPI_LFB_PHYSICAL_ADDRESS;
+
+    return true;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/components/dma.cpp b/kernelz/src/system/components/dma.cpp
new file mode 100644
index 0000000..e2dcf96
--- /dev/null
+++ b/kernelz/src/system/components/dma.cpp
@@ -0,0 +1,126 @@
+#include <system/components/dma.h>
+
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+DMAController::DMAController()
+: SystemComponent("Direct Memory Access Controller (DMA)", "Controller for the legacy Intel 8237 DMA chip")
+{
+
+}
+
+void DMAController::SetChannelAddress(uint8_t channel, uint8_t low, uint8_t high)
+{
+    if (channel > 8)
+		return;
+
+	uint16_t port = 0;
+	switch ( channel ) {
+
+		case 0: {port = DMA0_CHAN0_ADDR_REG; break;}
+		case 1: {port = DMA0_CHAN1_ADDR_REG; break;}
+		case 2: {port = DMA0_CHAN2_ADDR_REG; break;}
+		case 3: {port = DMA0_CHAN3_ADDR_REG; break;}
+		case 4: {port = DMA1_CHAN4_ADDR_REG; break;}
+		case 5: {port = DMA1_CHAN5_ADDR_REG; break;}
+		case 6: {port = DMA1_CHAN6_ADDR_REG; break;}
+		case 7: {port = DMA1_CHAN7_ADDR_REG; break;}
+	}
+
+	outportb(port, low);
+	outportb(port, high);
+}
+void DMAController::SetChannelCounter(uint8_t channel, uint8_t low, uint8_t high)
+{
+	if (channel > 8)
+		return;
+
+	uint16_t port = 0;
+	switch ( channel ) {
+
+		case 0: {port = DMA0_CHAN0_COUNT_REG; break;}
+		case 1: {port = DMA0_CHAN1_COUNT_REG; break;}
+		case 2: {port = DMA0_CHAN2_COUNT_REG; break;}
+		case 3: {port = DMA0_CHAN3_COUNT_REG; break;}
+		case 4: {port = DMA1_CHAN4_COUNT_REG; break;}
+		case 5: {port = DMA1_CHAN5_COUNT_REG; break;}
+		case 6: {port = DMA1_CHAN6_COUNT_REG; break;}
+		case 7: {port = DMA1_CHAN7_COUNT_REG; break;}
+	}
+
+	outportb(port, low);
+	outportb(port, high);
+}
+void DMAController::SetExternalPageRegister(uint8_t reg, uint8_t val)
+{
+	if (reg > 14)
+		return;
+
+	uint16_t port = 0;
+	switch ( reg ) {
+
+		case 1: {port = DMA_PAGE_CHAN1_ADDRBYTE2; break;}
+		case 2: {port = DMA_PAGE_CHAN2_ADDRBYTE2; break;}
+		case 3: {port = DMA_PAGE_CHAN3_ADDRBYTE2; break;}
+		case 4: {return;}//! nothing should ever write to register 4
+		case 5: {port = DMA_PAGE_CHAN5_ADDRBYTE2; break;}
+		case 6: {port = DMA_PAGE_CHAN6_ADDRBYTE2; break;}
+		case 7: {port = DMA_PAGE_CHAN7_ADDRBYTE2; break;}
+	}
+
+	outportb(port, val);
+}
+void DMAController::SetChannelMode(uint8_t channel, uint8_t mode)
+{
+
+	int dma = (channel < 4) ? 0 : 1;
+	int chan = (dma==0) ? channel : channel-4;
+
+	MaskChannel(channel);
+	outportb ((channel < 4) ? (uint16_t)(DMA0_MODE_REG) : (uint16_t)(DMA1_MODE_REG), chan | (mode));
+	UnmaskAll(dma);
+}
+void DMAController::ChannelPrepareRead(uint8_t channel)
+{
+	SetChannelMode(channel, DMA_MODE_READ_TRANSFER | DMA_MODE_TRANSFER_SINGLE | DMA_MODE_MASK_AUTO);
+}
+void DMAController::ChannelPrepareWrite(uint8_t channel)
+{
+	SetChannelMode(channel, DMA_MODE_WRITE_TRANSFER | DMA_MODE_TRANSFER_SINGLE | DMA_MODE_MASK_AUTO);
+}
+void DMAController::MaskChannel(uint8_t channel)
+{
+	if (channel <= 4)
+		outportb(DMA0_CHANMASK_REG, (1 << (channel-1)));
+	else
+		outportb(DMA1_CHANMASK_REG, (1 << (channel-5)));
+}
+void DMAController::UnmaskChannel(uint8_t channel)
+{
+	if (channel <= 4)
+		outportb(DMA0_CHANMASK_REG, channel);
+	else
+		outportb(DMA1_CHANMASK_REG, channel);
+}
+void DMAController::ResetFlipFlop(int dma)
+{
+	if (dma < 2)
+		return;
+
+	//! it doesnt matter what is written to this register
+	outportb((dma == 0) ? (uint16_t)(DMA0_CLEARBYTE_FLIPFLOP_REG) : (uint16_t)(DMA1_CLEARBYTE_FLIPFLOP_REG), 0xff);
+}
+void DMAController::Reset(int dma)
+{
+	//! it doesnt matter what is written to this register
+	outportb(DMA0_TEMP_REG, 0xff);
+}
+void DMAController::UnmaskAll(int dma)
+{
+	//! it doesnt matter what is written to this register
+	outportb(DMA1_UNMASK_ALL_REG, 0xff);
+}
\ No newline at end of file
diff --git a/kernelz/src/system/components/edid.cpp b/kernelz/src/system/components/edid.cpp
new file mode 100644
index 0000000..eaf9833
--- /dev/null
+++ b/kernelz/src/system/components/edid.cpp
@@ -0,0 +1,120 @@
+#include <system/components/edid.h>
+
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+uint8_t* edidBuffer = 0;
+
+EDID::EDID()
+: SystemComponent("EDID", "Mechanism to acquire monitor information")
+{
+    edidBuffer = 0;
+}
+
+bool EDIDCheckChecksum()
+{
+    const char* data = (const char *)edidBuffer;
+    char checksum = 0;
+
+    /* Check EDID checksum.  */
+    for (int i = 0; i < 128; ++i)
+        checksum += data[i];
+
+    if (checksum != 0)
+        return false;
+
+    return true;
+}
+
+void EDID::AcquireEDID()
+{
+    VM86Arguments args;
+    MemoryOperations::memset(&args, 0, sizeof(VM86Arguments));
+
+    Log(Info, "Checking if EDID is supported");
+    args.AX = 0x4F15;
+    System::vm86Manager->CallInterrupt(0x10, &args);
+
+    if(args.AX != EDID_SUCCES) {
+        Log(Info, "EDID Not supported, status = %w", args.AX);
+        return;
+    }
+
+    // Assign EDID buffer to area of memory within first 1MB
+    edidBuffer = (uint8_t*)0x7500;
+    MemoryOperations::memset(edidBuffer, 0, 128);
+    MemoryOperations::memset(&args, 0, sizeof(VM86Arguments));
+
+    args.AX = 0x4F15;
+    args.BX = 0x0001;
+    args.DI = 0x7500;
+
+    Log(Info, "Reading EDID via BIOS/VBE");
+    System::vm86Manager->CallInterrupt(0x10, &args);
+    
+    if((args.AX & 0x00FF) != 0x4F) {
+        Log(Info, "Read EDID Failed, status = %w", args.AX);
+        edidBuffer = 0; //Reset buffer
+        return;
+    }
+
+    Log(Info, "Checking if EDID makes sense");
+    if(EDIDCheckChecksum() == false) {
+        Log(Info, "EDID Checksum incorrect");
+        edidBuffer = 0; //Reset buffer
+        return;
+    }
+
+    const uint8_t edidHeader[] = {0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00};
+    if(MemoryOperations::memcmp(edidBuffer, edidHeader, 8) != 0) {
+        Log(Info, "EDID Header incorrect");
+        edidBuffer = 0; //Reset buffer
+        return;
+    }
+
+    //////////////
+    // Start Parsing Data
+    //////////////
+    EDIDInfoBlock* info = (EDIDInfoBlock*)edidBuffer;
+    Log(Info, "EDID Structure Version %d.%d", info->version, info->revision);
+    for(int i = 0; i < 4; i++) { //Loop through descriptors
+        switch(info->detailed_timings[i].dataType) {
+            case 0xFF: //Monitor Serial Number - Stored as ASCII
+                Log(Info, "Monitor Serial: %s", info->detailed_timings[i].descriptorData);
+                break;
+            case 0xFE: //ASCII String - Stored as ASCII
+                Log(Info, "ASCII String: %s", info->detailed_timings[i].descriptorData);
+                break;
+            case 0xFC: //Monitor Name, stored as ASCII
+                Log(Info, "Monitor Name: %s", info->detailed_timings[i].descriptorData);
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void EDID::PreferedMode(int* widthPtr, int* heightPtr)
+{
+    if(edidBuffer == 0) {
+        Log(Info, "EDID: Could not find prefered mode since edid is not loaded");
+        return;
+    }
+    
+    EDIDInfoBlock* info = (EDIDInfoBlock*)edidBuffer;
+
+    if (info->version == 1 && (info->feature_support & (1<<1)) && info->detailed_timings[0].flag != 0)
+    {
+        TimingsInfoBlock* timing = (TimingsInfoBlock*)(info->detailed_timings);
+
+        *widthPtr = timing->horizontal_active_lo | (((unsigned int)(timing->horizontal_hi & 0xF0)) << 4);
+        *heightPtr = timing->vertical_active_lo | (((unsigned int)(timing->vertical_hi & 0xF0)) << 4);
+    }
+
+    if(*widthPtr == 0 || *heightPtr == 0)
+        Log(Info, "EDID: Could not find prefered mode, error parsing timings");
+}
\ No newline at end of file
diff --git a/kernelz/src/system/components/graphicsdevice.cpp b/kernelz/src/system/components/graphicsdevice.cpp
new file mode 100644
index 0000000..5391977
--- /dev/null
+++ b/kernelz/src/system/components/graphicsdevice.cpp
@@ -0,0 +1,46 @@
+#include <system/components/graphicsdevice.h>
+#include <system/components/bochsvbe.h>
+#include <system/components/vesa.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+GraphicsDevice::GraphicsDevice(char* name)
+{
+    this->width = 0;
+    this->height = 0;
+    this->bpp = 0;
+    this->identifier = name;
+}
+
+GraphicsDevice::~GraphicsDevice()
+{
+    
+}
+
+bool GraphicsDevice::SelectBestVideoMode()
+{
+    return false;
+}
+
+uint32_t GraphicsDevice::GetBufferSize()
+{
+	return this->width * this->height * (this->bpp/8);
+}
+
+//Select the best graphics device for the situation
+GraphicsDevice* GraphicsDevice::GetBestDevice()
+{
+    #if BOCHS_GFX_HACK
+    if(BochsVBE::IsAvailable() && System::isBochs)
+    {
+        //BootConsole::Write(" BochsVBE");
+        return new BochsVBE();
+    }
+    #endif
+    
+    //BootConsole::Write(" VESA");
+    return new VESA(System::vm86Manager);
+}
\ No newline at end of file
diff --git a/kernelz/src/system/components/pci.cpp b/kernelz/src/system/components/pci.cpp
new file mode 100644
index 0000000..d97713c
--- /dev/null
+++ b/kernelz/src/system/components/pci.cpp
@@ -0,0 +1,234 @@
+#include <system/components/pci.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+bool PCIController::DeviceHasFunctions(uint16_t bus, uint16_t device)
+{
+    return Read(bus, device, 0, 0x0E) & (1<<7);
+}
+
+uint32_t PCIController::Read(uint16_t bus, uint16_t device, uint16_t function, uint32_t registeroffset)
+{
+    uint32_t id =
+        0x1 << 31
+        | ((bus & 0xFF) << 16)
+        | ((device & 0x1F) << 11)
+        | ((function & 0x07) << 8)
+        | (registeroffset & 0xFC);
+    outportl(0xCF8, id);
+    uint32_t result = inportl(0xCFC);
+    return result >> (8* (registeroffset % 4));
+}
+
+void PCIController::Write(uint16_t bus, uint16_t device, uint16_t function, uint32_t registeroffset, uint32_t value)
+{
+    uint32_t id =
+        0x1 << 31
+        | ((bus & 0xFF) << 16)
+        | ((device & 0x1F) << 11)
+        | ((function & 0x07) << 8)
+        | (registeroffset & 0xFC);
+    outportl(0xCF8, id);
+    outportl(0xCFC, value); 
+}
+
+
+PCIController::PCIController()
+: SystemComponent("PCI", "Peripheral Component Interconnect")
+{
+    this->deviceList.Clear();
+}
+
+
+void PCIController::PopulateDeviceList()
+{
+    Log(Info, "Scanning for PCI Devices");
+
+    for(int bus = 0; bus < 256; bus++)
+    {
+        for(int device = 0; device < 32; device++)
+        {
+            int numFunctions = DeviceHasFunctions(bus, device) ? 8 : 1;
+            for(int function = 0; function < numFunctions; function++)
+            {
+                uint16_t vendorID = Read(bus, device, function, 0x00);
+                if(vendorID == 0xFFFF)
+                    continue;
+
+                // Add pci device to list
+                PCIDevice* pciDevice = new PCIDevice();
+                pciDevice->bus = bus;
+                pciDevice->device = device;
+                pciDevice->function = function;
+
+                pciDevice->vendorID = vendorID;
+                pciDevice->deviceID = Read(bus, device, function, 0x02);
+
+                pciDevice->classID = Read(bus, device, function, 0x0B);
+                pciDevice->subclassID = Read(bus, device, function, 0x0A);
+                pciDevice->programmingInterfaceID = Read(bus, device, function, 0x09); 
+                pciDevice->revisionID = Read(bus, device, function, 0x08);
+                pciDevice->interrupt = Read(bus, device, function, 0x3C);
+
+                // Get the portBase from the base address registers
+                for(int barNum = 0; barNum < 6; barNum++)
+                {
+                    BaseAddressRegister bar = GetBaseAddressRegister(bus, device, function, barNum);
+                    if(bar.address && (bar.type == InputOutput))
+                        pciDevice->portBase = (uint32_t)bar.address;
+                }
+
+                // Read status byte from device
+                uint16_t status = (Read(bus, device, function, 0x04) & 0xFFFF0000) >> 16;
+                if(status & (1<<4)) { // There is a capabilities list
+                    uint8_t offset = Read(bus, device, function, 0x34) & 0xFF;
+                    offset &= ~(0b11);
+                    
+                    while(offset) {
+                        // Read value stored at offset, this contains ID, next offset and a feature specific uint16_t.
+                        uint32_t capValue1 = Read(bus, device, function, offset);
+
+                        // Extract ID from value read above
+                        uint8_t id = capValue1 & 0xFF;
+
+                        if(id == 1) // Power Management, see https://lekensteyn.nl/files/docs/PCI_Power_Management_12.pdf for details
+                        {
+                            // Read next 4 bytes of structure
+                            uint32_t capValue2 = Read(bus, device, function, offset + 4);
+
+                            //Log(Info, "CAP1 = %x    CAP2 = %x", capValue1, capValue2);
+
+                            // Extract PMCSR from value
+                            uint16_t powerValue = (capValue2 & 0xFFFF);
+                            
+                            // Powerstate is not D0 (Complete on)
+                            if((powerValue & 0b11) != 0) {
+                                powerValue &= ~(0b11); // Set it to D0
+                                powerValue |= (1<<15); // Also set PME Status bit (not sure why)
+                                Write(bus, device, function, offset + 4, (capValue2 & 0xFFFF0000) | powerValue);
+
+                                System::pit->Sleep(10);
+
+                                // Read second 4 bytes again to check if power on succeeded
+                                capValue2 = Read(bus, device, function, offset + 4);
+
+                                if((capValue2 & 0b11) != 0) // Power on failed
+                                    Log(Error, "Could not enable power for device %d:%d:%d", bus, device, function);
+                            }
+                        }
+
+                        offset = (capValue1 & 0xFF00) >> 8;
+                    } 
+                }
+
+                Log(Info, "%d:%d:%d %w:%w %s", bus, device, function, pciDevice->vendorID, pciDevice->deviceID, GetClassCodeString(pciDevice->classID, pciDevice->subclassID));
+                
+                deviceList.push_back(pciDevice);
+            }
+        }
+    }
+    BootConsole::Write("Found a total of: "); BootConsole::Write(Convert::IntToString(deviceList.size())); BootConsole::WriteLine(" Devices");
+}
+
+char* PCIController::GetClassCodeString(uint8_t classID, uint8_t subClassID)
+{
+    char* idString = "??:??"; 
+    char* classIDString = Convert::IntToHexString(classID);
+    char* subClassIDString = Convert::IntToHexString(subClassID);
+
+    idString[0] = classIDString[0];
+    idString[1] = classIDString[1];
+
+    idString[3] = subClassIDString[0];
+    idString[4] = subClassIDString[1];
+
+    uint32_t lookupTableSize = 0;
+    char* lookupTable = (char*)InitialRamDisk::ReadFile("/PCI Class Codes.txt", &lookupTableSize);
+    if(lookupTable == 0 || lookupTableSize == 0) {
+        delete classIDString;
+        delete subClassIDString;
+        return "Database Error";
+    }
+
+    uint32_t tableIndex = 0;
+    while(tableIndex < lookupTableSize)
+    {
+        uint32_t strLength = 0;
+        char* refString = lookupTable + tableIndex;
+        while(*refString != '\n')
+        {
+            strLength++;
+            refString++;
+        }
+        if(String::strncmp(lookupTable + tableIndex, idString, 5)) //It is a match
+        {
+            char* returnString = new char[strLength + 1];
+            MemoryOperations::memcpy(returnString, lookupTable + tableIndex, strLength);
+            returnString[strLength] = '\0';
+
+            delete classIDString;
+            delete subClassIDString;
+            return returnString;
+        }
+
+        tableIndex += strLength + 1;
+    }
+
+    delete classIDString;
+    delete subClassIDString;
+    return "Unkown";
+}
+
+BaseAddressRegister PCIController::GetBaseAddressRegister(uint16_t bus, uint16_t device, uint16_t function, uint16_t bar)
+{
+    BaseAddressRegister result;
+    MemoryOperations::memset(&result, 0, sizeof(BaseAddressRegister));
+
+    uint32_t barRegister = 0x10 + (bar * sizeof(uint32_t));
+    uint32_t barValue = Read(bus, device, function, barRegister);
+
+    if(barValue == 0)
+        return result;
+    
+    uint32_t headertype = Read(bus, device, function, 0x0E) & 0x7F;
+    int maxBARs = 6 - (4*headertype);
+    if(bar >= maxBARs)
+        return result;
+
+    //Get The size of the BAR
+    Write(bus, device, function, barRegister, 0xffffffff);
+    uint32_t sizeMask = Read(bus, device, function, barRegister);
+    //Write back the original value
+    Write(bus, device, function, barRegister, barValue);
+
+    //Fill in the structure
+    result.type = (barValue & 0x1) ? InputOutput : MemoryMapping;
+
+    if(result.type == MemoryMapping)
+    {
+        switch((barValue >> 1) & 0x3)
+        {
+            case 0: // 32 Bit Mode
+                result.address = (uint32_t)(uintptr_t)(barValue & ~0xf);
+                result.size = ~(sizeMask & ~0xf) + 1;
+                result.prefetchable = barValue & 0x8;
+                break;
+            case 2: // 64 Bit Mode
+                result.size = ~(sizeMask & ~0xf) + 1;
+                result.prefetchable = barValue & 0x8;
+                BaseAddressRegister sBAR = GetBaseAddressRegister(bus, device, function, bar + 1);
+                result.address = ((uint32_t)(uintptr_t)(barValue & ~0xf) + ((sBAR.address & 0xFFFFFFFF) << 32));
+                break;
+        }   
+    }
+    else // InputOutput
+    {
+        result.address = (uint32_t)(barValue & ~0x3);
+        result.size = (uint16_t)(~(sizeMask & ~0x3) + 1);
+    }
+    return result;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/components/pit.cpp b/kernelz/src/system/components/pit.cpp
new file mode 100644
index 0000000..2db86a6
--- /dev/null
+++ b/kernelz/src/system/components/pit.cpp
@@ -0,0 +1,83 @@
+#include <system/components/pit.h>
+#include <core/idt.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+PIT::PIT()
+: SystemComponent("PIT", "Legacy Programmable Interval Timer"),
+InterruptHandler(IDT_INTERRUPT_OFFSET + 0)
+{
+    timer_ticks = 0;
+
+    uint64_t divisor = 1193180 / PIT_FREQUENCY; //Default is 1000 Hz
+
+    outportb(0x43, 0x34);
+    outportb(0x40, (uint8_t)divisor);
+    outportb(0x40, (uint8_t)(divisor >> 8));
+}
+
+uint32_t PIT::HandleInterrupt(uint32_t esp)
+{
+    timer_ticks++;
+
+    return esp;
+}
+void PIT::Sleep(uint32_t ms)
+{
+    uint64_t targetTicks = timer_ticks + ms;
+    while(timer_ticks < targetTicks)
+        asm ("hlt"); // Wait for next interrupt
+}
+
+
+void PIT::PlaySound(common::uint32_t nFrequence)
+{
+    uint32_t Div;
+ 	uint8_t tmp;
+ 
+    //Set the PIT to the desired frequency
+ 	Div = 1193180 / nFrequence;
+ 	outportb(0x43, 0xb6);
+ 	outportb(0x42, (uint8_t) (Div) );
+ 	outportb(0x42, (uint8_t) (Div >> 8));
+ 
+    //And play the sound using the PC speaker
+ 	tmp = inportb(0x61);
+  	if (tmp != (tmp | 3)) {
+ 		outportb(0x61, tmp | 3);
+ 	}
+}
+void PIT::NoSound()
+{
+    uint8_t tmp = inportb(0x61) & 0xFC;
+ 
+ 	outportb(0x61, tmp);
+}
+void PIT::Beep()
+{
+    Beep(800); //800 is default beep frequency
+}
+
+void PIT::Beep(common::uint32_t freq)
+{
+    Beep(freq, 200); //200 is default beep duration
+}
+void PIT::Beep(common::uint32_t freq, common::uint32_t duration)
+{
+    if(duration == 0)
+        return;
+    if(freq == 0)
+        return;
+
+    PlaySound(freq);
+ 	Sleep(duration);
+ 	NoSound();
+}
+
+uint64_t PIT::Ticks()
+{
+    return this->timer_ticks;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/components/rtc.cpp b/kernelz/src/system/components/rtc.cpp
new file mode 100644
index 0000000..291c790
--- /dev/null
+++ b/kernelz/src/system/components/rtc.cpp
@@ -0,0 +1,92 @@
+#include <system/components/rtc.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+bool RTC::UpdateInProgress()
+{
+    outportb(0x70, 0x0A);
+    return (inportb(0x71) & 0x80);
+}
+uint8_t RTC::ReadRegister(int reg)
+{
+    outportb(0x70, reg);
+    return inportb(0x71);
+}
+
+RTC::RTC()
+: SystemComponent("RTC", "Legacy Real Time Clock")
+{   }
+
+uint32_t RTC::GetSecond()
+{
+    while(UpdateInProgress());
+    uint32_t value = ReadRegister(0x00);
+    uint32_t registerB = ReadRegister(0x0B);
+
+    if(!(registerB & 0x04))
+        value = (value & 0x0F) + ((value / 16) * 10);
+    return value;
+}
+uint32_t RTC::GetMinute()
+{
+    while(UpdateInProgress());
+    uint32_t value = ReadRegister(0x02);
+    uint32_t registerB = ReadRegister(0x0B);
+
+    if(!(registerB & 0x04))
+        value = (value & 0x0F) + ((value / 16) * 10);
+    return value;
+}
+uint32_t RTC::GetHour()
+{
+    while(UpdateInProgress());
+    uint32_t value = ReadRegister(0x04);
+    uint32_t registerB = ReadRegister(0x0B);
+
+    if(!(registerB & 0x04))
+        value = ((value & 0x0F) + (((value & 0x70) / 16) * 10) ) | (value & 0x80);
+    
+    if(!(registerB & 0x02) && (value & 0x80))
+        value = ((value & 0x7F) + 12) % 24;
+
+    return value;
+}
+uint32_t RTC::GetDay()
+{
+    while(UpdateInProgress());
+    uint32_t value = ReadRegister(0x07);
+    uint32_t registerB = ReadRegister(0x0B);
+
+    if(!(registerB & 0x04))
+        value = (value & 0x0F) + ((value / 16) * 10);
+    return value;
+}
+uint32_t RTC::GetMonth()
+{
+    while(UpdateInProgress());
+    uint32_t value = ReadRegister(0x08);
+    uint32_t registerB = ReadRegister(0x0B);
+
+    if(!(registerB & 0x04))
+        value = (value & 0x0F) + ((value / 16) * 10);
+    return value;
+}
+uint32_t RTC::GetYear()
+{
+    while(UpdateInProgress());
+    uint32_t value = ReadRegister(0x09);
+    uint32_t registerB = ReadRegister(0x0B);
+
+    if(!(registerB & 0x04))
+        value = (value & 0x0F) + ((value / 16) * 10);
+    
+    // Calculate the full (4-digit) year
+    value += (CURRENT_YEAR / 100) * 100;
+    if(value < CURRENT_YEAR)
+        value += 100;
+
+    return value;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/components/smbios.cpp b/kernelz/src/system/components/smbios.cpp
new file mode 100644
index 0000000..1966842
--- /dev/null
+++ b/kernelz/src/system/components/smbios.cpp
@@ -0,0 +1,141 @@
+#include <system/components/smbios.h>
+#include <system/system.h>
+#include <system/listings/systeminfo.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+char* SMBIOS::CopyString(char* src)
+{
+    int len = String::strlen(src);
+    char* ret = new char[len + 1];
+    MemoryOperations::memcpy(ret, src, len);
+    ret[len] = '\0';
+    return ret;
+}
+
+SMBIOS::SMBIOS()
+: SystemComponent("SMBIOS", "System Management BIOS")
+{
+    Log(Info, "Searching for SMBIOS structure");
+
+    char* memAddress = (char*)0xF0000;
+    while ((uint32_t)memAddress < 0x100000) {
+        if (memAddress[0] == '_' && memAddress[1] == 'S' && memAddress[2] == 'M' && memAddress[3] == '_') {
+            int length = memAddress[5];
+            uint8_t checksum = 0;
+            for(int i = 0; i < length; i++) {
+                checksum += memAddress[i];
+            }
+            if(checksum == 0) break;
+        }
+        memAddress += 16;
+    }
+
+    if((uint32_t)memAddress != 0x100000)
+    {
+        Log(Info, "Found at: %x", (uint32_t)memAddress);
+        this->TableAddress = memAddress;
+
+        SMBIOSEntryPoint* entryPoint = (SMBIOSEntryPoint*)this->TableAddress;
+        Log(Info, " -------- SMBIOS Summary ----------");
+        Log(Info, "Version: %d.%d", entryPoint->MajorVersion, entryPoint->MinorVersion);
+        Log(Info, "Number of Structures: %d", entryPoint->NumberOfStructures);
+        Log(Info, "Table Address: %x", entryPoint->TableAddress);
+        Log(Info, "Table Length: %d", entryPoint->TableLength);
+        Log(Info, " ---------------------------------");
+
+        int i = 0;
+        uint32_t tableAddress = entryPoint->TableAddress;
+        while(i < entryPoint->NumberOfStructures)
+        {
+            SMBIOSTag* tag = (SMBIOSTag*)tableAddress;
+            List<char*> stringList = ExtractStrings(tag);
+            switch(tag->type) {
+                case SMBIOSTableType::BIOSInformation:
+                {
+                    SMBIOSBiosInfo* info = (SMBIOSBiosInfo*)tag;
+                    SystemInfoManager::bios.vendor = CopyString(stringList[info->vendor]);
+                    SystemInfoManager::bios.version = CopyString(stringList[info->version]);
+                    SystemInfoManager::bios.releaseDate = CopyString(stringList[info->releaseDate]);
+
+                    #if BOCHS_GFX_HACK // Massive hack to detect bochs so that we can use the right video device, TODO: Improve
+                    System::isBochs = String::strcmp(stringList[info->vendor], "The Bochs Project");
+                    if(System::isBochs)
+                        BootConsole::WriteLine("(Warning) Using Bochs GFX Hack");
+                    #endif
+                    break;
+                }
+                case SMBIOSTableType::SystemInformation:
+                {
+                    SMBIOSSystemInfo* info = (SMBIOSSystemInfo*)tag;
+                    SystemInfoManager::system.manufacturer = CopyString(stringList[info->manufacturer]);
+                    SystemInfoManager::system.product = CopyString(stringList[info->productName]);
+                    SystemInfoManager::system.version = CopyString(stringList[info->version]);
+                    SystemInfoManager::system.serial = CopyString(stringList[info->serialNumber]);
+                    
+                    if(entryPoint->MajorVersion >= 2 && entryPoint->MinorVersion > 4) {
+                        SystemInfoManager::system.sku = CopyString(stringList[info->sku]);
+                        SystemInfoManager::system.family = CopyString(stringList[info->family]);
+                    }
+                    else {
+                        SystemInfoManager::system.sku = "N/A";
+                        SystemInfoManager::system.family = "N/A";
+                    }
+                    break;
+                }
+                case SMBIOSTableType::EnclosureInformation:
+                {
+                    SMBIOSSystemEnclosureInformation* info = (SMBIOSSystemEnclosureInformation*)tag;
+                    SystemInfoManager::enclosure.manufacturer = CopyString(stringList[info->manufacturer]); 
+                    SystemInfoManager::enclosure.serial = CopyString(stringList[info->serialNumber]); 
+                    SystemInfoManager::enclosure.sku = CopyString(stringList[info->assetTag]); 
+                    SystemInfoManager::enclosure.version = CopyString(stringList[info->version]);                     
+                    break;
+                }
+                case SMBIOSTableType::ProcessorInformation:
+                {
+                    SMBIOSProcessorInformation* info = (SMBIOSProcessorInformation*)tag;
+                    SystemInfoManager::processor.manufacturer = CopyString(stringList[info->manufacturer]);
+                    SystemInfoManager::processor.socket = CopyString(stringList[info->socketDesignation]);
+                    SystemInfoManager::processor.version = CopyString(stringList[info->version]);
+                    break;
+                }
+                case SMBIOSTableType::EndOfTable:
+                    return;
+            }
+
+            tableAddress += ((SMBIOSTag*)tableAddress)->length;
+
+            while(0 != (*((uint8_t*)tableAddress) | *((uint8_t*)tableAddress + 1))) tableAddress++;
+
+            tableAddress += 2;
+            i++;
+        }
+    }
+}
+
+List<char*> SMBIOS::ExtractStrings(SMBIOSTag* header)
+{
+    List<char*> stringList;
+    stringList.push_back("N/A");
+
+    uint8_t* ptr = ((uint8_t*)header) + header->length;
+
+    if(*ptr == 0) 
+        ptr += 2;
+    else for (;;) {
+        char* str = (char*)ptr;
+        uint32_t len = String::strlen(str);
+
+        ptr += len + 1;
+
+        if(len == 0)
+            break;
+        else
+            stringList.push_back(str);
+    }
+
+    return stringList;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/components/systemcomponents.cpp b/kernelz/src/system/components/systemcomponents.cpp
new file mode 100644
index 0000000..a3df66a
--- /dev/null
+++ b/kernelz/src/system/components/systemcomponents.cpp
@@ -0,0 +1,20 @@
+#include <system/components/systemcomponent.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+SystemComponent::SystemComponent(char* name, char* description)
+{
+    this->Name = name;
+    this->Description = description;
+}
+
+char* SystemComponent::GetComponentName()
+{
+    return this->Name;
+}
+char* SystemComponent::GetComponentDescription()
+{
+    return this->Description;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/components/vesa.cpp b/kernelz/src/system/components/vesa.cpp
new file mode 100644
index 0000000..f898816
--- /dev/null
+++ b/kernelz/src/system/components/vesa.cpp
@@ -0,0 +1,159 @@
+/*
+http://www.petesqbsite.com/sections/tutorials/tuts/vbe3.pdf
+*/
+
+#include <system/components/vesa.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+using namespace CactusOS::core;
+
+uint16_t* RealPTRToAddr(Real_Pointer ptr){
+    return (uint16_t*)((ptr.B * 0x10) + ptr.A);
+}
+
+VESA::VESA(Virtual8086Manager* vm86)
+: GraphicsDevice("VESA VBE Adapter"),
+SystemComponent("VESA VBE", "VESA BIOS Extensions")
+{ 
+    this->virtual8086Manager = vm86;
+}
+
+VESAModeInfo* VESA::GetModeInfo(uint16_t mode)
+{
+    VESAModeInfo* info = (VESAModeInfo*)0x8000;
+    MemoryOperations::memset(info, 0, sizeof(VESAModeInfo));
+
+	VM86Arguments regs;
+	MemoryOperations::memset(&regs, 0, sizeof(VM86Arguments));
+
+	regs.AX = 0x4F01;
+	regs.CX = mode;
+	regs.DI = (uint16_t)0x8000;
+	virtual8086Manager->CallInterrupt(0x10, &regs);	
+	
+	return info;
+}
+
+void VESA::SetVideoMode(uint16_t mode)
+{
+	VM86Arguments regs;
+	MemoryOperations::memset(&regs, 0, sizeof(VM86Arguments));
+	regs.AX = 0x4F02;
+	regs.BX = mode;
+	virtual8086Manager->CallInterrupt(0x10, &regs);
+}
+
+bool VESA::SelectBestVideoMode()
+{
+	Log(Info, "Initializing VESA Graphics Device");
+
+	VESAControllerInfo* vesaInfo = (VESAControllerInfo*)0x7000;
+	MemoryOperations::memset(vesaInfo, 0, 512);
+	MemoryOperations::memcpy(vesaInfo->Signature, "VBE2", 4);
+	
+	Log(Info, "Probing For Controller Information");
+	VM86Arguments regs;
+	MemoryOperations::memset(&regs, 0, sizeof(VM86Arguments));
+	regs.AX = 0x4F00;
+	regs.DI = (uint16_t)0x7000;
+	virtual8086Manager->CallInterrupt(0x10, &regs);
+
+	if(MemoryOperations::memcmp(vesaInfo->Signature, "VESA", 4) == 0)
+	{
+		// Print Basic Info
+		Log(Info, "VESA VBE Version: %d.%d", (vesaInfo->Version & 0xFF00) >> 8, vesaInfo->Version & 0x00FF);
+		Log(Info, "OEM String: %s", (char*)RealPTRToAddr(vesaInfo->OemStringPtr));
+		Log(Info, "Amount of Video Memory: %d Kb", vesaInfo->TotalMemory * 64);
+
+		if((vesaInfo->Version & 0xFF00) >> 8 >= 2) { //VBE2.0+ Support some more info strings
+			Log(Info, "Vendor: %s", (char*)RealPTRToAddr(vesaInfo->OemVendorNamePtr));
+			Log(Info, "Product: %s", (char*)RealPTRToAddr(vesaInfo->OemProductNamePtr));
+			Log(Info, "Revision: %s", (char*)RealPTRToAddr(vesaInfo->OemProductRevPtr));
+		}
+
+		// Check if EDID is loaded
+		int preferedWidth = 0, preferedHeight = 0;
+		bool edidValid = true;
+		System::edid->PreferedMode(&preferedWidth, &preferedHeight);
+		if(preferedWidth == 0 || preferedHeight == 0)
+			edidValid = false;
+
+		// Get mode array pointer
+		uint16_t* modeArray = (uint16_t*)RealPTRToAddr(vesaInfo->VideoModePtr);
+		if(edidValid)
+			Log(Info, "Looping through video modes, using prefered mode %dx%d", preferedWidth, preferedHeight);
+		else
+			Log(Info, "Looping through video modes");
+
+		///////////////
+		// Select Best Video Mode from List
+		///////////////
+		uint16_t selectedModeNumber = 0;
+		uint16_t fallbackModeNumber = 0;
+		while(*modeArray != 0xFFFF) {
+			VESAModeInfo* modeInfo = GetModeInfo(*modeArray);
+			if((modeInfo->ModeAttributes & 0x90) != 0x90) { // Check for lineair framebuffer support + mode is graphics mode
+				modeArray++;
+				continue;
+			}
+
+			if(modeInfo->MemoryModel != 4 && modeInfo->MemoryModel != 6 ) { // Check if this is a packed pixel or direct color mode
+				modeArray++;
+				continue;
+			}
+
+			if(modeInfo->BitsPerPixel != DEFAULT_SCREEN_BPP) { // We only support 32-bit color atm
+				modeArray++;
+				continue;
+			}
+			
+			// Valid Mode if we reach this
+			// Now check resolution
+			if(edidValid && modeInfo->XResolution == preferedWidth && modeInfo->YResolution == preferedHeight) { // We found the perfect mode for our monitor
+				selectedModeNumber = *modeArray;
+				break; // Stop the loop since we have found a perfect match
+			}
+			else if(modeInfo->XResolution == DEFAULT_SCREEN_WIDTH && modeInfo->YResolution == DEFAULT_SCREEN_HEIGHT) // We at least found a fallback resolution
+				fallbackModeNumber = *modeArray;
+			
+			modeArray++;
+		}
+
+		if(selectedModeNumber == 0 && fallbackModeNumber != 0) { // We have not found prefered mode
+			selectedModeNumber = fallbackModeNumber; // Use mode that should always work
+			Log(Warning, "Using Fallback mode %w (%dx%d)", fallbackModeNumber, DEFAULT_SCREEN_WIDTH, DEFAULT_SCREEN_HEIGHT);
+		}
+
+		if(selectedModeNumber != 0)
+		{
+			Log(Info, "Switching to video mode: %w", selectedModeNumber);
+			this->SetVideoMode(selectedModeNumber);
+
+			//Set the current mode info
+			MemoryOperations::memcpy(&this->currentVideoMode, GetModeInfo(selectedModeNumber), sizeof(VESAModeInfo));
+
+			Log(Info, "Framebuffer is at: %x", this->currentVideoMode.PhysBasePtr);
+
+			//Store mode information to base class
+			this->bpp = this->currentVideoMode.BitsPerPixel;
+			this->height = this->currentVideoMode.YResolution;
+			this->width = this->currentVideoMode.XResolution;
+			this->framebufferPhys = this->currentVideoMode.PhysBasePtr;
+
+			return true;
+		}
+		else // No valid mode found, not even a fallback resolution
+		{
+			Log(Error, "Could not find a usable video mode");
+			return false;
+		}
+	}
+	else
+	{
+		Log(Error, "Vesa info block does not have valid signature");
+		return false;
+	}
+}
\ No newline at end of file
diff --git a/kernelz/src/system/debugger.cpp b/kernelz/src/system/debugger.cpp
new file mode 100644
index 0000000..7b744c8
--- /dev/null
+++ b/kernelz/src/system/debugger.cpp
@@ -0,0 +1,480 @@
+#include <system/debugger.h>
+#include <system/system.h>
+#include <system/memory/deviceheap.h>
+#include <system/listings/systeminfo.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+using namespace CactusOS::core;
+
+SymbolDebugger::SymbolDebugger(char* symFile, bool kernel)
+{
+    MemoryOperations::memset(this->messageBuffer, 0, sizeof(this->messageBuffer));
+    this->isKernel = kernel;
+
+    // Check if file even exists
+    if(System::vfs->FileExists(symFile) == false) {
+        Log(Error, "Could not initialize debugger %s does not exist!", symFile);
+        return;
+    }
+
+    // Get length and read file
+    uint32_t fileLen = System::vfs->GetFileSize(symFile);
+    if(fileLen == (uint32_t)-1)
+        return; // Error while getting size
+    
+    // Create buffer
+    uint8_t* fileBuffer = new uint8_t[fileLen];
+    if(System::vfs->ReadFile(symFile, fileBuffer) != 0) {
+        Log(Error, "Could not read file: %s!", symFile);
+
+        delete fileBuffer;
+        return;
+    }
+
+    // Loop though all data and parse items
+    uint32_t dataOffset = 0;
+    while(dataOffset < fileLen)
+    {
+        // Turn data to string
+        char* strPtr = (char*)(fileBuffer + dataOffset);
+
+        // Create item
+        GenericSymbol_t item;
+
+        // Get address
+        strPtr[8] = '\0'; // Replace space with terminator temporarily
+        item.address = Convert::HexToInt(strPtr);
+        strPtr[8] = ' '; // Replace it back
+
+        // Get Type
+        item.type = strPtr[9];
+
+        // Copy name
+        int len = String::IndexOf(strPtr + 10, '\n');
+        item.name = new char[len];
+        MemoryOperations::memcpy(item.name, strPtr + 11, len - 1);
+        item.name[len-1] = '\0';
+
+        dataOffset += len + 11;
+        this->symbolTable.push_back(item);
+    }
+    delete fileBuffer;
+
+    Log(Info, "Debugger initialized with %d symbols for %s", this->symbolTable.size(), symFile);
+
+#if ENABLE_ADV_DEBUG
+    // allocate free page to use for debugging
+    this->pageAccessAddress = (uint32_t)KernelHeap::alignedMalloc(PAGE_SIZE, PAGE_SIZE);
+    if(this->isKernel) {
+        // Send message to external debugger that we are initalized and ready to receive commands
+        if(Serialport::Initialized && !System::gdbEnabled) {
+            Serialport::WriteStr("$DebugReady\n");
+
+            // Send system general info
+            Serialport::WriteStr("$DebugSysSummary|");
+            Serialport::WriteStr(__DATE__ "  " __TIME__ "|");
+
+            // Info about system
+            Serialport::WriteStr(SystemInfoManager::system.manufacturer);
+            Serialport::WriteStr("|");
+            Serialport::WriteStr(SystemInfoManager::system.product);
+            Serialport::WriteStr("|");
+            Serialport::WriteStr(SystemInfoManager::system.version);
+            Serialport::WriteStr("|");
+
+            // Info about bios
+            Serialport::WriteStr(SystemInfoManager::bios.vendor);
+            Serialport::WriteStr("|");
+            Serialport::WriteStr(SystemInfoManager::bios.version);
+            Serialport::WriteStr("|");
+
+            // Info about memory
+            Serialport::WriteStr(Convert::IntToString32(PhysicalMemoryManager::AmountOfMemory()));
+            Serialport::WriteStr("\n"); // Terminate info
+
+            //KernelDebugger::PrintPageTables();
+        }
+    }
+#endif
+}
+const char* SymbolDebugger::FindSymbol(uint32_t address, uint32_t* offset)
+{    
+	GenericSymbol_t prevItem = this->symbolTable[0];
+	for (int i = 0; i < this->symbolTable.size(); i++)
+	{
+        // Check if address is between this entry or the last one
+        // Then the address belongs to this function
+		if (address >= prevItem.address && address <= this->symbolTable[i].address)
+		{
+			*offset = address - prevItem.address;
+			return prevItem.name;
+		}
+		prevItem = this->symbolTable[i];
+	}
+	return 0;
+}
+void SymbolDebugger::Stacktrace(CPUState* esp)
+{
+    if(this->symbolTable.size() == 0) {
+        Log(Error, "Debugger symbols not loaded!");
+        return;
+    }
+
+    StackFrame_t* frame = (StackFrame_t*)esp->EBP;
+	uint32_t page = (uint32_t)frame & 0xFFFFF000;
+    uint32_t offset = 0;
+
+	const char* name = FindSymbol(esp->EIP, &offset);
+    Log(Info, "%x [%x] %s", offset, esp->EIP, name ? name : "[Symbol not found]");
+	while(frame && ((uint32_t)frame & 0xFFFFF000) == page)
+	{
+		name = FindSymbol(frame->addr, &offset);
+        Log(Info, "%x [%x] %s", offset, frame->addr, name ? name : "[Symbol not found]");
+		frame = frame->next;
+	}
+}
+void SymbolDebugger::Update()
+{
+    if(this->isKernel == false) // Only kernel debugger has acces to serial
+        return;
+    
+    while(Serialport::SerialReceiveReady()) {
+        char c = Serialport::Read();
+        if(c != '\n') {
+            messageBuffer[this->serialIndex++] = c;
+        }
+        else {
+            // Terminate string
+            messageBuffer[this->serialIndex] = '\0';
+
+            // Prevent a task-switch from happening while excecuting a debug command
+            System::scheduler->Enabled = false;
+            
+            // Handle command
+            this->HandleDebugCommand(this->serialIndex);
+
+            // And enable scheduler again
+            System::scheduler->Enabled = true;
+
+            this->serialIndex = 0;
+        }
+    }
+}
+void SymbolDebugger::HandleDebugCommand(int size)
+{
+    //Log(Info, "%s", messageBuffer);
+    if (String::strncmp(messageBuffer, "ReqDebugUpdate", 14)) {
+        // Update from kernel
+        SymbolDebugger::SendUpdateToHost();
+    }
+    else if(String::strncmp(messageBuffer, "xp ", 3)) {
+        // Physical memory dump
+        List<char*> args = String::Split(messageBuffer, ' ');
+
+        uint32_t address = args[1][1] == 'x' ? Convert::HexToInt(args[1] + 2) : Convert::StringToInt(args[1]);
+        uint32_t size = args[2][1] == 'x' ? Convert::HexToInt(args[2] + 2) : Convert::StringToInt(args[2]);
+
+        SymbolDebugger::PrintMemoryDump(address, size, false);
+
+        for(char* c : args)
+            delete c;
+    }
+    else if(String::strncmp(messageBuffer, "x ", 2)) {
+        // Virtual memory dump
+        List<char*> args = String::Split(messageBuffer, ' ');
+
+        uint32_t address = args[1][1] == 'x' ? Convert::HexToInt(args[1] + 2) : Convert::StringToInt(args[1]);
+        uint32_t size = args[2][1] == 'x' ? Convert::HexToInt(args[2] + 2) : Convert::StringToInt(args[2]);
+
+        SymbolDebugger::PrintMemoryDump(address, size, true);
+
+        for(char* c : args)
+            delete c;
+    }
+    else if(String::strncmp(messageBuffer, "pagedump", 8)) {
+        List<char*> args = String::Split(messageBuffer, ' ');
+
+        // Page table dump
+        SymbolDebugger::PrintPageTables(args.size() > 1 ? Convert::StringToInt(args[1]) : -1);
+
+        for(char* c : args)
+            delete c;
+    }
+    else {
+        Log(Error, "Unknown debug command %s", messageBuffer);
+    }
+}
+void SymbolDebugger::SendUpdateToHost()
+{
+    if(this->isKernel == false) // Only kernel debugger has acces to serial
+        return;
+    
+    // Send update about host to debugger
+    Serialport::WriteStr("$DebugUpdate|");
+
+    // Used physical memory
+    Serialport::WriteStr(Convert::IntToString32(PhysicalMemoryManager::UsedBlocks() * PAGE_SIZE));
+    Serialport::WriteStr("|");
+
+    // Used kernel memory
+    Serialport::WriteStr(Convert::IntToString32(KernelHeap::UsedMemory()));
+    Serialport::WriteStr("|");
+
+    // Idle process active time
+    Serialport::WriteStr(Convert::IntToString32(System::statistics.idleProcActive));
+    Serialport::WriteStr("|");
+
+    // Disk read and writes
+    Serialport::WriteStr(Convert::IntToString32(System::statistics.diskReadOp));
+    Serialport::WriteStr("|");
+    Serialport::WriteStr(Convert::IntToString32(System::statistics.diskWriteOp));
+
+    Serialport::WriteStr("\n");
+}
+void SymbolDebugger::PrintMemoryDump(uint32_t address, uint32_t size, bool virtMemory)
+{
+    //Log(Info, "KernelDebugger::PrintMemoryDump(%x, %x, %d)", address, size, virtMemory);
+
+    const uint8_t maxWidth = 20;
+
+    BootConsole::WriteLine("------------ Memory Dump ----------");
+    if(virtMemory)
+    {
+        // Print a byte dump of a virtual region of memory
+        uint8_t width = 0;
+        for(uint32_t x = address; x < address + size; x++) {
+            BootConsole::Write(Convert::IntToHexString(*(uint8_t*)x));
+            BootConsole::Write(" ");
+            
+            if (width++ > maxWidth) {
+                width = 0;
+                BootConsole::WriteLine();
+            }
+        }
+    }
+    else
+    {   
+        // We have section at the start we need to print
+        if(address % PAGE_SIZE != 0) {
+            uint32_t start = this->pageAccessAddress + (address % PAGE_SIZE);
+            uint16_t firstBlockSize = PAGE_SIZE - (address % PAGE_SIZE);
+            if(firstBlockSize > size)
+                firstBlockSize = size;
+
+            // We are processing this block
+            size -= firstBlockSize;
+
+            // Move address to paging boundary
+            address = pageRoundDown(address);
+
+            // Make sure we can access this physical block of memory
+            VirtualMemoryManager::mapVirtualToPhysical((void*)address, (void*)this->pageAccessAddress, true, false);
+
+            uint8_t width = 0;
+            for(uint32_t item = 0; item < firstBlockSize; item++) {
+                BootConsole::Write(Convert::IntToHexString(*(uint8_t*)(start + item)));
+                BootConsole::Write(" ");
+                
+                if (width++ > maxWidth) {
+                    width = 0;
+                    BootConsole::WriteLine();
+                }
+            }
+        }
+
+        // Allocate a piece of memory for accessing the physical memory
+        for(uint32_t x = address; x < address + size; x += PAGE_SIZE)
+        {
+            // Make sure we can access this physical block of memory
+            VirtualMemoryManager::mapVirtualToPhysical((void*)x, (void*)this->pageAccessAddress, true, false);
+
+            uint16_t blockSize = (x - (address + size)) > PAGE_SIZE ? PAGE_SIZE : (x - (address + size));
+
+            uint8_t width = 0;
+            for(uint32_t item = 0; item < blockSize; item++) {
+                BootConsole::Write(Convert::IntToHexString((*(uint8_t*)(this->pageAccessAddress + item))));
+                BootConsole::Write(" ");
+                
+                if (width++ > maxWidth) {
+                    width = 0;
+                    BootConsole::WriteLine();
+                }
+            }
+        }
+    }
+    BootConsole::WriteLine();
+    BootConsole::WriteLine("-----------------------------------");
+}
+void SymbolDebugger::PrintPageTables(int pid)
+{
+    uint32_t prevPageDir = VirtualMemoryManager::GetPageDirectoryAddress();
+    if(pid != -1) {
+        Process* proc = ProcessHelper::ProcessById(pid);
+        if(proc == 0) {
+            Log(Error, "KernelDebugger: no process found with id %d", pid);
+            return;
+        }
+        
+        VirtualMemoryManager::SwitchPageDirectory(proc->pageDirPhys);
+    }
+
+    BootConsole::WriteLine("------------ Paging Dump ----------");
+
+    PageDirectory* pageDir = (PageDirectory*)PAGE_DIRECTORY_ADDRESS;
+
+    // Loop through all page directories and print their contents
+    for(uint16_t pageDirIndex = 0; pageDirIndex < 1024; pageDirIndex++) {
+        // Get entry from page directory
+        PageDirectoryEntry pdEntry = pageDir->entries[pageDirIndex];
+        
+        if(pdEntry.pageSize == FOUR_MB) {
+            if(pdEntry.present) {
+                this->PrintPageItem(&pdEntry, true, pageDirIndex, 0);
+            }
+        }
+        else {
+            if(pdEntry.present) {
+                PageTable* pageTable = (PageTable*)(PAGE_TABLE_ADDRESS + (PAGE_SIZE * pageDirIndex));
+                for(uint16_t pageTabIndex = 0; pageTabIndex < 1024; pageTabIndex++) {
+                    uint32_t address = pageDirIndex * 4_MB + pageTabIndex * 4_KB;
+                    uint32_t pt_offset = PAGETBL_INDEX(address);
+
+                    PageTableEntry ptEntry = pageTable->entries[pt_offset];
+                    if(!ptEntry.present)
+                        continue;
+                    
+                    this->PrintPageItem(&ptEntry, false, pageDirIndex, pageTabIndex);
+                }
+            }
+        }
+    }
+
+    BootConsole::WriteLine("-----------------------------------");
+
+    if(pid != -1)
+        VirtualMemoryManager::SwitchPageDirectory(prevPageDir);
+}
+void SymbolDebugger::PrintPageItem(void* item, bool table, uint16_t pdIndex, uint16_t ptIndex)
+{
+    static uint32_t curChainSize = 0;
+    static uint32_t curChainStart = 0;
+    
+    // Calculate basic info about item
+    uint32_t address = pdIndex * 4_MB + ptIndex * 4_KB;
+    //uint32_t physAddress = table ? ((PageDirectoryEntry*)item)->frame * 4_MB : ((PageTableEntry*)item)->frame * 4_KB;
+    uint32_t addressSize = table ? 4_MB : 4_KB;
+    
+    if(curChainSize == 0) {
+        curChainStart = address; // Start new chain
+        curChainSize = addressSize;
+    }
+    else {
+        uint32_t curChainAddress = curChainStart + curChainSize;
+
+        // Check if we can attach this entry to the chain
+        if(curChainAddress == address) // We fit right in
+            curChainSize += addressSize;
+        else {
+            // Else print the current chain and reset vars
+            Log(Info, "%x-%x --- %x %s", curChainStart, curChainAddress, curChainSize, "-XXX-");
+
+            // Reset vars to this entry
+            curChainStart = address;
+            curChainSize = addressSize;
+        }
+    }
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+void KernelDebugger::PrintPageItem(void* item, bool table, uint16_t pdIndex, uint16_t ptIndex)
+{
+    static uint32_t prevAddress = 0;
+    static uint32_t prevAddressPhys = 0;
+    static uint32_t prevAddressSize = 0;
+
+    static uint32_t curChainSize = 0;
+    static uint32_t startAddress = 0;
+    static uint32_t startAddressPhys = 0;
+
+    uint32_t address = pdIndex * 4_MB + ptIndex * 4_KB;
+    uint32_t physAddress = table ? ((PageDirectoryEntry*)item)->frame * 4_MB : ((PageTableEntry*)item)->frame * 4_KB;
+    uint32_t addressSize = table ? 4_MB : 4_KB;
+
+    bool canMakeChain = (address - prevAddressSize == prevAddress);// && (physAddress - addressSize == prevAddressPhys);
+    if(curChainSize == 0)
+        canMakeChain = true;
+
+    if(canMakeChain) {
+        if(curChainSize == 0) {
+            startAddress = address;
+            startAddressPhys = physAddress;
+        }
+        
+        curChainSize += addressSize;
+    }
+    else
+    {
+        if(curChainSize > 0)
+        {
+            Log(Info, "%x-%x  %x-%x  %x %s", startAddress, address, startAddressPhys, physAddress, curChainSize, "-XXX-");
+
+            // Reset vars
+            startAddress = 0;
+            startAddressPhys = 0;
+            curChainSize = 0;
+        }
+        else
+        {
+            char* flagBuf = "-----";
+
+            // Print single item
+            if(table) {
+                PageDirectoryEntry pdEntry = *(PageDirectoryEntry*)item;
+                
+                flagBuf[0] = 'R';
+                if(pdEntry.readWrite)
+                    flagBuf[1] = 'W';
+                if(pdEntry.isUser)
+                    flagBuf[2] = 'U';
+                if(pdEntry.writeThrough)
+                    flagBuf[3] = 'W';
+                if(pdEntry.canCache)
+                    flagBuf[4] = 'C';
+            }
+            else {
+                PageTableEntry ptEntry = *(PageTableEntry*)item;
+
+                flagBuf[0] = 'R';
+                if(ptEntry.readWrite)
+                    flagBuf[1] = 'W';
+                if(ptEntry.isUser)
+                    flagBuf[2] = 'U';
+                if(ptEntry.writeThrough)
+                    flagBuf[3] = 'W';
+                if(ptEntry.canCache)
+                    flagBuf[4] = 'C';
+            }
+
+            Log(Info, "%x-%x  %x-%x  %x %s", address, address + addressSize, physAddress, physAddress + addressSize, addressSize, flagBuf);
+        }
+    }
+
+    prevAddress = address;
+    prevAddressPhys = physAddress;
+    prevAddressSize = addressSize;
+}
+*/
\ No newline at end of file
diff --git a/kernelz/src/system/disks/disk.cpp b/kernelz/src/system/disks/disk.cpp
new file mode 100644
index 0000000..d4efb7c
--- /dev/null
+++ b/kernelz/src/system/disks/disk.cpp
@@ -0,0 +1,36 @@
+#include <system/disks/disk.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+Disk::Disk(uint32_t controllerIndex, DiskController* controller, DiskType type, uint64_t size, uint32_t blocks, uint32_t blocksize)
+{
+    this->controllerIndex = controllerIndex;
+    this->controller = controller;
+    this->type = type;
+    this->size = size;
+    this->blockSize = blocksize;
+    this->numBlocks = blocks;
+}
+char Disk::ReadSector(uint32_t lba, uint8_t* buf)
+{
+    #if ENABLE_ADV_DEBUG
+    System::statistics.diskReadOp += 1;
+    #endif
+
+    if(this->controller != 0)
+        return this->controller->ReadSector(this->controllerIndex, lba, buf);
+    return 1;
+}
+char Disk::WriteSector(uint32_t lba, uint8_t* buf)
+{
+    #if ENABLE_ADV_DEBUG
+    System::statistics.diskWriteOp += 1;
+    #endif
+
+    if(this->controller != 0)
+        return this->controller->WriteSector(this->controllerIndex, lba, buf);
+    return 1;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/disks/diskcontroller.cpp b/kernelz/src/system/disks/diskcontroller.cpp
new file mode 100644
index 0000000..c9ec40c
--- /dev/null
+++ b/kernelz/src/system/disks/diskcontroller.cpp
@@ -0,0 +1,14 @@
+#include <system/disks/diskcontroller.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+DiskController::DiskController()
+{ }
+char DiskController::ReadSector(uint16_t drive, uint32_t lba, uint8_t* buf)
+{ return 1; } //Needs to be implemented by driver
+char DiskController::WriteSector(uint16_t drive, uint32_t lba, uint8_t* buf)
+{ return 1; } //Needs to be implemented by driver
+bool DiskController::EjectDrive(uint8_t drive)
+{ return false; } //Needs to be implemented by driver
\ No newline at end of file
diff --git a/kernelz/src/system/disks/diskmanager.cpp b/kernelz/src/system/disks/diskmanager.cpp
new file mode 100644
index 0000000..065a6b5
--- /dev/null
+++ b/kernelz/src/system/disks/diskmanager.cpp
@@ -0,0 +1,51 @@
+#include <system/disks/diskmanager.h>
+
+#include <system/drivers/disk/ide.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+// VM86 Function to get info about a specific disk device
+// We must do it this way because the DS:SI gets used by the CallInterrupt() method
+extern "C" uint8_t diskInfo;
+
+DiskManager::DiskManager()
+{ 
+    allDisks.Clear();
+}
+
+char DiskManager::ReadSector(uint16_t drive, uint32_t lba, uint8_t* buf)
+{
+    if(drive < allDisks.size())
+        return allDisks[drive]->ReadSector(lba, buf);
+    return 1;
+}
+
+char DiskManager::WriteSector(uint16_t drive, uint32_t lba, uint8_t* buf)
+{
+    if(drive < allDisks.size())
+        return allDisks[drive]->WriteSector(lba, buf);
+    return 1;
+}
+
+void DiskManager::AddDisk(Disk* disk)
+{
+    //Add Disk to list of all disk
+    allDisks.push_back(disk);
+    //Try to detect filesystems present on disk
+    PartitionManager::DetectAndLoadFilesystem(disk);
+}
+void DiskManager::RemoveDisk(Disk* disk)
+{
+    allDisks.Remove(disk); //Remove from list
+    System::vfs->UnmountByDisk(disk); //And unmount all filesystems using that disk
+}
+
+BiosDriveParameters* DiskManager::GetDriveInfoBios(uint8_t drive)
+{
+    System::vm86Manager->ExecuteCode((uint32_t)&diskInfo, drive);
+    return (BiosDriveParameters*)0x7000;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/disks/partitionmanager.cpp b/kernelz/src/system/disks/partitionmanager.cpp
new file mode 100644
index 0000000..120c100
--- /dev/null
+++ b/kernelz/src/system/disks/partitionmanager.cpp
@@ -0,0 +1,77 @@
+#include <system/disks/partitionmanager.h>
+
+#include <system/vfs/iso9660.h>
+#include <system/vfs/fat.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+void PartitionManager::DetectAndLoadFilesystem(Disk* disk)
+{
+    char* diskIdentifier = (char*)(disk->identifier == 0 ? "" : disk->identifier);
+    Log(Info, "Detecting partitions on disk %s", diskIdentifier);
+    
+    uint8_t* Readbuf = new uint8_t[CDROM_SECTOR_SIZE];
+    MemoryOperations::memset(Readbuf, 0, CDROM_SECTOR_SIZE);
+
+    char ret = disk->ReadSector(0, Readbuf);
+    if(ret == 0)
+    {
+        MasterBootRecord* mbr = (MasterBootRecord*)Readbuf;
+        if(mbr->magicnumber != 0xAA55) {
+            Log(Warning, "MBR magic number is not 0xAA55 instead %w", mbr->magicnumber);
+            delete Readbuf;
+            return;
+        }
+
+        if(disk->type == DiskType::Floppy) // Floppy don't contain partitions
+        {
+            FAT* fatFS = new FAT(disk, 0, disk->size / BYTES_PER_SECT);
+            if(fatFS->Initialize())
+                System::vfs->Mount(fatFS); //Mount the filesystem
+            else
+                delete fatFS;
+        }
+        else // Regular partition scheme 
+        {
+            //Loop trough partitions
+            for(int p = 0; p < 4; p++)
+            {
+                if(mbr->primaryPartitions[p].partition_id == 0x00)
+                    continue;
+
+                Log(Info, "- Disk %s Part=%d Boot=%d ID=%b Sectors=%d", diskIdentifier, p, mbr->primaryPartitions[p].bootable == 0x80, mbr->primaryPartitions[p].partition_id, mbr->primaryPartitions[p].length);
+                AssignVFS(mbr->primaryPartitions[p], disk);
+            }
+        }
+    }
+    else {
+        Log(Error, "Error reading disk %s code = %b", diskIdentifier, ret);
+    }
+    delete Readbuf;
+}
+
+void PartitionManager::AssignVFS(PartitionTableEntry partition, Disk* disk)
+{
+    if(partition.partition_id == 0xCD)
+    {
+        BootConsole::Write(" [ISO9660]");
+        ISO9660* isoVFS = new ISO9660(disk, partition.start_lba, partition.length);
+        if(isoVFS->Initialize())
+            System::vfs->Mount(isoVFS); //Mount the filesystem
+        else
+            delete isoVFS;
+    }
+    else if(partition.partition_id == 0x0B || partition.partition_id == 0x0C || partition.partition_id == 0x01 || partition.partition_id == 0x04 || partition.partition_id == 0x06)
+    {
+        BootConsole::WriteLine(" [FAT(12/16/32)]");
+        FAT* fatFS = new FAT(disk, partition.start_lba, partition.length);
+        if(fatFS->Initialize())
+            System::vfs->Mount(fatFS); //Mount the filesystem
+        else
+            delete fatFS;
+    }
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/disk/ahci/ahcicontroller.cpp b/kernelz/src/system/drivers/disk/ahci/ahcicontroller.cpp
new file mode 100644
index 0000000..be9270e
--- /dev/null
+++ b/kernelz/src/system/drivers/disk/ahci/ahcicontroller.cpp
@@ -0,0 +1,174 @@
+#include <system/drivers/disk/ahci/ahcicontroller.h>
+#include <system/drivers/disk/ahci/ahcidefs.h>
+#include <system/system.h>
+#include <system/tasking/scheduler.h>
+#include <system/tasking/lock.h>
+#include <system/memory/deviceheap.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+
+uint32_t AHCIController::readRegister(uint32_t offset)
+{
+    return readMemReg(this->regBase + offset);
+}
+void AHCIController::writeRegister(uint32_t offset, uint32_t value)
+{
+    writeMemReg(this->regBase + offset, value);
+}
+bool AHCIController::waitForClear(uint32_t reg, uint32_t bits, uint32_t timeout)
+{
+	while (timeout--) {
+		if ((readRegister(reg) & bits) == 0)
+			return true;
+		System::pit->Sleep(1);
+	}
+	return false;
+}
+bool AHCIController::waitForSet(uint32_t reg, uint32_t bits, uint32_t timeout)
+{
+	while (timeout--) {
+		if ((readRegister(reg) & bits) == bits)
+			return true;
+		System::pit->Sleep(1);
+	}
+	return false;
+}
+
+AHCIController::AHCIController(PCIDevice* device)
+: Driver("PCI AHCI Controller", "PCI AHCI Controller"),
+  InterruptHandler(IDT_INTERRUPT_OFFSET + device->interrupt),
+  DiskController()
+{
+    this->pciDevice = device;
+    MemoryOperations::memset(this->ports, 0, sizeof(this->ports));
+}
+
+bool AHCIController::Initialize()
+{
+    BaseAddressRegister BAR5 = System::pci->GetBaseAddressRegister(pciDevice->bus, pciDevice->device, pciDevice->function, 5);
+    if(BAR5.type == InputOutput)
+        return false; // Should be memory mapped
+
+    uint32_t memStart = pageRoundDown((uint32_t)BAR5.address); // Assuming 32-Bit address
+    uint32_t memEnd = pageRoundUp((uint32_t)BAR5.address + BAR5.size);
+    
+    // Allocate virtual chuck of memory that we can use for device
+    this->regBase = DeviceHeap::AllocateChunk(memEnd - memStart) + ((uint32_t)BAR5.address % PAGE_SIZE);
+
+    // Map memory so that we can use it
+    VirtualMemoryManager::mapVirtualToPhysical((void*)memStart, (void*)this->regBase, memEnd - memStart, true, true);
+
+    // Enable BUS Mastering
+    System::pci->Write(pciDevice->bus, pciDevice->device, pciDevice->function, 0x04, 0x0006);
+
+    // Disable interrupts for now
+    writeRegister(AHCI_REG_GLOBALCONTROL, readRegister(AHCI_REG_GLOBALCONTROL) & ~(1<<1));
+
+    // Try to reset controller into default state
+    if(this->Reset() == false)
+        return false;
+
+    // Read amount of ports from register
+	this->portCount = 1 + ((readRegister(AHCI_REG_HOSTCAP) >> CAP_NP_SHIFT) & CAP_NP_MASK);
+    uint32_t portsImplemented = readRegister(AHCI_REG_PORTIMPLEMENTED);
+
+    // For each implemented port we create a new class for handling port specific things
+	for (int i = 0; i < this->portCount; i++) {
+		if (portsImplemented & (1 << i)) {
+			this->ports[i] = new AHCIPort(this, this->regBase + AHCI_REG_PORTBASE + (i * AHCI_PORTREG_SIZE), i);
+			if(this->ports[i]->PreparePort() == false) {
+				delete this->ports[i];
+				this->ports[i] = 0;
+			}
+		}
+	}
+
+    // Clear interrupt status
+    writeRegister(AHCI_REG_INTSTATUS, readRegister(AHCI_REG_INTSTATUS));
+
+    // Enable interrupts
+    writeRegister(AHCI_REG_GLOBALCONTROL, readRegister(AHCI_REG_GLOBALCONTROL) | (1<<1));
+    
+    // Enable all found ports
+	for (int i = 0; i < this->portCount; i++) {
+		if (this->ports[i]) {
+			if(this->ports[i]->StartupPort() == false) {
+				delete this->ports[i];
+				this->ports[i] = 0;
+			}
+		}
+	}
+
+    return true;
+}
+
+bool AHCIController::Reset()
+{
+    // Store usefull variables before reset
+    uint32_t capsBeforeReset = readRegister(AHCI_REG_HOSTCAP) & (CAP_SMPS | CAP_SSS | CAP_SPM | CAP_EMS | CAP_SXS);
+	uint32_t piBeforeReset = readRegister(AHCI_REG_PORTIMPLEMENTED);
+
+    // First set AHCI Enable bit
+    writeRegister(AHCI_REG_GLOBALCONTROL, readRegister(AHCI_REG_GLOBALCONTROL) | (1<<31));
+
+    // Then set the HBA Reset bit
+    writeRegister(AHCI_REG_GLOBALCONTROL, readRegister(AHCI_REG_GLOBALCONTROL) | (1<<0));
+
+    // Wait for reset completion
+    if(!waitForClear(AHCI_REG_GLOBALCONTROL, (1<<0), 1000))
+        return false;
+    
+    // Set AHCI Enable bit again
+    writeRegister(AHCI_REG_GLOBALCONTROL, readRegister(AHCI_REG_GLOBALCONTROL) | (1<<31));
+
+    // Write back stored variables
+    writeRegister(AHCI_REG_HOSTCAP, readRegister(AHCI_REG_HOSTCAP) | capsBeforeReset);
+    writeRegister(AHCI_REG_PORTIMPLEMENTED, piBeforeReset);
+
+    return true;
+}
+
+uint32_t AHCIController::HandleInterrupt(uint32_t esp)
+{
+    uint32_t interruptPending = readRegister(AHCI_REG_INTSTATUS) & readRegister(AHCI_REG_PORTIMPLEMENTED);
+
+	if (interruptPending == 0)
+		return esp;
+
+	for (int i = 0; i < this->portCount; i++) {
+		if (interruptPending & (1 << i)) {
+			if (this->ports[i])
+				this->ports[i]->HandleExternalInterrupt();
+		}
+	}
+
+	// clear pending interrupts
+	writeRegister(AHCI_REG_INTSTATUS, interruptPending);
+
+    //Log(Info, "AHCI Interrupt!");
+    return esp;
+}
+
+
+
+
+
+
+
+char AHCIController::ReadSector(uint16_t drive, uint32_t lba, uint8_t* buf)
+{
+    return this->ports[drive]->TransferData(true, lba, buf, 1) ? 0 : 1;
+}
+char AHCIController::WriteSector(uint16_t drive, uint32_t lba, uint8_t* buf)
+{
+    return this->ports[drive]->TransferData(false, lba, buf, 1) ? 0 : 1;
+}
+bool AHCIController::EjectDrive(uint8_t drive)
+{
+    return this->ports[drive]->Eject() ? 0 : 1;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/disk/ahci/ahciport.cpp b/kernelz/src/system/drivers/disk/ahci/ahciport.cpp
new file mode 100644
index 0000000..e92872d
--- /dev/null
+++ b/kernelz/src/system/drivers/disk/ahci/ahciport.cpp
@@ -0,0 +1,513 @@
+#include <system/drivers/disk/ahci/ahcicontroller.h>
+#include <system/drivers/disk/ahci/ahcidefs.h>
+#include <system/drivers/disk/ahci/ahciport.h>
+#include <system/system.h>
+#include <system/tasking/scheduler.h>
+#include <system/tasking/lock.h>
+#include <system/memory/deviceheap.h>
+#include <system/drivers/disk/ide.h>
+#include <system/disks/disk.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+uint32_t AHCIPort::readRegister(uint32_t offset)
+{
+    return readMemReg(this->portBase + offset);
+}
+void AHCIPort::writeRegister(uint32_t offset, uint32_t value)
+{
+    writeMemReg(this->portBase + offset, value);
+}
+bool AHCIPort::waitForClear(uint32_t reg, uint32_t bits, uint32_t timeout)
+{
+	while (timeout--) {
+		if ((readRegister(reg) & bits) == 0)
+			return true;
+		System::pit->Sleep(1);
+	}
+	return false;
+}
+bool AHCIPort::waitForSet(uint32_t reg, uint32_t bits, uint32_t timeout)
+{
+	while (timeout--) {
+		if ((readRegister(reg) & bits) == bits)
+			return true;
+		System::pit->Sleep(1);
+	}
+	return false;
+}
+int AHCIPort::FindFreeCMDSlot()
+{
+	// If not set in SACT and CI, the slot is free
+	uint32_t slots = (readRegister(AHCI_PORTREG_SATAACTIVE) | readRegister(AHCI_PORTREG_COMMANDISSUE));
+	for (int i = 0; i < COMMAND_LIST_COUNT; i++)
+	{
+		if ((slots & 1) == 0)
+			return i;
+		slots >>= 1;
+	}
+	return -1;
+}
+
+AHCIPort::AHCIPort(AHCIController* parent, uint32_t regBase, int index)
+{
+    this->parent = parent;
+    this->portBase = regBase;
+	this->index = index;
+}
+
+AHCIPort::~AHCIPort()
+{
+    if(this->commandList)
+        delete this->commandList;
+    
+    if(this->fis)
+        delete this->fis;
+}
+
+bool AHCIPort::PreparePort()
+{
+	if(this->Disable() == false)
+		return false;
+
+    // Allocate required structures for this port
+    this->commandList = (a_commandHeader_t*)KernelHeap::alignedMalloc(sizeof(a_commandHeader_t) * COMMAND_LIST_COUNT, 1_KB, &this->commandListPhys);
+    this->fis = (a_fis_t*)KernelHeap::alignedMalloc(sizeof(a_fis_t), 256, &this->fisPhys);
+
+    // Clear out the allocated memory
+    MemoryOperations::memset(this->commandList, 0, sizeof(a_commandHeader_t) * COMMAND_LIST_COUNT);
+    MemoryOperations::memset(this->fis, 0, sizeof(a_fis_t));
+
+    // Update port registers to point to structures
+    writeRegister(AHCI_PORTREG_CMDLISTBASE, this->commandListPhys);
+    writeRegister(AHCI_PORTREG_CMDLISTBASE2, 0);
+    writeRegister(AHCI_PORTREG_FISLISTBASE, this->fisPhys);
+    writeRegister(AHCI_PORTREG_FISLISTBASE2, 0);
+
+    // Disable transitions to partial or slumber state
+    writeRegister(AHCI_PORTREG_SATACTRL, readRegister(AHCI_PORTREG_SATACTRL) | (1<<8) | (1<<9));
+
+	// Clear IRQ status and error bits
+    writeRegister(AHCI_PORTREG_INTSTATUS, readRegister(AHCI_PORTREG_INTSTATUS));
+    writeRegister(AHCI_PORTREG_SATAERROR, readRegister(AHCI_PORTREG_SATAERROR));
+
+	// Power and Spin up device
+    writeRegister(AHCI_PORTREG_CMDANDSTATUS, readRegister(AHCI_PORTREG_CMDANDSTATUS) | PORT_CMD_POD | PORT_CMD_SUD);
+
+	// Activate link
+	writeRegister(AHCI_PORTREG_CMDANDSTATUS, (readRegister(AHCI_PORTREG_CMDANDSTATUS) & ~PORT_CMD_ICC_MASK) | PORT_CMD_ICC_ACTIVE);
+
+	// Enable FIS receive (enabled when fb set, only to be disabled when unset)
+	writeRegister(AHCI_PORTREG_CMDANDSTATUS, readRegister(AHCI_PORTREG_CMDANDSTATUS) | PORT_CMD_FRE);
+
+    return true;
+}
+
+bool AHCIPort::StartupPort()
+{
+	if(this->Enable() == false)
+		return false;
+	
+	// Enable interrupts
+	writeRegister(AHCI_PORTREG_INTENABLE, PORT_INT_MASK);
+
+	uint32_t portType = this->GetType();
+	//Log(Info, "AHCI: Port %d is of type %d", this->index, portType);
+
+	if(portType != AHCI_DEV_NULL) {
+		// Check if this device is a cdrom device or not
+		this->isATATPI = (portType == AHCI_DEV_SATAPI);
+
+		// Now we can send a Identify command to the device
+		// Data will be the same as with the IDE controller
+		uint16_t identifyBuffer[256];
+		if(this->Identify((uint8_t*)identifyBuffer) == false)
+			return false;
+
+		uint32_t diskSize = 0;
+		char diskModel[41];
+
+		// Extract Command set from buffer
+        uint32_t commandSet = *( (uint32_t*) &identifyBuffer[ATA_IDENT_COMMANDSETS] );
+    
+        // Get Size:
+        if (commandSet & (1 << 26)) {
+            // Device uses 48-Bit Addressing:
+            diskSize = *( (uint32_t*) &identifyBuffer[ATA_IDENT_MAX_LBA_EXT] );
+			this->useLBA48 = true;
+		}
+        else {
+            // Device uses CHS or 28-bit Addressing:
+            diskSize = *( (uint32_t*) &identifyBuffer[ATA_IDENT_MAX_LBA] );
+			this->useLBA48 = false;
+		}
+    
+        // String indicates model of device
+        uint8_t* strPtr = (uint8_t*)identifyBuffer;
+        for(int k = 0; k < 40; k += 2) {
+            diskModel[k] = strPtr[ATA_IDENT_MODEL + k + 1];
+            diskModel[k + 1] = strPtr[ATA_IDENT_MODEL + k];
+        }
+        diskModel[40] = 0; // Terminate String.
+
+		Log(Info, "AHCI: Found %s drive %s", this->isATATPI ? "ATAPI" : "ATA", diskModel);
+        uint32_t sectSize = this->isATATPI ? 2048 : 512;
+
+		// Create disk structure
+		Disk* disk = new Disk(this->index, this->parent, this->isATATPI ? CDROM : HardDisk, (uint64_t)(diskSize / 2U) * (uint64_t)1024, diskSize / 2 / sectSize, sectSize);
+            
+        // Create Identifier
+        int strLen = 40;
+        while(diskModel[strLen - 1] == ' ' && strLen > 1)
+            strLen--;
+        disk->identifier = new char[strLen + 1];
+            
+        MemoryOperations::memcpy(disk->identifier, diskModel, strLen);
+        disk->identifier[strLen] = '\0';
+            
+        System::diskManager->AddDisk(disk);
+	}
+
+    return true;
+}
+
+uint32_t AHCIPort::GetType()
+{
+	uint32_t status = readRegister(AHCI_PORTREG_SATASTATUS);
+ 
+	uint8_t speed = (status >> 8) & 0x0F;
+	uint8_t devDET = status & 0x0F;
+ 
+	if (devDET != AHCI_PORT_DET_PRESENT)	// Check drive status
+		return AHCI_DEV_NULL;
+	if (speed != HBA_PORT_IPM_ACTIVE)
+		return AHCI_DEV_NULL;
+ 
+	switch (readRegister(AHCI_PORTREG_SIGNATURE))
+	{
+		case SATA_SIG_ATAPI:
+			return AHCI_DEV_SATAPI;
+		case SATA_SIG_SEMB:
+			return AHCI_DEV_SEMB;
+		case SATA_SIG_PM:
+			return AHCI_DEV_PM;
+		default:
+			return AHCI_DEV_SATA;
+	}	
+}
+
+bool AHCIPort::Enable()
+{
+	// Wait until CR (bit15) is cleared
+	if (!waitForClear(AHCI_PORTREG_CMDANDSTATUS, PORT_CMD_CR, 500))
+		return false;
+
+	// Start port
+	writeRegister(AHCI_PORTREG_CMDANDSTATUS, readRegister(AHCI_PORTREG_CMDANDSTATUS) | PORT_CMD_ST);
+	return true;
+}
+
+
+bool AHCIPort::Disable()
+{
+	// Disable port
+	writeRegister(AHCI_PORTREG_CMDANDSTATUS, readRegister(AHCI_PORTREG_CMDANDSTATUS) & ~PORT_CMD_ST);
+
+	// Wait until bit is cleared
+	if (!waitForClear(AHCI_PORTREG_CMDANDSTATUS, PORT_CMD_CR, 500))
+		return false;
+
+	return true;
+}
+
+void AHCIPort::HandleExternalInterrupt()
+{
+	uint32_t status = readRegister(AHCI_PORTREG_INTSTATUS);
+	//Log(Info, "AHCIPort: Interrupt %x", status);
+	writeRegister(AHCI_PORTREG_INTSTATUS, status); // Clear interrupts
+}
+
+bool AHCIPort::Identify(uint8_t* buffer)
+{
+	int slot = this->FindFreeCMDSlot();
+	if (slot == -1)
+		return false;
+
+	uint32_t bufPhys = 0;
+	uint8_t* buf = (uint8_t*)KernelHeap::alignedMalloc(512, 16, &bufPhys);
+	MemoryOperations::memset(buf, 0, 512);
+ 
+	a_commandHeader_t* cmdheader = &this->commandList[slot];
+	cmdheader->flags = (sizeof(FIS_REG_H2D) / sizeof(uint32_t)) | (0<<6) | (1<<16);
+
+	uint32_t cmdTablePhys = 0;
+	a_commandTable_t* cmdTable = (a_commandTable_t*)KernelHeap::alignedMalloc(sizeof(a_commandTable_t), 128, &cmdTablePhys);
+	MemoryOperations::memset(cmdTable, 0, sizeof(a_commandTable_t));
+
+	// Make header point to allocated table
+	cmdheader->cmdTableAddress = cmdTablePhys;
+	cmdheader->cmdTableAddressHigh = 0;
+
+	// Setup PRDT Entry
+	cmdTable->prdt_entry[0].dataBase = bufPhys;
+	cmdTable->prdt_entry[0].byteCount = 511;
+	cmdTable->prdt_entry[0].ioc = 1;
+ 
+	// Setup command
+	FIS_REG_H2D* cmdfis = (FIS_REG_H2D*)(&cmdTable->fis);
+ 
+	cmdfis->fis_type = FIS_TYPE_REG_H2D;
+	cmdfis->c = 1;	// Command
+	cmdfis->command = this->isATATPI ? ATA_CMD_IDENTIFY_PACKET : ATA_CMD_IDENTIFY;
+
+	if(!waitForClear(AHCI_PORTREG_TASKFILE, 0x80 | 0x8, 1000)) {
+		Log(Error, "AHCI: Port is stuck!");
+		
+		KernelHeap::allignedFree(buf);
+		KernelHeap::allignedFree(cmdTable);
+		cmdheader->cmdTableAddress = 0;
+		return false;
+	}
+	
+	// Enable command slot
+	writeRegister(AHCI_PORTREG_COMMANDISSUE, 1<<slot);
+
+	bool ret = true;
+ 
+	// Wait for completion
+	while (1)
+	{
+		// In some longer duration reads, it may be helpful to spin on the DPS bit 
+		// in the PxIS port field as well (1 << 5)
+		if ((readRegister(AHCI_PORTREG_COMMANDISSUE) & (1<<slot)) == 0) 
+			break;
+		
+		if (readRegister(AHCI_PORTREG_COMMANDISSUE) & (1<<30)) { // Task file error
+			ret = false;
+			break;
+		}
+	}
+ 
+	// Check again
+	if (readRegister(AHCI_PORTREG_COMMANDISSUE) & (1<<30))
+		ret = false;
+	
+	if(ret)
+		MemoryOperations::memcpy(buffer, buf, 512);
+	
+	KernelHeap::allignedFree(buf);
+	KernelHeap::allignedFree(cmdTable);
+	cmdheader->cmdTableAddress = 0;
+
+	return ret;
+}
+
+bool AHCIPort::TransferData(bool dirIn, uint32_t lba, uint8_t* buffer, uint32_t count)
+{
+	int slot = this->FindFreeCMDSlot();
+	if (slot == -1)
+		return false;
+
+	// Required buffer size
+	uint32_t size = count * (this->isATATPI ? 2048 : 512);
+	uint32_t entryCount = (size / 8_KB + 1); // 8K bytes (16 sectors) per PRDT
+	uint32_t i = 0;
+	uint32_t count2 = count;
+
+	uint32_t bufPhys = 0;
+	uint8_t* buf = (uint8_t*)KernelHeap::alignedMalloc(size, 16, &bufPhys);
+	MemoryOperations::memset(buf, 0, size);
+ 
+	a_commandHeader_t* cmdheader = &this->commandList[slot];
+	cmdheader->flags = (sizeof(FIS_REG_H2D) / sizeof(uint32_t)) | (0<<6) | (entryCount<<16);
+
+	uint32_t cmdTablePhys = 0;
+	a_commandTable_t* cmdTable = (a_commandTable_t*)KernelHeap::alignedMalloc(sizeof(a_commandTable_t) + (entryCount-1) * sizeof(a_prdtEntry_t), 128, &cmdTablePhys);
+	MemoryOperations::memset(cmdTable, 0, sizeof(a_commandTable_t) + (entryCount-1) * sizeof(a_prdtEntry_t));
+
+	// Make header point to allocated table
+	cmdheader->cmdTableAddress = cmdTablePhys;
+	cmdheader->cmdTableAddressHigh = 0;
+
+	// Setup required entries
+	for (i = 0; i < (entryCount-1); i++)
+	{
+		cmdTable->prdt_entry[i].dataBase = bufPhys;
+		cmdTable->prdt_entry[i].byteCount = 8*1024-1;	// 8K bytes (this value should always be set to 1 less than the actual value)
+		cmdTable->prdt_entry[i].ioc = 1;
+		bufPhys += 4*1024;	// 4K words
+		count -= 16;	// 16 sectors
+	}
+	// Last entry
+	cmdTable->prdt_entry[i].dataBase = bufPhys;
+	cmdTable->prdt_entry[i].byteCount = (size % 4_KB)-1; // 512 bytes per sector
+	cmdTable->prdt_entry[i].ioc = 1;
+
+	if(this->isATATPI)
+	{
+		// Setup command
+		FIS_REG_H2D* cmdfis = (FIS_REG_H2D*)(&cmdTable->fis);
+	
+		cmdfis->fis_type = FIS_TYPE_REG_H2D;
+		cmdfis->c = 1;	// Command
+		cmdfis->command = ATA_CMD_PACKET;
+		cmdfis->featurel = 1;
+		cmdfis->featureh = 0;
+		cmdfis->countl = count2 & 0xFF;
+		cmdfis->counth = (count2 >> 8) & 0xFF;
+
+		cmdheader->flags |= (1<<5); // Set A Bit in header flags
+
+		cmdTable->cmd[ 0] = ATAPI_CMD_READ;
+		cmdTable->cmd[ 1] = 0x0;
+		cmdTable->cmd[ 2] = (lba >> 24) & 0xFF;
+		cmdTable->cmd[ 3] = (lba >> 16) & 0xFF;
+		cmdTable->cmd[ 4] = (lba >> 8) & 0xFF;
+		cmdTable->cmd[ 5] = (lba >> 0) & 0xFF;
+		cmdTable->cmd[ 6] = 0x0;
+		cmdTable->cmd[ 7] = 0x0;
+		cmdTable->cmd[ 8] = 0x0;
+		cmdTable->cmd[ 9] = count2;
+		cmdTable->cmd[10] = 0x0;
+		cmdTable->cmd[11] = 0x0;
+	}
+	else
+	{
+		// Setup command
+		FIS_REG_H2D* cmdfis = (FIS_REG_H2D*)(&cmdTable->fis);
+	
+		cmdfis->fis_type = FIS_TYPE_REG_H2D;
+		cmdfis->c = 1;	// Command
+		cmdfis->command = dirIn ? (this->useLBA48 ? ATA_CMD_READ_DMA_EXT : ATA_CMD_READ_DMA) : (this->useLBA48 ? ATA_CMD_WRITE_DMA_EXT : ATA_CMD_WRITE_DMA);
+	
+		cmdfis->lba0 = (uint8_t)lba;
+		cmdfis->lba1 = (uint8_t)(lba>>8);
+		cmdfis->lba2 = (uint8_t)(lba>>16);
+		cmdfis->device = 1<<6;	// LBA mode
+	
+		cmdfis->lba3 = (uint8_t)(lba>>24);
+		cmdfis->lba4 = 0; // TODO: Use when we might ever use 64-bit lba
+		cmdfis->lba5 = 0; // Not used for now
+	
+		cmdfis->countl = count2 & 0xFF;
+		cmdfis->counth = (count2 >> 8) & 0xFF;	
+	}
+
+	if(!waitForClear(AHCI_PORTREG_TASKFILE, 0x80 | 0x8, 1000)) {
+		Log(Error, "AHCI: Port is stuck!");
+		
+		KernelHeap::allignedFree(buf);
+		KernelHeap::allignedFree(cmdTable);
+		cmdheader->cmdTableAddress = 0;
+		return false;
+	}
+	
+	// Enable command slot
+	writeRegister(AHCI_PORTREG_COMMANDISSUE, 1<<slot);
+
+	bool ret = true;
+ 
+	// Wait for completion
+	while (1)
+	{
+		// In some longer duration reads, it may be helpful to spin on the DPS bit 
+		// in the PxIS port field as well (1 << 5)
+		if ((readRegister(AHCI_PORTREG_COMMANDISSUE) & (1<<slot)) == 0) 
+			break;
+		
+		if (readRegister(AHCI_PORTREG_COMMANDISSUE) & (1<<30)) { // Task file error
+			ret = false;
+			break;
+		}
+	}
+ 
+	// Check again
+	if (readRegister(AHCI_PORTREG_COMMANDISSUE) & (1<<30))
+		ret = false;
+	
+	if(ret)
+		MemoryOperations::memcpy(buffer, buf, size);
+	
+	KernelHeap::allignedFree(buf);
+	KernelHeap::allignedFree(cmdTable);
+	cmdheader->cmdTableAddress = 0;
+
+	return ret;
+}			
+
+
+bool AHCIPort::Eject()
+{
+	if(this->isATATPI == false)
+		return false; // This it not going to work, no matter how hard we try :)
+	
+	int slot = this->FindFreeCMDSlot();
+	if (slot == -1)
+		return false;
+ 
+	a_commandHeader_t* cmdheader = &this->commandList[slot];
+	cmdheader->flags = (sizeof(FIS_REG_H2D) / sizeof(uint32_t)) | (0<<6) | (0<<16);
+
+	uint32_t cmdTablePhys = 0;
+	a_commandTable_t* cmdTable = (a_commandTable_t*)KernelHeap::alignedMalloc(sizeof(a_commandTable_t), 128, &cmdTablePhys);
+	MemoryOperations::memset(cmdTable, 0, sizeof(a_commandTable_t));
+
+	// Make header point to allocated table
+	cmdheader->cmdTableAddress = cmdTablePhys;
+	cmdheader->cmdTableAddressHigh = 0;
+
+	// Setup command
+	FIS_REG_H2D* cmdfis = (FIS_REG_H2D*)(&cmdTable->fis);
+	
+	cmdfis->fis_type = FIS_TYPE_REG_H2D;
+	cmdfis->c = 1;	// Command
+	cmdfis->command = ATA_CMD_PACKET;
+	cmdfis->featurel = 1;
+	cmdfis->featureh = 0;
+	cmdfis->countl = 1;
+
+	cmdheader->flags |= (1<<5); // Set A Bit in header flags
+
+	cmdTable->cmd[ 0] = ATAPI_CMD_EJECT;
+	cmdTable->cmd[ 4] = 0x02;
+
+	if(!waitForClear(AHCI_PORTREG_TASKFILE, 0x80 | 0x8, 1000)) {
+		Log(Error, "AHCI: Port is stuck!");
+		
+		KernelHeap::allignedFree(cmdTable);
+		cmdheader->cmdTableAddress = 0;
+		return false;
+	}
+	
+	// Enable command slot
+	writeRegister(AHCI_PORTREG_COMMANDISSUE, 1<<slot);
+
+	bool ret = true;
+ 
+	// Wait for completion
+	while (1)
+	{
+		// In some longer duration reads, it may be helpful to spin on the DPS bit 
+		// in the PxIS port field as well (1 << 5)
+		if ((readRegister(AHCI_PORTREG_COMMANDISSUE) & (1<<slot)) == 0) 
+			break;
+		
+		if (readRegister(AHCI_PORTREG_COMMANDISSUE) & (1<<30)) { // Task file error
+			ret = false;
+			break;
+		}
+	}
+ 
+	// Check again
+	if (readRegister(AHCI_PORTREG_COMMANDISSUE) & (1<<30))
+		ret = false;
+	
+	KernelHeap::allignedFree(cmdTable);
+	cmdheader->cmdTableAddress = 0;
+
+	return ret;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/disk/ide.cpp b/kernelz/src/system/drivers/disk/ide.cpp
new file mode 100644
index 0000000..56617ac
--- /dev/null
+++ b/kernelz/src/system/drivers/disk/ide.cpp
@@ -0,0 +1,845 @@
+#include <system/drivers/disk/ide.h>
+#include <system/system.h>
+#include <system/tasking/scheduler.h>
+#include <system/tasking/lock.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+IDEInterruptHandler::IDEInterruptHandler(IDEController* parent, uint8_t interrupt)
+: InterruptHandler(IDT_INTERRUPT_OFFSET + interrupt)
+{
+    Log(Info, "IDEController adding interrupt handler for int %d", interrupt);
+    this->target = parent;
+}
+
+uint32_t IDEInterruptHandler::HandleInterrupt(uint32_t esp)
+{
+    if(this->target != 0)
+        this->target->HandleIRQ(esp);
+
+    return esp;
+}
+
+
+
+IDEController::IDEController(PCIDevice* device)
+: Driver("PCI IDE Controller", "PCI IDE Controller"),
+  DiskController()
+{
+    this->pciDevice = device;
+    this->devices = List<IDEDevice*>();
+}
+
+uint8_t IDEController::ReadRegister(uint8_t channel, uint8_t reg)
+{
+    uint8_t result = 0;
+    
+    if (reg < 0x08)
+        result = inportb(channels[channel].commandReg + reg);
+    else if (reg < 0x0C)
+        result = inportb(channels[channel].commandReg + reg - 0x06);
+    else if (reg < 0x0E)
+        result = inportb(channels[channel].controlReg + reg - 0x0C);
+    else if (reg < 0x16)
+        result = inportb(channels[channel].bmideReg + reg - 0x0E);
+    
+    return result;
+}
+
+void IDEController::WriteRegister(uint8_t channel, uint8_t reg, uint8_t data)
+{    
+    if (reg < 0x08)
+        outportb(channels[channel].commandReg + reg, data);
+    else if (reg < 0x0C)
+        outportb(channels[channel].commandReg + reg - 0x06, data);
+    else if (reg < 0x0E)
+        outportb(channels[channel].controlReg + reg - 0x0C, data);
+    else if (reg < 0x16)
+        outportb(channels[channel].bmideReg + reg - 0x0E, data);
+}
+
+const void IDEController::Wait400NS(uint8_t channel)
+{
+    inportb(channels[channel].controlReg);
+    inportb(channels[channel].controlReg);
+    inportb(channels[channel].controlReg);
+    inportb(channels[channel].controlReg);
+}
+
+bool IDEController::WaitForClear(uint8_t channel, uint8_t reg, uint8_t bits, uint32_t timeout, bool yield)
+{
+	while (timeout--) {
+		if ((this->ReadRegister(channel, reg) & bits) == 0)
+			return true;
+		
+        if(yield && System::scheduler && System::scheduler->Enabled)
+            System::scheduler->ForceSwitch();
+        else
+            System::pit->Sleep(1);
+	}
+    //Log(Warning, "IDE Wait for clear timed out, status = %b", this->ReadRegister(channel, IDE_REG_ALTSTATUS));
+	return false;
+}
+bool IDEController::WaitForSet(uint8_t channel, uint8_t reg, uint8_t bits, uint32_t timeout, bool yield)
+{
+	while (timeout--) {
+		if ((this->ReadRegister(channel, reg) & bits) == bits)
+			return true;
+		
+        if(yield && System::scheduler && System::scheduler->Enabled)
+            System::scheduler->ForceSwitch();
+        else
+            System::pit->Sleep(1);
+	}
+	return false;
+}
+
+const void IDEController::SetChannelInterruptEnable(uint8_t channel, bool enable)
+{
+    this->WriteRegister(channel, IDE_REG_CONTROL, enable ? IDE_CTRL_IE : IDE_CTRL_ID);
+}
+
+const void IDEController::SetDeviceFeature(uint8_t channel, uint8_t feature, uint8_t arg1, uint8_t arg2, uint8_t arg3, uint8_t arg4)
+{
+    this->WriteRegister(channel, IDE_REG_FEATURES, feature);
+    this->WriteRegister(channel, IDE_REG_SECCOUNT0, arg1);
+    this->WriteRegister(channel, IDE_REG_LBA0, arg2);
+    this->WriteRegister(channel, IDE_REG_LBA1, arg3);
+    this->WriteRegister(channel, IDE_REG_LBA2, arg4);
+    this->WriteRegister(channel, IDE_REG_COMMAND, ATA_CMD_SETFEATURE);
+
+    if(!this->Polling(channel, false))
+        Log(Warning, "IDEController::SetDeviceFeature failed");
+}
+
+const void IDEController::SetCountAndLBA(uint8_t channel, uint16_t count, uint32_t lba, bool extended)
+{
+    if(extended) {
+        // Setup second set of LBA Registers
+        this->WriteRegister(channel, IDE_REG_SECCOUNT1, (count & 0xFF00) >> 8);
+        this->WriteRegister(channel, IDE_REG_LBA3, (lba & 0xFF000000) >> 24);
+        this->WriteRegister(channel, IDE_REG_LBA4, 0);
+        this->WriteRegister(channel, IDE_REG_LBA5, 0);
+    }
+
+    // Setup first set of LBA Registers
+    this->WriteRegister(channel, IDE_REG_SECCOUNT0, count & 0xFF);
+    this->WriteRegister(channel, IDE_REG_LBA0, (lba & 0x00000FF) >> 0);
+    this->WriteRegister(channel, IDE_REG_LBA1, (lba & 0x000FF00) >> 8);
+    this->WriteRegister(channel, IDE_REG_LBA2, (lba & 0x0FF0000) >> 16);
+}
+
+const void IDEController::PrepareSCSI(uint8_t command, uint32_t lba, uint16_t count, bool dma)
+{
+    this->atapiPacket[ 0] = command;
+    this->atapiPacket[ 1] = 0; //dma ? 1 : 0;
+    this->atapiPacket[ 2] = (lba >> 24) & 0xFF;
+    this->atapiPacket[ 3] = (lba >> 16) & 0xFF;
+    this->atapiPacket[ 4] = (lba >> 8) & 0xFF;
+    this->atapiPacket[ 5] = (lba >> 0) & 0xFF;
+    this->atapiPacket[ 6] = 0x0;
+    this->atapiPacket[ 7] = 0x0;
+    this->atapiPacket[ 8] = count >> 8;
+    this->atapiPacket[ 9] = count & 0xFF;
+    this->atapiPacket[10] = 0x0;
+    this->atapiPacket[11] = 0x0;
+
+    if(command == ATAPI_CMD_EJECT)
+        this->atapiPacket[ 4] = 0x02;
+}
+
+const bool IDEController::Polling(uint8_t channel, bool checkError)
+{
+    // Delay 400 nanosecond for BSY to be set:
+    this->Wait400NS(channel);
+    
+    // Wait for BSY to be cleared
+    if(!this->WaitForClear(channel, IDE_REG_ALTSTATUS, IDE_SR_BSY, IDE_TIMEOUT))
+        return false;
+    
+    if (checkError) {
+        uint8_t state = this->ReadRegister(channel, IDE_REG_ALTSTATUS);
+    
+        // Check For Errors
+        if (state & IDE_SR_ERR)
+            return false; // Error.
+    
+        // Check If Device fault
+        if (state & IDE_SR_DF)
+            return false; // Device Fault.
+    
+        // Check DRQ
+        // BSY = 0; DF = 0; ERR = 0 so we should check for DRQ now.
+        if ((state & IDE_SR_DRQ) == 0)
+            return false; // DRQ should be set  
+    }
+    
+    return true;
+}
+
+const void IDEController::PIOReadData(uint8_t channel, bool withIORDY, uint8_t* buffer, uint32_t bytes)
+{
+    if(withIORDY)
+        inportsm(this->channels[channel].commandReg + IDE_REG_DATA, buffer, bytes / sizeof(uint16_t));
+    else {
+        uint16_t* dataPtr = (uint16_t*)buffer;
+        while (bytes >= 2) {
+            if(!WaitForClear(channel, IDE_REG_ALTSTATUS, IDE_SR_BSY, IDE_TIMEOUT)
+              || !WaitForSet(channel, IDE_REG_ALTSTATUS, IDE_SR_DRQ, IDE_TIMEOUT))
+                Log(Error, "IDEController::PIOReadData timeout waiting for BSY and DRQ");
+
+            *dataPtr++ = inportw(this->channels[channel].commandReg + IDE_REG_DATA);
+            bytes -= 2;
+        }
+    }
+}
+
+const void IDEController::PIOWriteData(uint8_t channel, bool withIORDY, uint8_t* buffer, uint32_t bytes)
+{
+    if (withIORDY)
+        outportsm(this->channels[channel].commandReg + IDE_REG_DATA, buffer, bytes / sizeof(uint16_t));
+    else {
+        uint16_t* dataPtr = (uint16_t*)buffer;
+        while (bytes >= 2) {
+            if(!WaitForSet(channel, IDE_REG_ALTSTATUS, IDE_SR_DRQ, IDE_TIMEOUT))
+                Log(Error, "IDEController::PIOReadData timeout waiting for DRQ");
+
+            outportw(this->channels[channel].commandReg + IDE_REG_DATA, *dataPtr++);
+            bytes -= 2;
+        }
+    }
+}
+
+const bool IDEController::SendPacketCommand(uint8_t channel, uint8_t cmd, uint32_t lba, uint16_t count, bool dma, bool iordy)
+{
+    // Inform the Controller which mode we use
+    this->WriteRegister(channel, IDE_REG_FEATURES, dma ? 1 : 0);
+
+    // Tell the Controller the size of buffer and set other registers to 0
+    this->WriteRegister(channel, IDE_REG_SECCOUNT0, 0);
+    this->WriteRegister(channel, IDE_REG_LBA0, 0);
+    this->WriteRegister(channel, IDE_REG_LBA1, ATAPI_SECTOR_SIZE & 0xFF);   // Lower Byte of Sector Size.
+    this->WriteRegister(channel, IDE_REG_LBA2, ATAPI_SECTOR_SIZE >> 8);     // Upper Byte of Sector Size.
+
+    // Disable interrupts
+    this->SetChannelInterruptEnable(channel, false);
+
+    // Send the Packet Command
+    this->WriteRegister(channel, IDE_REG_COMMAND, ATA_CMD_PACKET);
+
+    // Prepare SCSI Packet
+    this->PrepareSCSI(cmd, lba, count, dma);
+
+    // Wait for busy to be set
+    if(!this->Polling(channel, true))
+        return false;
+
+    // Enable interrupts
+    this->SetChannelInterruptEnable(channel, true);
+
+    // Write packet data to data port
+    this->PIOWriteData(channel, iordy, this->atapiPacket, 12);
+
+    return true;
+}
+
+void IDEController::HandleIRQ(uint32_t esp)
+{
+    /*uint8_t status1 =*/ this->ReadRegister(IDE_CHANNEL_PRIMARY, IDE_REG_STATUS);
+    /*uint8_t status2 =*/ this->ReadRegister(IDE_CHANNEL_SECONDARY, IDE_REG_STATUS);
+
+    //Log(Info, "IDE Interrupt (%b, %b)", status1, status2);
+ 
+    /*
+    // Reset Interrupt Status
+    if(status1 & (1<<2))
+        this->WriteRegister(IDE_CHANNEL_PRIMARY, IDE_REG_STATUS, (1<<2));
+
+    if(status2 & (1<<2))
+        this->WriteRegister(IDE_CHANNEL_SECONDARY, IDE_REG_STATUS, (1<<2));
+    */
+
+    this->irqState = true;
+}
+
+const void IDEController::WaitForIRQ()
+{
+    while(!this->irqState)
+        if(System::scheduler && System::scheduler->Enabled)
+            System::scheduler->ForceSwitch();
+        else
+            asm("hlt"); // Might as well offload the CPU
+    
+    this->irqState = false;
+}
+
+bool IDEController::Initialize()
+{
+    uint8_t mode = this->pciDevice->programmingInterfaceID & 0b1111;
+
+    Log(Info, "Initializing PCI-IDE Controller (Mode = %b)", mode);
+
+    // Get Base Address Registers
+    auto BAR0 = System::pci->GetBaseAddressRegister(pciDevice->bus, pciDevice->device, pciDevice->function, 0);
+    auto BAR1 = System::pci->GetBaseAddressRegister(pciDevice->bus, pciDevice->device, pciDevice->function, 1);
+    auto BAR2 = System::pci->GetBaseAddressRegister(pciDevice->bus, pciDevice->device, pciDevice->function, 2);
+    auto BAR3 = System::pci->GetBaseAddressRegister(pciDevice->bus, pciDevice->device, pciDevice->function, 3);
+    auto BAR4 = System::pci->GetBaseAddressRegister(pciDevice->bus, pciDevice->device, pciDevice->function, 4);
+
+    // Setup registers
+    if(mode & (1<<0)) { // Primary channel is operating in Native-PCI Mode
+        this->channels[IDE_CHANNEL_PRIMARY].commandReg = BAR0.address;
+        this->channels[IDE_CHANNEL_PRIMARY].controlReg = BAR1.address;
+    }
+    else { // Primary channel is operating in Compatibility Mode
+        this->channels[IDE_CHANNEL_PRIMARY].commandReg = 0x1F0;
+        this->channels[IDE_CHANNEL_PRIMARY].controlReg = 0x3F6;
+    }
+    if(mode & (1<<2)) { // Secondary channel is operating in Native-PCI Mode
+        this->channels[IDE_CHANNEL_SECONDARY].commandReg = BAR2.address;
+        this->channels[IDE_CHANNEL_SECONDARY].controlReg = BAR3.address;
+    }
+    else { // Secondary channel is operating in Compatibility Mode
+        this->channels[IDE_CHANNEL_SECONDARY].commandReg = 0x170;
+        this->channels[IDE_CHANNEL_SECONDARY].controlReg = 0x376;
+    }
+
+    // Also set Bus Master addres for both channels
+    this->channels[IDE_CHANNEL_PRIMARY].bmideReg = BAR4.address;
+    this->channels[IDE_CHANNEL_SECONDARY].bmideReg = BAR4.address + 8;
+
+    Log(Info, "IDE Registers -> (%x, %x) (%x, %x) (%x, %x)",
+            this->channels[IDE_CHANNEL_PRIMARY].commandReg,
+            this->channels[IDE_CHANNEL_PRIMARY].controlReg,
+            this->channels[IDE_CHANNEL_SECONDARY].commandReg,
+            this->channels[IDE_CHANNEL_SECONDARY].controlReg,
+            this->channels[IDE_CHANNEL_PRIMARY].bmideReg,
+            this->channels[IDE_CHANNEL_SECONDARY].bmideReg);
+
+    // Enable BUS Mastering
+    System::pci->Write(pciDevice->bus, pciDevice->device, pciDevice->function, 0x04, (1<<2) | (1<<0));
+
+    // Setup interrupt handlers
+    this->interruptHandlers[IDE_CHANNEL_PRIMARY] = new IDEInterruptHandler(this, (mode & (1<<0)) ? this->pciDevice->interrupt : 14);
+    if((mode & (1<<2)) == 0) // Secondary channel is operating in Compatibility mode
+        this->interruptHandlers[IDE_CHANNEL_SECONDARY] = new IDEInterruptHandler(this, 15);
+    
+    else if((mode & (1<<0)) == 0) // Secondary channel runs in native mode and we do not have a generic interrupt handler yet (no need to have 2)
+        this->interruptHandlers[IDE_CHANNEL_SECONDARY] = new IDEInterruptHandler(this, this->pciDevice->interrupt);
+
+    // Start device detection, we have possibly 2 drives per channel
+    for (int channel = 0; channel < 2; channel++)
+    {
+        for (int device = 0; device < 2; device++)
+        {   
+            Log(Info, "IDEController checking device %d:%d", channel, device);
+
+            // Type of this device
+            uint8_t type = IDE_ATA; 
+
+            // Select Drive:
+            this->WriteRegister(channel, IDE_REG_HDDEVSEL, 0xA0 | (device << 4));
+            this->Wait400NS(channel);
+
+            // Check if device exists
+            if (this->ReadRegister(channel, IDE_REG_ALTSTATUS) == 0xFF)
+                continue; // Go to next drive
+
+            // First wait for busy to be cleared (likely not active, but just to be sure)
+            if(!this->WaitForClear(channel, IDE_REG_ALTSTATUS, IDE_SR_BSY, IDE_TIMEOUT))
+                continue;
+
+            // Set unused variables to 0
+            this->WriteRegister(channel, IDE_REG_SECCOUNT0, 0);
+            this->WriteRegister(channel, IDE_REG_LBA0, 0);
+            this->WriteRegister(channel, IDE_REG_LBA1, 0);
+            this->WriteRegister(channel, IDE_REG_LBA2, 0);
+
+            // Disable IRQ's
+            this->SetChannelInterruptEnable(channel, false);
+    
+            // Send ATA Identify Command:
+            this->WriteRegister(channel, IDE_REG_COMMAND, ATA_CMD_IDENTIFY);
+            System::pit->Sleep(10);
+    
+            // Check if device exists
+            if (this->ReadRegister(channel, IDE_REG_ALTSTATUS) == 0)
+                continue; // Go to next drive
+
+            bool canBeATAPI = false;
+            while(1) {
+                uint8_t status = this->ReadRegister(channel, IDE_REG_ALTSTATUS);
+                if (status & IDE_SR_ERR) { // If Err, Device is not ATA.
+                    canBeATAPI = true;
+                    break;
+                } 
+                if (!(status & IDE_SR_BSY) && (status & IDE_SR_DRQ)) 
+                    break; // Everything is right.
+            }
+    
+            // Check for ATAPI Devices:
+            if (canBeATAPI) {
+                uint8_t cl = this->ReadRegister(channel, IDE_REG_LBA1);
+                uint8_t ch = this->ReadRegister(channel, IDE_REG_LBA2);
+    
+                if (cl == 0x14 && ch == 0xEB)
+                    type = IDE_ATAPI;
+                else if (cl == 0x69 && ch == 0x96)
+                    type = IDE_ATAPI;
+                else
+                    continue; // Unknown Type (may not be a device).
+
+                // Send IDENTIFY_PACKET command instead
+                this->WriteRegister(channel, IDE_REG_COMMAND, ATA_CMD_IDENTIFY_PACKET);
+                System::pit->Sleep(10);
+            }
+
+            if(this->ReadRegister(channel, IDE_REG_ALTSTATUS) == 0xFF)
+                continue; // Not connected
+
+            ////////////////////
+            // We assume valid drive if we get here
+            ////////////////////
+
+            // Read Identification Space of the Device:
+            uint16_t identifyBuffer[256];
+            MemoryOperations::memset(identifyBuffer, 0, sizeof(identifyBuffer));
+            for(int i = 0; i < 256; i++)
+                identifyBuffer[i] = inportw(this->channels[channel].commandReg + IDE_REG_DATA);
+
+            // Construct IDE-Device structure
+            IDEDevice* dev = new IDEDevice();
+            MemoryOperations::memset(dev, 0, sizeof(IDEDevice));
+
+            // Set vars
+            dev->Type = type;
+            dev->Channel = channel;
+            dev->Drive = device;
+
+            // Extract information from Identify Packet
+            dev->specs.use48_Bit = identifyBuffer[ATA_IDENT_COMMANDSETS] & (1<<10);
+            dev->specs.IO_Ready = identifyBuffer[ATA_IDENT_CAPABILITIES] & (1<<11);
+            dev->specs.dmaLevel = -1;
+
+            // Check if Master IDE capability bit is set
+            if(this->pciDevice->programmingInterfaceID & (1<<7)) 
+            {
+                // Check for UDMA support
+                uint16_t dmaSupportedBits = 0;
+                if(identifyBuffer[53] & (1<<2)) // Bits in word 88 are valid
+                    dmaSupportedBits = identifyBuffer[88] & 0b111111;
+
+                // Look for highest supported UDMA
+                for (dev->specs.dmaLevel = 5; dev->specs.dmaLevel >= 0; --dev->specs.dmaLevel) {
+                    if (dmaSupportedBits & (1 << dev->specs.dmaLevel))
+                        break;
+                }
+
+                // Check for MWDMA
+                if (dev->specs.dmaLevel < 0) {
+                    dmaSupportedBits = identifyBuffer[63] & 0b111;
+
+                    for (dev->specs.dmaLevel = 2; dev->specs.dmaLevel >= 0; --dev->specs.dmaLevel) {
+                        if (dmaSupportedBits & (1 << dev->specs.dmaLevel))
+                            break;
+                    }
+
+                    // Fall back to old MWDMA
+                    if (dev->specs.dmaLevel >= 0)
+                        dev->specs.legacyDMA = true;
+                }
+            }
+
+            if(IDE_DEV_DMA(dev)) // We need to setup DMA structres for this device
+            {
+                // Wait for busy to be cleared first
+                if(!this->WaitForClear(channel, IDE_REG_ALTSTATUS, IDE_SR_BSY, IDE_TIMEOUT))
+                    continue; // Hard to believe drive is not valid here, but still ignore it
+
+                if (dev->specs.legacyDMA) {
+                    // Enable MWDMA
+                    Log(Info, "Enabling MWDMA level %d for drive %d:%d", dev->specs.dmaLevel, channel, device);
+                    this->SetDeviceFeature(channel, ATA_FEATURE_TRANSFER_MODE, (1<<5) | dev->specs.dmaLevel);
+                } else {
+                    // Enable UDMA
+                    Log(Info, "Enabling UDMA level %d for drive %d:%d", dev->specs.dmaLevel, channel, device);
+                    this->SetDeviceFeature(channel, ATA_FEATURE_TRANSFER_MODE, (1<<6) | dev->specs.dmaLevel);
+                }
+
+                // Setup DMA Stuff
+                dev->prdt = (IDEPhysRegionDescriptor*)KernelHeap::alignedMalloc(sizeof(IDEPhysRegionDescriptor), 32, &dev->prdtPhys);
+                MemoryOperations::memset(dev->prdt, 0, sizeof(IDEPhysRegionDescriptor));
+                dev->prdtBuffer = (uint8_t*)KernelHeap::alignedMalloc(PAGE_SIZE, PAGE_SIZE, &dev->prdtBufferPhys);
+                MemoryOperations::memset(dev->prdtBuffer, 0, PAGE_SIZE);
+
+                // Setup PRDT
+                dev->prdt->bufferPtrPhys = dev->prdtBufferPhys;
+                dev->prdt->byteCount = ATA_SECTOR_SIZE;
+                dev->prdt->flags = (1<<15);
+            }
+
+            // Get Size for ATA drive
+            // TODO: Find method for ATAPI
+            if(type == IDE_ATA) {
+                if (dev->specs.use48_Bit)
+                    dev->Size = (uint32_t) *( (uint64_t*) &identifyBuffer[ATA_IDENT_MAX_LBA_EXT] );
+                else
+                    dev->Size = *( (uint32_t*) &identifyBuffer[ATA_IDENT_MAX_LBA] );
+            }
+            else
+                dev->Size = 0;
+    
+            // String indicates model of device
+            uint8_t* strPtr = (uint8_t*)identifyBuffer;
+            for(int k = 0; k < 40; k += 2) {
+                dev->Model[k] = strPtr[ATA_IDENT_MODEL + k + 1];
+                dev->Model[k + 1] = strPtr[ATA_IDENT_MODEL + k];
+            }
+            dev->Model[40] = 0; // Terminate String.
+
+            // Enable interrupts again
+            this->SetChannelInterruptEnable(channel, true);
+
+            // Finally add device to list
+            this->devices.push_back(dev);
+        }
+    }
+
+    // Print Summary of found devices
+    for (int i = 0; i < this->devices.size(); i++) {  
+        BootConsole::Write("Found "); BootConsole::Write(this->devices[i]->Type == 0 ? (char*)"ATA" : (char*)"ATAPI");
+        BootConsole::Write(" Drive "); BootConsole::Write(Convert::IntToString(this->devices[i]->Size / 1024 / 2));
+        BootConsole::Write(" MB - "); BootConsole::Write((char*)this->devices[i]->Model);
+        BootConsole::WriteLine(IDE_DEV_DMA(this->devices[i]) ? (char*)" (DMA Enabled)" : (char*)"");
+
+        // Create new system disk
+        uint32_t sectSize = this->devices[i]->Type == 0 ? ATA_SECTOR_SIZE : ATAPI_SECTOR_SIZE;
+        Disk* disk = new Disk(i, this, this->devices[i]->Type == 0 ? HardDisk : CDROM, (uint64_t)(this->devices[i]->Size / 2U) * (uint64_t)1024, this->devices[i]->Size / 2 / sectSize, sectSize);
+        
+        // Create Identifier
+        int strLen = 40;
+        while(this->devices[i]->Model[strLen - 1] == ' ' && strLen > 1)
+            strLen--;
+        
+        // Allocate memory for identifier
+        disk->identifier = new char[strLen + 1];
+
+        // And copy string
+        MemoryOperations::memcpy(disk->identifier, this->devices[i]->Model, strLen);
+        disk->identifier[strLen] = '\0';
+        
+        // Finally add disk to system
+        System::diskManager->AddDisk(disk);
+    }
+
+    return true;
+}
+
+char IDEController::ATA_DMA_TransferSector(uint16_t drive, uint32_t lba, uint8_t* buf, bool read)
+{
+    IDEDevice* dev = this->devices[drive];
+    dev->prdt->byteCount = ATA_SECTOR_SIZE;
+
+    // Write data to DMA buffer
+    if(!read)
+        MemoryOperations::memcpy(dev->prdtBuffer, buf, ATA_SECTOR_SIZE);
+
+    // Reset DMA command register
+    this->WriteRegister(dev->Channel, IDE_REG_BMI_CMD, 0);
+
+    // Set PDRT Pointer
+    outportl(this->channels[dev->Channel].bmideReg + 4, dev->prdtPhys);
+
+    // Enable interrupts
+    this->SetChannelInterruptEnable(dev->Channel, true);
+
+    if(lba > 0xFFFFFFF) // We need to use 48-Bit addressing for this LBA
+    {
+        if(!dev->specs.use48_Bit)
+            return 1; // 48-Bit addressing needs to be supported by drive
+
+        // Select Drive
+        this->WriteRegister(dev->Channel, IDE_REG_HDDEVSEL, 0xE0 | (dev->Drive << 4));
+
+        // Setup registers for LBA address and sector count
+        this->SetCountAndLBA(dev->Channel, 1, lba, true);
+
+        if(read)
+            this->WriteRegister(dev->Channel, IDE_REG_COMMAND, ATA_CMD_READ_DMA_EXT); // Send command
+        else
+            this->WriteRegister(dev->Channel, IDE_REG_COMMAND, ATA_CMD_WRITE_DMA_EXT); // Send command
+    }
+    else // Just use 28-Bit addressing
+    {
+        // Select Drive
+        this->WriteRegister(dev->Channel, IDE_REG_HDDEVSEL, 0xE0 | (dev->Drive << 4) | (lba & 0xF000000) >> 24);
+    
+        // Setup registers for LBA address and sector count
+        this->SetCountAndLBA(dev->Channel, 1, lba, false);
+
+        if(read)
+            this->WriteRegister(dev->Channel, IDE_REG_COMMAND, ATA_CMD_READ_DMA); // Send command
+        else
+            this->WriteRegister(dev->Channel, IDE_REG_COMMAND, ATA_CMD_WRITE_DMA); // Send command
+    }
+
+    // Start DMA operation by setting the right bits in the Command Register
+    this->WriteRegister(dev->Channel, IDE_REG_BMI_CMD, (!read << 3) | (1<<0));
+
+    // Wait for IRQ to happen, this is the true power of DMA because we can other stuff meanwhile
+    this->WaitForIRQ();
+
+    // Reset DMA Command register
+    this->WriteRegister(dev->Channel, IDE_REG_BMI_CMD, 0);
+
+    // Read status registers to check for errors
+    uint8_t ctrlStatus = this->ReadRegister(dev->Channel, IDE_REG_BMI_STS);
+    uint8_t devStatus = this->ReadRegister(dev->Channel, IDE_REG_STATUS);
+
+    // Reset status bits in Bus Master Status
+    this->WriteRegister(dev->Channel, IDE_REG_BMI_STS, ctrlStatus);
+
+    if(ctrlStatus & (1<<1) || devStatus & (1<<0))
+        return 1; // Error occurred
+
+    if(read)
+        MemoryOperations::memcpy(buf, dev->prdtBuffer, ATA_SECTOR_SIZE);
+    else
+    {
+        // In the case of a write we also need to send a Cache flush command
+        this->SetCountAndLBA(dev->Channel, 0, 0, false);
+        this->WriteRegister(dev->Channel, IDE_REG_FEATURES, 0);
+
+        if(lba > 0xFFFFFFF)
+            this->WriteRegister(dev->Channel, IDE_REG_COMMAND, ATA_CMD_CACHE_FLUSH_EXT);
+        else
+            this->WriteRegister(dev->Channel, IDE_REG_COMMAND, ATA_CMD_CACHE_FLUSH);
+
+        // Wait for IRQ and ignore errors
+        this->WaitForIRQ();
+    }
+
+    return 0;
+}
+
+char IDEController::ATAPI_DMA_TransferSector(uint16_t drive, uint16_t lba, uint8_t* buf)
+{
+    IDEDevice* dev = this->devices[drive];
+    dev->prdt->byteCount = ATAPI_SECTOR_SIZE;
+
+    // Set PDRT Pointer
+    outportl(this->channels[dev->Channel].bmideReg + 4, dev->prdtPhys);
+
+    // Set DMA transfer direction (READ)
+    this->WriteRegister(dev->Channel, IDE_REG_BMI_CMD, (1<<3));
+
+    // Reset status bits in Bus Master Status
+    this->WriteRegister(dev->Channel, IDE_REG_BMI_STS, this->ReadRegister(dev->Channel, IDE_REG_BMI_STS) | (1<<2) | (1<<1));
+
+    // Select drive
+    this->WriteRegister(dev->Channel, IDE_REG_HDDEVSEL, dev->Drive << 4);
+
+    // Wait for select
+    this->Wait400NS(dev->Channel);
+
+    // Send packet to device
+    if(!this->SendPacketCommand(dev->Channel, ATAPI_CMD_READ, lba, 1, true, dev->specs.IO_Ready))
+        return 1;
+
+    // Start DMA operation by setting the right bits in the Command Register
+    this->WriteRegister(dev->Channel, IDE_REG_BMI_CMD, (1<<3) | (1<<0));
+
+    // Wait for DMA operation to complete by waiting for interrupt
+    this->WaitForIRQ();
+
+    // Read status registers to check for errors
+    uint8_t ctrlStatus = this->ReadRegister(dev->Channel, IDE_REG_BMI_STS);
+    uint8_t devStatus = this->ReadRegister(dev->Channel, IDE_REG_STATUS);
+
+    // Reset DMA Command register (Stop DMA)
+    this->WriteRegister(dev->Channel, IDE_REG_BMI_CMD, 0);
+
+    // Wait for active to be cleared
+    if(!this->WaitForClear(dev->Channel, IDE_REG_BMI_STS, (1<<0), IDE_TIMEOUT, true))
+        return 1;
+
+    if(ctrlStatus & (1<<1) || devStatus & (1<<0))
+        return 1; // Error occurred
+
+    MemoryOperations::memcpy(buf, dev->prdtBuffer, ATAPI_SECTOR_SIZE);
+
+    return 0;
+}
+
+char IDEController::ATA_PIO_TransferSector(uint16_t drive, uint32_t lba, uint8_t* buf, bool read)
+{
+    IDEDevice* dev = this->devices[drive];
+
+    // Disable interrupts
+    this->SetChannelInterruptEnable(dev->Channel, false);
+
+    // Wait for busy to be cleared
+    if(!this->WaitForClear(dev->Channel, IDE_REG_ALTSTATUS, IDE_SR_BSY, IDE_TIMEOUT))
+        return 1;
+
+    if(lba > 0xFFFFFFF) // We need to use 48-Bit addressing for this LBA
+    {
+        if(!dev->specs.use48_Bit)
+            return 1; // 48-Bit addressing needs to be supported by drive
+
+        // Select Drive
+        this->WriteRegister(dev->Channel, IDE_REG_HDDEVSEL, 0xE0 | (dev->Drive << 4));
+
+        // Setup registers for LBA address and sector count
+        this->SetCountAndLBA(dev->Channel, 1, lba, true);
+
+        if(read)
+            this->WriteRegister(dev->Channel, IDE_REG_COMMAND, ATA_CMD_READ_PIO_EXT); // Send command
+        else
+            this->WriteRegister(dev->Channel, IDE_REG_COMMAND, ATA_CMD_WRITE_PIO_EXT); // Send command
+    }
+    else // Just use 28-Bit addressing
+    {
+        // Select Drive
+        this->WriteRegister(dev->Channel, IDE_REG_HDDEVSEL, 0xE0 | (dev->Drive << 4) | (lba & 0xF000000) >> 24);
+    
+        // Setup registers for LBA address and sector count
+        this->SetCountAndLBA(dev->Channel, 1, lba, false);
+
+        if(read)
+            this->WriteRegister(dev->Channel, IDE_REG_COMMAND, ATA_CMD_READ_PIO); // Send command
+        else
+            this->WriteRegister(dev->Channel, IDE_REG_COMMAND, ATA_CMD_WRITE_PIO); // Send command
+    }
+
+    if(this->Polling(dev->Channel, true) == false)
+        return 1;
+    
+    // Transfer data through data port
+    if(read)
+        this->PIOReadData(dev->Channel, dev->specs.IO_Ready, buf, ATA_SECTOR_SIZE);
+    else {
+        this->PIOWriteData(dev->Channel, dev->specs.IO_Ready, buf, ATA_SECTOR_SIZE);
+
+        // In the case of a write we also need to send a Cache flush command
+        if(lba > 0xFFFFFFF)
+            this->WriteRegister(dev->Channel, IDE_REG_COMMAND, ATA_CMD_CACHE_FLUSH_EXT);
+        else
+            this->WriteRegister(dev->Channel, IDE_REG_COMMAND, ATA_CMD_CACHE_FLUSH);
+        
+        // Poll again and ignore any possible errors
+        if(this->Polling(dev->Channel, false) == false)
+            return 1;
+    }
+
+    // All should have gone fine if we get here
+    return 0;
+}
+
+char IDEController::ATAPI_PIO_TransferSector(uint16_t drive, uint16_t lba, uint8_t* buf)
+{
+    IDEDevice* dev = this->devices[drive];
+
+    // Select drive
+    this->WriteRegister(dev->Channel, IDE_REG_HDDEVSEL, dev->Drive << 4);
+
+    // Wait for select
+    this->Wait400NS(dev->Channel);
+
+    // Send packet to device
+    if(!this->SendPacketCommand(dev->Channel, ATAPI_CMD_READ, lba, 1, false, dev->specs.IO_Ready))
+        return 1;
+
+    // Wait for IRQ
+    this->WaitForIRQ();
+
+    // Check for errors by polling (could also check status register but this works fine)
+    if(!this->Polling(dev->Channel, true))
+        return 1;
+
+    // Finally read data
+    this->PIOReadData(dev->Channel, dev->specs.IO_Ready, buf, ATAPI_SECTOR_SIZE);
+
+    return 0;
+}
+
+
+char IDEController::ReadSector(uint16_t drive, uint32_t lba, uint8_t* buf)
+{
+    // Prevent multiple processes from using this function at the same time
+    this->ideLock.Lock();
+
+    uint8_t returnCode = 1;
+    if(this->devices[drive]->Type == IDE_ATA) 
+    {
+        if(IDE_DEV_DMA(this->devices[drive]))
+            returnCode = this->ATA_DMA_TransferSector(drive, lba, buf, true);
+        else
+            returnCode = this->ATA_PIO_TransferSector(drive, lba, buf, true);
+    }
+    else if (this->devices[drive]->Type == IDE_ATAPI)
+    {
+        if(IDE_DEV_DMA(this->devices[drive]))
+            returnCode = this->ATAPI_DMA_TransferSector(drive, lba, buf);
+        else
+            returnCode = this->ATAPI_PIO_TransferSector(drive, lba, buf);
+    }
+
+    // Everything is processed so an other process can have access to this function
+    this->ideLock.Unlock();
+
+    return returnCode;
+}
+
+char IDEController::WriteSector(uint16_t drive, uint32_t lba, uint8_t* buf)
+{
+    // Prevent multiple processes from using this function at the same time
+    this->ideLock.Lock();
+
+    uint8_t returnCode = 1;
+    if(this->devices[drive]->Type == IDE_ATA) 
+    {
+        if(IDE_DEV_DMA(this->devices[drive]))
+            returnCode = this->ATA_DMA_TransferSector(drive, lba, buf, false);
+        else
+            returnCode = this->ATA_PIO_TransferSector(drive, lba, buf, false);
+    }
+    else if (this->devices[drive]->Type == IDE_ATAPI)
+        Log(Error, "IDEController ATAPI::WriteSector not supported!");
+
+    // Everything is processed so an other process can have access to this function
+    this->ideLock.Unlock();
+
+    return returnCode;
+}
+
+bool IDEController::EjectDrive(uint8_t drive)
+{
+    IDEDevice* dev = this->devices[drive];
+
+    if(dev->Type != IDE_ATAPI)
+        return false;
+
+    // Select drive
+    this->WriteRegister(dev->Channel, IDE_REG_HDDEVSEL, dev->Drive << 4);
+
+    // Wait for select
+    this->Wait400NS(dev->Channel);
+
+    // Send packet to device
+    if(!this->SendPacketCommand(dev->Channel, ATAPI_CMD_EJECT, 0, 0, false, dev->specs.IO_Ready))
+        return 1;
+
+    // Wait for IRQ
+    this->WaitForIRQ();
+
+    // Check for errors by polling (could also check status register but this works fine)
+    if(!this->Polling(dev->Channel, false))
+        return false;
+
+    return true;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/driver.cpp b/kernelz/src/system/drivers/driver.cpp
new file mode 100644
index 0000000..e52b838
--- /dev/null
+++ b/kernelz/src/system/drivers/driver.cpp
@@ -0,0 +1,25 @@
+#include <system/drivers/driver.h>
+#include <system/log.h>
+
+using namespace CactusOS;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+Driver::Driver(char* name, char* description)
+{
+    this->Name = name;
+    this->Description = description;
+}
+                
+char* Driver::GetDriverName() {
+    return this->Name; 
+}
+char* Driver::GetDriverDescription() {
+    return this->Description;
+}
+
+bool Driver::Initialize()
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+    return false;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/drivermanager.cpp b/kernelz/src/system/drivers/drivermanager.cpp
new file mode 100644
index 0000000..3e0ce12
--- /dev/null
+++ b/kernelz/src/system/drivers/drivermanager.cpp
@@ -0,0 +1,27 @@
+#include <system/drivers/drivermanager.h>
+#include <system/log.h>
+
+using namespace CactusOS;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+DriverManager::DriverManager()
+{
+    this->driverList.Clear();
+}
+
+void DriverManager::AddDriver(Driver* drv)
+{
+    this->driverList.push_back(drv);
+}
+
+void DriverManager::ActivateAll()
+{
+    for(int i = 0; i < driverList.size(); i++)
+    {
+        Log(Info, "Activating driver %s", driverList[i]->GetDriverName());
+        
+        if(driverList[i]->Initialize() == false)
+            Log(Error, "driver initialize failed for driver -> %s ", driverList[i]->GetDriverName());
+    }
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/integrated/floppy.cpp b/kernelz/src/system/drivers/integrated/floppy.cpp
new file mode 100644
index 0000000..cc08da2
--- /dev/null
+++ b/kernelz/src/system/drivers/integrated/floppy.cpp
@@ -0,0 +1,485 @@
+#include <system/drivers/integrated/floppy.h>
+#include <core/port.h>
+#include <system/memory/deviceheap.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+using namespace CactusOS::core;
+
+static const char* FloppyTypes[8] = {
+    "none",
+    "360kB 5.25\"",
+    "1.2MB 5.25\"",
+    "720kB 3.5\"",
+
+    "1.44MB 3.5\"",
+    "2.88MB 3.5\"",
+    "unknown type",
+    "unknown type"
+};
+
+FloppyDriver::FloppyDriver()
+: InterruptHandler(IDT_INTERRUPT_OFFSET + 0x6), Driver("Floppy Driver", "Controls the floppy drives present on the system"), DiskController()
+{
+    this->IrqHasFired = false;
+}
+
+bool FloppyDriver::Initialize()
+{
+	// Check if there even is a floppy present
+	outportb(0x70, 0x10);
+    uint8_t drives = inportb(0x71);
+
+	this->flpy1 = drives >> 4;
+	this->flpy2 = drives & 0xF;
+	bool present = false;
+	if(flpy1 != 0)
+		{Log(Info, "%s in slot 1", FloppyTypes[flpy1]); present = true;}
+	if(flpy2 != 0)
+		{Log(Info, "%s in slot 2", FloppyTypes[flpy2]); present = true;}
+	
+	if(!present) {
+		Log(Info, "No Floppies installed on this controller");
+		return false; // Why should we initialize when there are no floppies?
+	}
+
+    // Use address below 1MB for buffer, should be possible until 16MB but this does not seem to work
+    this->bufferVirt = (uint8_t*)DeviceHeap::AllocateChunk(PAGE_SIZE);
+	this->bufferPhys = 0x8000;
+	VirtualMemoryManager::mapVirtualToPhysical((void*)this->bufferPhys, this->bufferVirt, true, true);
+	MemoryOperations::memset(this->bufferVirt, 0, BYTES_PER_SECT);
+
+	//Log(Info, "Using floppy buffer at: virt -> %x  phys -> %x", (uint32_t)this->bufferVirt, this->bufferPhys);
+
+    //! reset the fdc
+	ResetController();
+
+	//! set drive information
+	ConfigureDrive(13, 1, 0xf, true);
+
+	// Assign disks
+	if(this->flpy1) {
+		Disk* disk1 = new Disk(0, this, DiskType::Floppy, 1_MB + 440_KB, (1_MB + 440_KB) / 512, 512);
+		disk1->identifier = "Floppy 1";
+		System::diskManager->AddDisk(disk1);
+	}
+	if(this->flpy2) {
+		Disk* disk2 = new Disk(1, this, DiskType::Floppy, 1_MB + 440_KB, (1_MB + 440_KB) / 512, 512);
+		disk2->identifier = "Floppy 2";
+		System::diskManager->AddDisk(disk2);
+	}
+
+    return true;
+}
+
+bool FloppyDriver::InitializeDMA(FloppyDirection dir)
+{
+    union {
+        uint8_t byte[4];//Lo[0], Mid[1], Hi[2]
+        unsigned long l;
+    } a, c;
+
+    a.l = (unsigned)this->bufferPhys;
+    c.l = (unsigned)BYTES_PER_SECT-1;
+
+ 	// check that address is at most 24-bits (under 16MB)
+    // check that count is at most 16-bits (DMA limit)
+    // check that if we add count and address we don't get a carry
+    // (DMA can't deal with such a carry, this is the 64k boundary limit)
+    if ((a.l >> 24) || (c.l >> 16) || (((a.l & 0xFFFF)+c.l) >> 16)){
+        return false;
+    }
+
+    System::dma->Reset(1);
+    System::dma->MaskChannel(FDC_DMA_CHANNEL); //Mask channel 2
+    System::dma->ResetFlipFlop(1); //Flipflop reset on DMA 1
+
+    System::dma->SetChannelAddress(FDC_DMA_CHANNEL, a.byte[0],a.byte[1]); //Buffer address
+	//System::dma->SetExternalPageRegister(FDC_DMA_CHANNEL, a.byte[2]);
+
+    System::dma->ResetFlipFlop(1); //Flipflop reset on DMA 1
+
+    System::dma->SetChannelCounter(FDC_DMA_CHANNEL, c.byte[0],c.byte[1]); //Set count
+
+	if(dir == FloppyDirectionWrite)
+		System::dma->ChannelPrepareWrite(FDC_DMA_CHANNEL);
+	else
+    	System::dma->ChannelPrepareRead(FDC_DMA_CHANNEL);
+
+    System::dma->UnmaskAll(1); //Unmask channel 2
+
+    return true;
+}
+
+uint32_t FloppyDriver::HandleInterrupt(uint32_t esp)
+{
+    this->IrqHasFired = true;
+    return esp;
+}
+
+void FloppyDriver::WaitForIRQ()
+{
+	while (this->IrqHasFired == false)
+        asm("pause");
+    
+	this->IrqHasFired = false;
+}
+
+void FloppyDriver::WriteDOR(uint8_t val)
+{
+    outportb(FLPYDSK_DOR, val);
+}
+
+void FloppyDriver::WriteCCR(uint8_t val) 
+{
+	//! write the configuation control
+	outportb(FLPYDSK_CTRL, val);
+}
+
+uint8_t FloppyDriver::ReadStatus()
+{
+    return inportb(FLPYDSK_MSR);
+}
+
+void FloppyDriver::SendCommand(uint8_t cmd) 
+{
+	//! wait until data register is ready. We send commands to the data register
+	for (int i = 0; i < 500; i++ )
+		if (ReadStatus() & FLPYDSK_MSR_MASK_DATAREG)
+			return outportb(FLPYDSK_FIFO, cmd);
+}
+ 
+uint8_t FloppyDriver::ReadData() 
+{
+	//! same as above function but returns data register for reading
+	for (int i = 0; i < 500; i++ )
+		if (ReadStatus() & FLPYDSK_MSR_MASK_DATAREG)
+			return inportb(FLPYDSK_FIFO);
+	
+	return inportb(FLPYDSK_FIFO);
+}
+
+//! check interrupt status command
+void FloppyDriver::CheckIntStatus(uint32_t* st0, uint32_t* cyl)
+{
+	SendCommand(FDC_CMD_CHECK_INT);
+
+	*st0 = ReadData();
+	*cyl = ReadData();
+}
+
+//! turns the current floppy drives motor on/off
+void FloppyDriver::ControlMotor(uint8_t drive, bool on)
+{
+	uint8_t motor = 0;
+
+	//! select the correct mask based on current drive
+	switch (drive) {
+
+		case 0:
+			motor = FLPYDSK_DOR_MASK_DRIVE0_MOTOR;
+			break;
+		case 1:
+			motor = FLPYDSK_DOR_MASK_DRIVE1_MOTOR;
+			break;
+		case 2:
+			motor = FLPYDSK_DOR_MASK_DRIVE2_MOTOR;
+			break;
+		case 3:
+			motor = FLPYDSK_DOR_MASK_DRIVE3_MOTOR;
+			break;
+	}
+
+	//! turn on or off the motor of that drive
+	if (on)
+		WriteDOR(uint8_t(drive | motor | FLPYDSK_DOR_MASK_RESET | FLPYDSK_DOR_MASK_DMA));
+	else
+		WriteDOR(FLPYDSK_DOR_MASK_RESET);
+
+	//! in all cases; wait a little bit for the motor to spin up/turn off
+	System::pit->Sleep(20);
+}
+//! configure drive
+void FloppyDriver::ConfigureDrive(uint8_t stepr, uint8_t loadt, uint8_t unloadt, bool dma) 
+{
+	uint8_t data = 0;
+
+	//! send command
+	SendCommand(FDC_CMD_SPECIFY);
+
+	data = ( (stepr & 0xf) << 4) | (unloadt & 0xf);
+	SendCommand(data);
+
+	data = (( loadt << 1 ) | ( (dma) ? 0 : 1 ) );
+	SendCommand(data);
+}
+
+//! calibrates the drive
+int FloppyDriver::Calibrate(uint8_t drive) 
+{
+	uint32_t st0, cyl;
+
+	if (drive >= 4)
+		return -2;
+
+	//! turn on the motor
+	ControlMotor(drive, true);
+
+	for (int i = 0; i < 10; i++) {
+
+		//! send command
+		SendCommand(FDC_CMD_CALIBRATE);
+		SendCommand(drive);
+		WaitForIRQ();
+		CheckIntStatus(&st0, &cyl);
+
+		//! did we find cylinder 0? if so, we are done
+		if (!cyl) {
+			ControlMotor(drive, false);
+			return 0;
+		}
+	}
+
+	ControlMotor(drive, false);
+	return -1;
+}
+
+//! seek to given track/cylinder
+int FloppyDriver::Seek(uint8_t drive, uint8_t cyl, uint8_t head) 
+{
+	uint32_t st0, cyl0;
+
+	for (int i = 0; i < 10; i++ ) {
+
+		//! send the command
+		SendCommand(FDC_CMD_SEEK);
+		SendCommand((head) << 2 | drive);
+		SendCommand(cyl);
+
+		//! wait for the results phase IRQ
+		WaitForIRQ();
+		CheckIntStatus(&st0, &cyl0);
+
+		//! found the cylinder?
+		if (cyl0 == cyl)
+			return 0;
+	}
+
+	return -1;
+}
+
+//! disable controller
+void FloppyDriver::DisableController() 
+{
+	WriteDOR(0);
+}
+
+//! enable controller
+void FloppyDriver::EnableController() 
+{
+	WriteDOR(FLPYDSK_DOR_MASK_RESET | FLPYDSK_DOR_MASK_DMA);
+}
+
+//! reset controller
+void FloppyDriver::ResetController()
+{
+	uint32_t st0, cyl;
+
+	//! reset the controller
+	DisableController();
+	EnableController();
+	WaitForIRQ();
+
+	//! send CHECK_INT/SENSE INTERRUPT command to all drives
+	for (int i=0; i < 4; i++)
+		CheckIntStatus(&st0,&cyl);
+
+	//! transfer speed 500kb/s
+	WriteCCR(0);
+
+	//! pass mechanical drive info. steprate=3ms, unload time=240ms, load time=16ms
+	ConfigureDrive(3, 16, 240, true);
+
+	//! calibrate the disks
+	if(this->flpy1)
+		Calibrate(0);
+	if(this->flpy2)
+		Calibrate(1);
+}
+
+int FloppyDriver::TransferSectorCHS(uint8_t drive, FloppyDirection dir, uint8_t head, uint8_t track, uint8_t sector)
+{ 
+	//! set the DMA for read transfer
+	InitializeDMA(dir);
+
+	System::pit->Sleep(100);
+ 
+	//! read in a sector
+	SendCommand((dir == FloppyDirectionRead ? FDC_CMD_READ_SECT : FDC_CMD_WRITE_SECT) | FDC_CMD_EXT_MULTITRACK | FDC_CMD_EXT_SKIP | FDC_CMD_EXT_DENSITY);
+	SendCommand(head << 2 | drive);
+	SendCommand(track);
+	SendCommand(head);
+	SendCommand(sector);
+	SendCommand(FLPYDSK_SECTOR_DTL_512);
+	SendCommand(((sector + 1) >= FLPY_SECTORS_PER_TRACK) ? FLPY_SECTORS_PER_TRACK : sector + 1);
+	SendCommand(FLPYDSK_GAP3_LENGTH_3_5);
+	SendCommand(0xff);
+ 
+	//! wait for irq
+	WaitForIRQ();
+ 
+	// first read status information
+    unsigned char st0, st1, st2, bps;
+    st0 = ReadData();
+    st1 = ReadData();
+    st2 = ReadData();
+
+    // bytes per sector, should be what we programmed in
+    bps = ReadData();
+
+	//! let FDC know we handled interrupt
+	//CheckIntStatus(&s_st0, &s_cyl);
+
+    int error = 0;
+
+    if(st0 & 0xC0) {
+        static const char * status[] =
+        { 0, "error", "invalid command", "drive not ready" };
+        Log(Error, "Floppy Transfer Error: status = %s", status[st0 >> 6]);
+        error = 1;
+    }
+    if(st1 & 0x80) {
+        Log(Error, "Floppy Transfer Error: end of cylinder");
+        error = 1;
+    }
+    if(st0 & 0x08) {
+        Log(Error, "Floppy Transfer Error: drive not ready");
+        error = 1;
+    }
+    if(st1 & 0x20) {
+        Log(Error, "Floppy Transfer Error: CRC error");
+        error = 1;
+    }
+    if(st1 & 0x10) {
+        Log(Error, "Floppy Transfer Error: controller timeout");
+        error = 1;
+    }
+    if(st1 & 0x04) {
+        Log(Error, "Floppy Transfer Error: no data found");
+        error = 1;
+    }
+    if((st1|st2) & 0x01) {
+        Log(Error, "Floppy Transfer Error: no address mark found");
+        error = 1;
+    }
+    if(st2 & 0x40) {
+        Log(Error, "Floppy Transfer Error: deleted address mark");
+        error = 1;
+    }
+    if(st2 & 0x20) {
+        Log(Error, "Floppy Transfer Error: CRC error in data");
+        error = 1;
+    }
+    if(st2 & 0x10) {
+        Log(Error, "Floppy Transfer Error: wrong cylinder");
+        error = 1;
+    }
+    if(st2 & 0x04) {
+        Log(Error, "Floppy Transfer Error: uPD765 sector not found");
+        error = 1;
+    }
+    if(st2 & 0x02) {
+        Log(Error, "Floppy Transfer Error: bad cylinder");
+        error = 1;
+    }
+    if(bps != 0x2) {
+        Log(Error, "Floppy Transfer Error: wanted 512B/sector, got %d", (1<<(bps+7)));
+        error = 1;
+    }
+    if(st1 & 0x02) {
+        Log(Error, "Floppy Transfer Error: not writable");
+        error = 2;
+    }
+
+    if(!error) {
+        ControlMotor(drive, false);
+        return 0;
+    }
+    if(error > 1) {
+        Log(Error, "Floppy Transfer Error: not retrying..");
+        ControlMotor(drive, false);
+        return -2;
+    }
+
+	ControlMotor(drive, false);
+	return 0;
+}
+
+//! convert LBA to CHS
+void FloppyLBAToCHS(int lba,int *head,int *track,int *sector)
+{
+   *head = (lba % ( FLPY_SECTORS_PER_TRACK * 2 ) ) / (FLPY_SECTORS_PER_TRACK);
+   *track = lba / ( FLPY_SECTORS_PER_TRACK * 2 );
+   *sector = lba % FLPY_SECTORS_PER_TRACK + 1;
+}
+
+
+
+
+
+
+///////////
+// Disk Functions
+///////////
+
+char FloppyDriver::ReadSector(uint16_t drive, uint32_t lba, uint8_t* buf)
+{
+    if (drive >= 2)
+		return 1;
+
+	//! convert LBA sector to CHS
+	int head = 0, track = 0, sector = 1;
+	FloppyLBAToCHS(lba, &head, &track, &sector);
+
+	//! turn motor on and seek to track
+	ControlMotor(drive, true);
+	if (Seek(drive, (uint8_t)track, (uint8_t)head) != 0)
+		return 1;
+
+	//! read sector and turn motor off
+	int ret = TransferSectorCHS(drive, FloppyDirectionRead, (uint8_t)head, (uint8_t)track, (uint8_t)sector);
+	ControlMotor(drive, false);
+
+	MemoryOperations::memcpy(buf, this->bufferVirt, BYTES_PER_SECT);
+	return ret;
+}
+char FloppyDriver::WriteSector(uint16_t drive, uint32_t lba, uint8_t* buf)
+{
+    if (drive >= 2)
+		return 1;
+
+	//! convert LBA sector to CHS
+	int head = 0, track = 0, sector = 1;
+	FloppyLBAToCHS(lba, &head, &track, &sector);
+
+	//! turn motor on and seek to track
+	ControlMotor(drive, true);
+	if (Seek(drive, (uint8_t)track, (uint8_t)head) != 0)
+		return 1;
+	
+	// Copy buffer to DMA address
+	MemoryOperations::memcpy(this->bufferVirt, buf, BYTES_PER_SECT);
+
+	//! write sector and turn motor off
+	int ret = TransferSectorCHS(drive, FloppyDirectionWrite, (uint8_t)head, (uint8_t)track, (uint8_t)sector);
+	ControlMotor(drive, false);
+
+	return ret;
+}
+bool FloppyDriver::EjectDrive(uint8_t drive)
+{
+	return false;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/integrated/ps2-keyboard.cpp b/kernelz/src/system/drivers/integrated/ps2-keyboard.cpp
new file mode 100644
index 0000000..406283e
--- /dev/null
+++ b/kernelz/src/system/drivers/integrated/ps2-keyboard.cpp
@@ -0,0 +1,115 @@
+#include <system/drivers/integrated/ps2-keyboard.h>
+#include <core/port.h>
+#include <system/bootconsole.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+using namespace CactusOS::core;
+
+PS2KeyboardDriver::PS2KeyboardDriver()
+: InterruptHandler(0x21), Keyboard(KeyboardType::PS2), Driver("PS2 Keyboard", "Driver for a generic ps2 keyboard"), FIFOStream(100)
+{ }
+
+void ReadyForRead()
+{
+    uint32_t timeOut = 100000;
+    while(timeOut--)
+        if((inportb(PS2_STATUS) & (1<<0)) == 1)
+            return;
+    
+    Log(Warning, "Keyboard wait timeout");
+}
+bool ReadyForWrite()
+{
+    uint32_t timeOut = 100000;
+    while(timeOut--)
+        if((inportb(PS2_STATUS) & (1<<1)) == 0)
+            return true;
+    
+    return false;
+}
+
+bool SendCommand(uint8_t cmd, uint8_t data = 0)
+{
+    if(ReadyForWrite() == false)
+        return false;
+
+    outportb(PS2_COMMAND, cmd);
+
+    if(data) {
+        if(ReadyForWrite() == false)
+            return false;
+        
+        outportb(PS2_DATA, data);
+    }
+    return true;
+}
+
+bool PS2KeyboardDriver::Initialize()
+{
+    if(!SendCommand(0xAD)) // Send Disable keyboard command
+        return false;
+    
+    if(!SendCommand(0x20)) // Indicate we would like to recieve the config byte
+        return false;
+    
+    ReadyForRead();
+    uint8_t status = (inportb(PS2_DATA) | 1) & ~0x10;
+    if(!SendCommand(0x60, status)) // Update config byte
+        return false;
+    
+    if(!SendCommand(0xAE)) // Send Enable keyboard command
+        return false;
+        
+    // Add ourself to the list of known keyboards
+    System::keyboardManager->keyboards.push_back(this);
+
+    return true;
+}
+uint32_t PS2KeyboardDriver::HandleInterrupt(uint32_t esp)
+{
+    uint8_t key = inportb(0x60);
+    bool pressed = !(key & (1<<7));
+
+    // Remove first bit from key
+    if(!pressed)
+        key = key & 0x7F;
+    
+    if(key == 0x7A) // CapsLock also sends 2 0x7A keycodes for some reason
+        return esp;
+     
+    // Update internal modifier keys
+    if(key == 0x2A)
+        status.LeftShift = pressed;
+    else if(key == 0x36)
+        status.RightShift = pressed;
+    else if(key == 0x1D)
+        status.LeftControl = pressed;
+    else if(key == 0xE0)
+        status.RightControl = pressed;
+    else if(key == 0x38)
+        status.Alt = pressed;
+
+    System::keyboardManager->HandleKeyChange(this, key, pressed);
+
+    return esp;
+}
+
+void PS2KeyboardDriver::UpdateLEDS()
+{
+	uint8_t code = 0;
+
+	if(System::keyboardManager->sharedStatus.NumLock)
+		code |= 1 << 1;
+		
+	if(System::keyboardManager->sharedStatus.CapsLock)
+		code |= 1 << 2;
+
+    while((inportb(0x64) & 2) != 0);
+    outportb(0x60, 0xED);
+    while((inportb(0x64) & 2) != 0);
+    outportb(0x60, code);
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/integrated/ps2-mouse.cpp b/kernelz/src/system/drivers/integrated/ps2-mouse.cpp
new file mode 100644
index 0000000..24566cf
--- /dev/null
+++ b/kernelz/src/system/drivers/integrated/ps2-mouse.cpp
@@ -0,0 +1,220 @@
+#include <system/drivers/integrated/ps2-mouse.h>
+#include <core/port.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+using namespace CactusOS::core;
+
+PS2MouseDriver::PS2MouseDriver()
+: InterruptHandler(0x2C), Driver("PS2 Mouse", "Driver for a generic ps2 mouse")
+{
+    this->packetBuffer = new signed char[3];
+}
+
+/**
+ * Wait for the mouse to become ready for a read or write opperation
+*/
+inline void mouseWait(bool type)
+{
+  uint32_t timeOut = 100000;
+  if(type == false)
+  {
+    while(timeOut--)
+      if((inportb(MOUSE_COMMAND) & 1) == 1)
+        return;
+
+    Log(Warning, "Mouse wait timeout type=%d", type);
+    return;
+  }
+  else
+  {
+    while(timeOut--)
+      if((inportb(MOUSE_COMMAND) & 2) == 0)
+        return;
+
+    Log(Warning, "Mouse wait timeout type=%d", type);
+    return;
+  }
+}
+/**
+ * Write a byte to the mouse
+*/
+inline void mouseWrite(uint8_t a_write)
+{
+  //Wait to be able to send a command
+  mouseWait(1);
+  //Tell the mouse we are sending a command
+  outportb(0x64, 0xD4);
+  //Wait for the final part
+  mouseWait(1);
+  //Finally write
+  outportb(0x60, a_write);
+}
+/**
+ * Read a byte from the mouse
+*/
+inline uint8_t mouseRead()
+{
+  //Get's response from mouse
+  mouseWait(0);
+  return inportb(0x60);
+}
+
+bool PS2MouseDriver::Initialize()
+{
+    //Enable the auxiliary mouse device
+    mouseWait(1);
+    outportb(0x64, 0xA8);
+    
+    //Enable the interrupts
+    mouseWait(1);
+    outportb(0x64, 0x20);
+
+    mouseWait(0);
+    uint8_t status = (inportb(0x60) | 2);
+
+    mouseWait(1);
+    outportb(0x64, 0x60);
+
+    mouseWait(1);
+    outportb(0x60, status);
+    
+    //Tell the mouse to use default settings
+    mouseWrite(0xF6);
+    if(mouseRead() != MOUSE_ACK)  //Acknowledge
+        return false;
+    
+    //Enable the mouse
+    mouseWrite(0xF4);
+    if(mouseRead() != MOUSE_ACK)  //Acknowledge
+        return false;
+
+    //Enable scroll wheel if present
+    if(EnableScrollWheel())
+        BootConsole::WriteLine("PS2 Mouse scrollwheel enabled");
+    else
+        BootConsole::WriteLine("PS2 Mouse has no scrollwheel");
+
+    this->ready = true;
+    return true;
+}
+bool PS2MouseDriver::EnableScrollWheel()
+{
+    if(MouseID == 3) //We are already using the scrollwheel
+        return true;
+    
+    if(!SetSampleRate(200) || !SetSampleRate(100) || !SetSampleRate(80))
+        return false;
+    
+    mouseWrite(0xF2);
+    if(mouseRead() != MOUSE_ACK)  //Acknowledge
+        return false;
+    
+    //Read new ID
+    uint8_t newID = mouseRead();
+
+    if(newID != 3)
+        return false;
+    
+    //Create new buffer
+    delete this->packetBuffer;
+    this->packetBuffer = new signed char[4];
+
+    MouseID = newID;
+    return true;
+}
+bool PS2MouseDriver::SetSampleRate(uint8_t value)
+{
+    mouseWrite(0xF3);
+    if(mouseRead() != MOUSE_ACK)  //Acknowledge
+        return false;
+    
+    mouseWrite(value);
+    if(mouseRead() != MOUSE_ACK)  //Acknowledge
+        return false;
+    
+    return true;
+}
+uint32_t PS2MouseDriver::HandleInterrupt(uint32_t esp)
+{
+    if(!this->ready)
+        return esp;
+    
+    uint8_t status = inportb(MOUSE_COMMAND);
+    if (!(status & 0x20))
+        return esp;
+
+    uint8_t dataByte = inportb(MOUSE_DATA);
+
+    switch(MouseCycle)
+    {
+    case 0:
+        {
+            packetBuffer[0] = dataByte;
+            MouseCycle++;
+        }
+        break;
+    case 1:
+        {
+            packetBuffer[1] = dataByte;
+            MouseCycle++;
+        }
+        break;
+    case 2:
+        {
+            packetBuffer[2] = dataByte;
+
+            if(MouseID == 0) //End of packed
+            {
+                ProcessPacket();
+                MouseCycle = 0;
+            }
+            else
+                MouseCycle++;
+        }
+        break;
+    case 3:
+        {
+            packetBuffer[3] = dataByte;
+            ProcessPacket();
+            MouseCycle = 0;
+        }
+        break;
+    }
+
+    return esp;
+}
+void PS2MouseDriver::ProcessPacket()
+{
+    MousePacket* packet = (MousePacket*)this->packetBuffer;
+
+    int realX = packet->XMovement - (packet->Xsign & 0x100);
+    int realY = packet->YMovement - (packet->Ysign & 0x100);
+
+    //Log(Info, "Mouse: X=%d Y=%d Z=%d LB=%d RB=%d MB=%d", realX, realY, (this->MouseID == 3 ? packet->ZMovement : 0), packet->LeftBTN, packet->RightBTN, packet->MiddleBTN);
+
+    //Upload values to systeminfo
+    System::systemInfo->MouseLeftButton = packet->LeftBTN;
+    System::systemInfo->MouseMiddleButton = packet->MiddleBTN;
+    System::systemInfo->MouseRightButton = packet->RightBTN;
+    System::systemInfo->MouseZ += (int8_t)(this->MouseID == 3 ? packet->ZMovement : 0);
+
+    int newX = (System::systemInfo->MouseX + realX);
+    if((newX >= 0) && (newX < (int)System::gfxDevice->width))
+        System::systemInfo->MouseX = newX;
+    else if(newX < 0)
+        System::systemInfo->MouseX = 0;
+    else if(newX >= (int)System::gfxDevice->width)
+        System::systemInfo->MouseX = System::gfxDevice->width - 1;
+    
+    int newY = (System::systemInfo->MouseY - realY);
+    if((newY >= 0) && (newY < (int)System::gfxDevice->height))
+        System::systemInfo->MouseY = newY;
+    else if(newY < 0)
+        System::systemInfo->MouseY = 0;
+    else if(newY >= (int)System::gfxDevice->height)
+        System::systemInfo->MouseY = System::gfxDevice->height - 1;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/pcidrivers.cpp b/kernelz/src/system/drivers/pcidrivers.cpp
new file mode 100644
index 0000000..3dd4c80
--- /dev/null
+++ b/kernelz/src/system/drivers/pcidrivers.cpp
@@ -0,0 +1,119 @@
+#include <system/drivers/pcidrivers.h>
+
+//Drivers
+#include <system/drivers/disk/ide.h>
+#include <system/drivers/disk/ahci/ahcicontroller.h>
+#include <system/drivers/usb/controllers/uhci.h>
+#include <system/drivers/usb/controllers/ohci.h>
+#include <system/drivers/usb/controllers/ehci.h>
+#include <system/drivers/usb/controllers/xhci.h>
+#include <system/drivers/video/vmwaresvga.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+
+PCIAttachedDriverEntry pciDriverList[] = 
+{
+    {VMWARESVGAII_VENDORID, VMWARESVGAII_DEVICEID, "VMWare SVGAII"}
+};
+
+const int pciDriverListCount = sizeof(pciDriverList) / sizeof(PCIAttachedDriverEntry);
+
+void PCIDrivers::AssignDriversFromPCI(PCIController* pci, DriverManager* driverManager)
+{
+    for(int i = 0; i < pci->deviceList.size(); i++)
+    {
+        PCIDevice* pciDevice = pci->deviceList[i];
+
+        //First loop through the known drivers per pci device
+        for(int x = 0; x < pciDriverListCount; x++)
+        {
+            if(pciDriverList[x].vendorID == pciDevice->vendorID && pciDriverList[x].deviceID == pciDevice->deviceID && pciDriverList[x].driverString != 0)
+            {
+                //Found a driver for that specific device
+                if(String::strcmp(pciDriverList[x].driverString, "VMWare SVGAII"))
+                    driverManager->AddDriver(new VMWARESVGAII(pciDevice));
+
+                goto FoundDriver;
+            }
+        }
+
+        //Then check if we can assign a driver by its class and subclass
+        switch(pciDevice->classID)
+        {
+            case 0x01: //Mass Storage Controller
+            {
+                switch(pciDevice->subclassID)
+                {
+                    case 0x01: //IDE Controller
+                    {
+                        driverManager->AddDriver(new IDEController(pciDevice));
+                        goto FoundDriver;
+                        break;
+                    }
+                    case 0x06: // SATA Controller
+                    {
+                        driverManager->AddDriver(new AHCIController(pciDevice));
+                        goto FoundDriver;
+                        break;
+                    }
+                }
+                break;
+            }
+#if ENABLE_USB
+            case 0x0C: //Serial Bus Controller 
+            {
+                switch(pciDevice->subclassID)
+                {
+                    case 0x03: //USB Controller
+                    {
+                        switch(pciDevice->programmingInterfaceID)
+                        {
+                            case 0x00: //UHCI
+                            {
+                                driverManager->AddDriver(new UHCIController(pciDevice));
+                                goto FoundDriver;
+                                break;
+                            }
+                            case 0x10: //OHCI
+                            {
+                                driverManager->AddDriver(new OHCIController(pciDevice));
+                                goto FoundDriver;
+                                break;
+                            }
+                            case 0x20: //EHCI
+                            {
+                                driverManager->AddDriver(new EHCIController(pciDevice));
+                                goto FoundDriver;
+                                break;
+                            }
+                            case 0x30: //xHCI
+                            {
+                                BootConsole::WriteLine("xHCI Controller found, no support for this controller (yet)");
+                                //driverManager->AddDriver(new XHCIController(pciDevice));
+                                //goto FoundDriver;
+                                break;
+                            }
+                            default:
+                            {
+                                Log(Warning, "Unknown USB controller found of type %b", pciDevice->programmingInterfaceID);
+                                break;
+                            }
+                        }   
+                    }
+                }
+                break;
+            }
+#endif
+        }
+
+FoundDriver:
+        //Goto the next device in the list
+        continue;
+    }
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/usb/controllers/ehci.cpp b/kernelz/src/system/drivers/usb/controllers/ehci.cpp
new file mode 100644
index 0000000..cbad347
--- /dev/null
+++ b/kernelz/src/system/drivers/usb/controllers/ehci.cpp
@@ -0,0 +1,816 @@
+#include <system/drivers/usb/controllers/ehci.h>
+#include <system/drivers/usb/usbdefs.h>
+#include <system/memory/deviceheap.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+EHCIController::EHCIController(PCIDevice* device)
+: USBController(EHCI), Driver("EHCI USB Controller", "Controller for a EHCI device")
+, InterruptHandler(IDT_INTERRUPT_OFFSET + device->interrupt) 
+{
+    this->pciDevice = device;
+}
+
+bool EHCIController::Initialize()
+{
+    BaseAddressRegister BAR0 = System::pci->GetBaseAddressRegister(pciDevice->bus, pciDevice->device, pciDevice->function, 0);
+    if(BAR0.type == InputOutput)
+        return false; // We only want memory mapped controllers
+
+    uint32_t memStart = pageRoundDown((uint32_t)BAR0.address); // Assuming 32-Bit address
+    uint32_t memEnd = pageRoundUp((uint32_t)BAR0.address + BAR0.size);
+    
+    // Allocate virtual chuck of memory that we can use for device
+    this->regBase = DeviceHeap::AllocateChunk(memEnd - memStart) + ((uint32_t)BAR0.address % PAGE_SIZE);
+
+    // Map memory so that we can use it
+    VirtualMemoryManager::mapVirtualToPhysical((void*)memStart, (void*)this->regBase, memEnd - memStart, true, true);
+
+    Log(Info, "[EHCI] Controller Memory addres %x -> Memory Mapped: Start=%x End=%x Size=%x", (uint32_t)BAR0.address, memStart, memEnd, memEnd - memStart);
+    Log(Info, "[EHCI] regBase -> %x", this->regBase);
+
+    // Enable BUS Mastering
+    uint32_t busMasterTemp = System::pci->Read(pciDevice->bus, pciDevice->device, pciDevice->function, 0x04);
+    busMasterTemp &= ~PCI_CMDREG_IO;
+    busMasterTemp |= PCI_CMDREG_MEM | PCI_CMDREG_BM;
+    Log(Info, "[EHCI] PCI Command before and after -> %b %b", System::pci->Read(pciDevice->bus, pciDevice->device, pciDevice->function, 0x04), busMasterTemp);
+    System::pci->Write(pciDevice->bus, pciDevice->device, pciDevice->function, 0x04, busMasterTemp);
+
+    // Calculate the operational base
+    // Must be before any ReadOpReg() or WriteOpReg() calls
+    operRegsOffset = (uint8_t)readMemReg(this->regBase + EHCI_CAPS_CapLength);
+    Log(Info, "[EHCI] operRegsOffset = %b", operRegsOffset);
+
+    uint32_t structuralParams = readMemReg(this->regBase + EHCI_CAPS_HCSParams);
+    uint32_t capabilityParams = readMemReg(this->regBase + EHCI_CAPS_HCCParams);
+    Log(Info, "[EHCI] structuralParams = %b", structuralParams);
+    Log(Info, "[EHCI] capabilityParams = %b", capabilityParams);
+
+    // Get num_ports from EHCI's HCSPARAMS register
+    numPorts = (uint8_t)(structuralParams & 0x0F);  // At least 1 and no more than 15
+    Log(Info, "EHCI Found %d root hub ports.", numPorts);
+
+    // Turn off legacy support for Keyboard and Mice
+    if (!this->StopLegacy(capabilityParams)) {
+        Log(Error, "[EHCI] BIOS did not release Legacy support...");
+        return false;
+    }
+
+    // Disable interrupts
+    WriteOpReg(EHCI_OPS_USBInterrupt, 0x0);
+
+    // Do what the function says
+    if (!this->ResetController()) {
+        Log(Error, "[EHCI] Could not reset controller");
+        return false;
+    }
+
+    // We use 32bit addresses so set this to 0
+    WriteOpReg(EHCI_OPS_CtrlDSSegment, 0);
+
+    // Set Interrupt Enable register for following interrupts:
+    // Short Packet, Completion of frame, Error with transaction and port change interrupt
+    WriteOpReg(EHCI_OPS_USBInterrupt, 0x07);
+
+    // Add ourself to known controllers
+    System::usbManager->AddController(this);
+
+    return true;
+}
+bool EHCIController::ResetController()
+{
+    Log(Info, "[EHCI] Controller reset......");
+
+    // First halt the controller, and give it some time to do so
+	WriteOpReg(EHCI_OPS_USBCommand, 0);
+	System::pit->Sleep(USB_TRSTRCY);
+
+	// Then send the reset
+	WriteOpReg(EHCI_OPS_USBCommand, (1<<1));
+
+	uint32_t timeout = 1000;
+	while (ReadOpReg(EHCI_OPS_USBCommand) & (1<<1)) {
+		System::pit->Sleep(10);
+        timeout -= 10;
+		if (timeout < 0)
+			return false;
+	}
+
+	return true;
+}
+void EHCIController::InitializeAsyncList()
+{
+    e_queueHead_t* queueHeadPtr = this->asyncList;
+    uint32_t queueHeadPhysPtr = this->asyncListPhys;
+    // The async queue (Control and Bulk TD's) is a round robin set of 16 Queue Heads.
+    for (int i = 0; i < 16; i++) {
+        queueHeadPtr->horzPointer = (queueHeadPhysPtr + sizeof(e_queueHead_t)) | QH_HS_TYPE_QH | QH_HS_T0;
+        queueHeadPtr->horzPointerVirt = queueHeadPtr + 1;
+        queueHeadPtr->prevPointerPhys = queueHeadPhysPtr - sizeof(e_queueHead_t);
+        queueHeadPtr->prevPointerVirt = queueHeadPtr - 1;
+        queueHeadPtr->flags = (0 << 16) | ((i==0) ? (1<<15) : (0<<15)) | (QH_HS_EPS_HS<<12) | (0<<8) | 0;
+        queueHeadPtr->hubFlags = (1<<30);
+        queueHeadPtr->transferDescriptor.nextQTD = QH_HS_T1;
+        queueHeadPtr->transferDescriptor.altNextQTD = QH_HS_T1;
+        queueHeadPtr++;
+        queueHeadPhysPtr += sizeof(e_queueHead_t);
+    }
+    
+    // Backup and point the last one at the first one
+    queueHeadPtr--;
+    queueHeadPtr->horzPointer = (this->asyncListPhys | QH_HS_TYPE_QH | QH_HS_T0);
+    queueHeadPtr->horzPointerVirt = this->asyncList;
+    
+    // Setup previous pointers for first item
+    this->asyncList->prevPointerPhys = queueHeadPhysPtr + 15 * sizeof(e_queueHead_t);
+    this->asyncList->prevPointerVirt = queueHeadPtr + 15;
+}
+void EHCIController::InitializePeriodicList()
+{
+  // The periodic list is a round robin set of (256, 512, or) 1204 list pointers.
+  for (int i = 0; i < 1024; i++)
+    this->periodicList[i] = QH_HS_TYPE_QH | QH_HS_T1;
+}
+void EHCIController::Setup()
+{
+    Log(Info, "[EHCI] Starting controller");
+
+    // Allocate Async and Periodic lists
+    this->asyncList = (e_queueHead_t*)KernelHeap::alignedMalloc(16 * sizeof(e_queueHead_t), 4096, &this->asyncListPhys);
+    this->periodicList = (uint32_t*)KernelHeap::alignedMalloc(1024 * sizeof(uint32_t), 4096, &this->periodicListPhys);
+
+    Log(Info, "[EHCI] Async List allocated %x (virt) and %x (phys)", this->asyncList, this->asyncListPhys);
+    Log(Info, "[EHCI] Periodic List allocated %x (virt) and %x (phys)", this->periodicList, this->periodicListPhys);
+
+    // Clear them out
+    MemoryOperations::memset(this->asyncList, 0, 16 * sizeof(e_queueHead_t));
+    MemoryOperations::memset(this->periodicList, 0, 1024 * sizeof(uint32_t));
+
+    // And then initialize them
+    InitializeAsyncList();
+    InitializePeriodicList();
+
+    // Set List Pointers
+    WriteOpReg(EHCI_OPS_PeriodicListBase, this->periodicListPhys);
+    WriteOpReg(EHCI_OPS_AsyncListBase, this->asyncListPhys);
+
+    // Read port specific events
+    bool hasPPC = (readMemReg(this->regBase + EHCI_CAPS_HCCParams) & (1<<18)) != 0;
+
+    // Read configuration of controller and attempt to start it
+    uint32_t cmdConfig = ReadOpReg(EHCI_OPS_USBCommand);
+    cmdConfig &= ~((0xFF << 16) | (1 << 15)); // Reset special interrupt tresholds and port specific events
+    
+    // Start controller
+    WriteOpReg(EHCI_OPS_USBCommand, cmdConfig | (8<<16) | (hasPPC ? (1<<15) : 0) | (1<<5) | (1<<4) | (1<<0));
+
+    bool running = false;
+	for (int i = 0; i < 10; i++) {
+		uint32_t status = ReadOpReg(EHCI_OPS_USBStatus);
+
+		if (status & (1 << 12)) {
+			System::pit->Sleep(10);
+		} else {
+			running = true;
+			break;
+		}
+	}
+
+    if(!running) {
+        Log(Error, "[EHCI] Controller did not start!");
+        System::usbManager->RemoveController(this);
+        return;
+    }
+
+    // Take ownership of root hub ports
+    WriteOpReg(EHCI_OPS_ConfigFlag, 1);
+    System::pit->Sleep(100);
+
+    // If we have control to change the port power, we need to power each port to 1
+    if (readMemReg(this->regBase + EHCI_CAPS_HCSParams) & (1<<4))
+        for (int i = 0; i < numPorts; i++)
+            WriteOpReg(EHCI_OPS_PortStatus + (i * 4), ReadOpReg(EHCI_OPS_PortStatus + (i * 4)) | EHCI_PORT_PP);
+    
+    // After powering a port, we must wait 20mS before using it.
+    System::pit->Sleep(20);
+
+    // We should be ready to detect any ports that are occupied
+    for (int i = 0; i < numPorts; i++) {
+        // Power and reset the port
+        if (ResetPort(i)) {
+            Log(Info, "[EHCI] Found device at port %d", i);
+            SetupNewDevice(i);
+        }
+    }
+}
+uint32_t EHCIController::HandleInterrupt(uint32_t esp)
+{
+    uint32_t val = ReadOpReg(EHCI_OPS_USBStatus);
+    //Log(Info, "EHCI Interrupt, Status = %x", val);
+
+    if(val == 0) // Interrupt came from another EHCI device
+    {
+        //Log(Warning, "Interrupt came from another EHCI device!\n");
+        return esp;
+    }
+
+    WriteOpReg(EHCI_OPS_USBStatus, val);
+
+    if (val & (1<<1))
+    {
+        Log(Error, "[EHCI] USB Error Interrupt");
+    }
+
+    if (val & (1<<2))
+    {
+        Log(Info, "[EHCI] Port Change");
+    }
+
+    if (val & (1<<3))
+    {
+        //Log(Info, "EHCI: Frame List Rollover Interrupt");
+    }
+
+    if (val & (1<<4))
+    {
+        Log(Error, "[EHCI] Host System Error");
+    }
+
+    return esp;
+}
+void EHCIController::ControllerChecksThread()
+{
+    for (int i = 0; i < numPorts; i++)
+    {
+        uint32_t HCPortStatusOff = EHCI_OPS_PortStatus + (i * 4);
+        uint32_t portStatus = ReadOpReg(HCPortStatusOff);
+        if (portStatus & EHCI_PORT_CSC)
+        {
+            Log(Info, "[EHCI] Port %d Connection change, now %s", i, (portStatus & EHCI_PORT_CCS) ? "Connected" : "Not Connected");
+            portStatus |= EHCI_PORT_CSC; // Clear bit
+            WriteOpReg(HCPortStatusOff, portStatus);
+
+            if (portStatus & EHCI_PORT_CCS) { // Connected
+                if(ResetPort(i))
+                    SetupNewDevice(i);
+            }
+            else {
+                System::usbManager->RemoveDevice(this, i);          
+            }
+        }
+    }
+}
+bool EHCIController::ResetPort(uint8_t port)
+{
+    uint32_t HCPortStatusOff = EHCI_OPS_PortStatus + (port * 4);
+    
+    // Clear the enable bit and status change bits (making sure the PP is set)
+    WriteOpReg(HCPortStatusOff, EHCI_PORT_PP | EHCI_PORT_OVER_CUR_C | EHCI_PORT_ENABLE_C | EHCI_PORT_CSC);
+    
+    // Read the port and see if a device is attached
+    // If device attached and is a hs device, the controller will set the enable bit.
+    // If the enable bit is not set, then there was an error or it is a low- or full-speed device.
+    // If bits 11:10 = 01b, then it isn't a high speed device anyway, skip the reset.
+    uint32_t portValue = ReadOpReg(HCPortStatusOff);
+    if ((portValue & EHCI_PORT_CCS) && (((portValue & EHCI_PORT_LINE_STATUS) >> 10) != 0x01)) {
+        // Set bit 8 (writing a zero to bit 2)
+        WriteOpReg(HCPortStatusOff, EHCI_PORT_PP | EHCI_PORT_RESET);
+        System::pit->Sleep(USB_TDRSTR);  // At least 50 ms for a root hub
+        
+        // Clear the reset bit leaving the power bit set
+        WriteOpReg(HCPortStatusOff, EHCI_PORT_PP);
+        System::pit->Sleep(USB_TRSTRCY);
+    }
+    
+    portValue = ReadOpReg(HCPortStatusOff);
+    if (portValue & EHCI_PORT_CCS) {
+        // If after the reset, the enable bit is set, we have a high-speed device
+        if (portValue & EHCI_PORT_ENABLED) {
+            // Found a high-speed device.
+            // Clear the status change bit(s)
+            WriteOpReg(HCPortStatusOff, ReadOpReg(HCPortStatusOff) & EHCI_PORT_WRITE_MASK);
+
+            Log(Info, "[EHCI] Found High-Speed Device at port %d", port);
+            return true;
+        } else {
+            Log(Info, "[EHCI] Found a low- or full-speed device. Releasing Control.");
+
+            // Disable and power off the port
+            WriteOpReg(HCPortStatusOff, 0);
+            System::pit->Sleep(10);
+            
+            // Release ownership of the port.
+            WriteOpReg(HCPortStatusOff, EHCI_PORT_OWNER);
+
+            // Wait for the owner bit to actually be set, and the ccs bit to clear
+            if(!WaitForRegister(HCPortStatusOff, (EHCI_PORT_OWNER | EHCI_PORT_CCS), EHCI_PORT_OWNER, 250)) {
+                Log(Error, "[EHCI] Could not release control of device.");
+                return false;
+            }
+        }
+    }
+    return false;
+}
+// This routine waits for the value read at (base, reg) and'ed by mask to equal result.
+// It returns true if this happens before the alloted time expires
+// returns false if this does not happen
+bool EHCIController::WaitForRegister(const uint32_t reg, const uint32_t mask, const uint32_t result, unsigned ms) {
+    do {
+        if ((ReadOpReg(reg) & mask) == result)
+            return true;
+        
+        System::pit->Sleep(1);
+    } while (--ms);
+    
+    return false;
+}
+bool EHCIController::SetupNewDevice(const int port) 
+{
+    struct DEVICE_DESC dev_desc;
+    
+    // Send the "get_descriptor" packet (get 18 bytes)
+    if (!ControlIn(&dev_desc, 0, EHCI_MPS, 18, STDRD_GET_REQUEST, GET_DESCRIPTOR, DEVICE))
+        return false;
+    
+    // Reset the port
+    ResetPort(port);
+    
+    // Set address
+    ControlOut(0, EHCI_MPS, 0, STDRD_SET_REQUEST, SET_ADDRESS, 0, this->newDeviceAddress);
+
+    // Setup Device
+    USBDevice* newDev = new USBDevice();
+    newDev->controller = this;
+    newDev->devAddress = this->newDeviceAddress++;
+    newDev->portNum = port;
+                
+    System::usbManager->AddDevice(newDev);
+    
+    return true;
+}
+
+bool EHCIController::StopLegacy(const uint32_t params)
+{
+    const uint8_t eecp = (uint8_t) ((params & 0x0000FF00) >> 8);
+    
+    if (eecp >= 0x40) 
+    {
+        // set bit 24 asking the BIOS to release ownership
+        System::pci->Write(pciDevice->bus, pciDevice->device, pciDevice->function, eecp + EHCI_LEGACY_USBLEGSUP, 
+        (System::pci->Read(pciDevice->bus, pciDevice->device, pciDevice->function, eecp + EHCI_LEGACY_USBLEGSUP) | EHCI_LEGACY_OS_OWNED));
+        
+        // Timeout if bit 24 is not set and bit 16 is not clear after EHC_LEGACY_TIMEOUT milliseconds
+        int timeout = EHCI_LEGACY_TIMEOUT;
+        while (timeout--) {
+            if ((System::pci->Read(pciDevice->bus, pciDevice->device, pciDevice->function, eecp + EHCI_LEGACY_USBLEGSUP) & EHCI_LEGACY_OWNED_MASK) == EHCI_LEGACY_OS_OWNED)
+                return true;
+            System::pit->Sleep(1);
+        }
+        
+        return false;
+    } else
+        return true;
+}
+
+void EHCIController::MakeSetupTransferDesc(e_transferDescriptor_t* tdVirt, const uint32_t tdPhys, uint32_t bufPhys)
+{    
+    tdVirt->nextQTD = tdPhys + sizeof(e_transferDescriptor_t);
+    tdVirt->nextQTDVirt = tdVirt + 1;
+    tdVirt->altNextQTD = QH_HS_T1;
+    tdVirt->altNextQTDVirt = 0;
+    tdVirt->flags = (0<<31) | (8<<16) | (0<<15) | (0<<12) | (3<<10) | (EHCI_TD_PID_SETUP<<8) | 0x80;
+    
+    tdVirt->bufPtr[0] = bufPhys;
+
+    bufPhys = (bufPhys + 0x1000) & ~0x0FFF;
+    tdVirt->bufPtr[1] = bufPhys;
+    tdVirt->bufPtr[2] = bufPhys + 0x1000;
+    tdVirt->bufPtr[3] = bufPhys + 0x2000;
+    tdVirt->bufPtr[4] = bufPhys + 0x3000;
+}
+
+void EHCIController::MakeTransferDesc(e_transferDescriptor_t* currentTD, uint32_t physAddr, e_transferDescriptor_t* status_qtd, const uint32_t status_qtdPhys, uint32_t bufferPhys, int size, const bool last, 
+                uint8_t data0, const uint8_t dir, const uint16_t mps) 
+{   
+    do {        
+        currentTD->nextQTD = (last && (size <= mps)) ? QH_HS_T1 : ((physAddr + sizeof(e_transferDescriptor_t)) | QH_HS_T0);
+        currentTD->nextQTDVirt = (last && (size <= mps)) ? 0 : (currentTD + 1);
+        currentTD->altNextQTD = (!status_qtdPhys) ? QH_HS_T1 : status_qtdPhys;
+        currentTD->altNextQTDVirt = (!status_qtd) ? 0 : status_qtd;
+        currentTD->flags = (data0<<31) | (((size < mps) ? size : mps)<<16) | (0<<15) | (0<<12) | (3<<10) | (dir<<8) | 0x80;
+        currentTD->bufPtr[0] = bufferPhys;
+        if (bufferPhys) {
+            uint32_t buff = (bufferPhys + 0x1000) & ~0x0FFF;
+            currentTD->bufPtr[1] = buff;
+            currentTD->bufPtr[2] = buff + 0x1000;
+            currentTD->bufPtr[3] = buff + 0x2000;
+            currentTD->bufPtr[4] = buff + 0x3000;
+        }
+        
+        data0 ^= 1;
+        currentTD++;
+        physAddr += sizeof(e_transferDescriptor_t);
+
+        size -= mps;
+        bufferPhys += mps;
+    } while (size > 0);
+}
+
+void EHCIController::InsertIntoQueue(e_queueHead_t* item, uint32_t itemPhys, const uint8_t type) {
+    item->horzPointer = this->asyncList->horzPointer;
+    item->horzPointerVirt = this->asyncList->horzPointerVirt;
+
+    this->asyncList->horzPointer = itemPhys | type;
+    this->asyncList->horzPointerVirt = item;
+
+    item->prevPointerPhys = this->asyncListPhys;
+    item->prevPointerVirt = this->asyncList;
+}
+
+// removes a queue from the async list
+// EHCI section 4.8.2, shows that we must watch for three bits before we have "fully and successfully" removed
+// the queue(s) from the list
+bool EHCIController::RemoveFromQueue(e_queueHead_t* item) 
+{  
+    e_queueHead_t* prevQH = item->prevPointerVirt;
+    e_queueHead_t* nextQH = item->horzPointerVirt;
+    
+    prevQH->horzPointer = item->horzPointer;
+    prevQH->horzPointerVirt = nextQH;
+
+    nextQH->prevPointerPhys = item->prevPointerPhys;
+    nextQH->prevPointerVirt = item->prevPointerVirt;
+    
+    // now wait for the successful "doorbell"
+    // set bit 6 in command register (to tell the controller that something has been removed from the schedule)
+    // then watch for bit 5 in the status register.  Once it is set, we can assume all removed correctly.
+    // We ignore the interrupt on async bit in the USBINTR.  We don't need an interrupt here.
+    uint32_t command = ReadOpReg(EHCI_OPS_USBCommand);
+    WriteOpReg(EHCI_OPS_USBCommand, command | (1<<6));
+    if (WaitForRegister(EHCI_OPS_USBStatus, (1<<5), (1<<5), 100)) {
+        WriteOpReg(EHCI_OPS_USBStatus, (1<<5)); // acknowledge the bit
+        return true;
+    } else
+        return false;
+}
+
+int EHCIController::WaitForTransferComplete(e_transferDescriptor_t* td, const uint32_t timeout, bool* spd) 
+{  
+    int ret = -1;
+    uint32_t status;
+    
+    int timer = timeout;
+    while (timer) {
+        status = td->flags & ~1;  // ignore bit 0 (?)
+        if ((status & 0x00000080) == 0) {
+            ret = 1;
+            if ((status & 0x7F) == 0x00) {
+                if ((((status & 0x7FFF0000) >> 16) > 0) && (((status & (3<<8))>>8) == 1))
+                    if (spd) 
+                        *spd = true;
+            } else {
+                if (status & (1<<6)) {
+                    ret = 0; //ERROR_STALLED;
+                    Log(Error, "EHCI qtd->status = ERROR_STALLED");
+                }
+                else if (status & (1<<5)) {
+                    ret = 0; //ERROR_DATA_BUFFER_ERROR;
+                    Log(Error, "EHCI qtd->status = ERROR_DATA_BUFFER_ERROR");
+                }
+                else if (status & (1<<4)) {
+                    ret = 0; //ERROR_BABBLE_DETECTED;
+                    Log(Error, "EHCI qtd->status = ERROR_BABBLE_DETECTED");
+                }
+                else if (status & (1<<3)) {
+                    ret = 0; //ERROR_NAK;
+                    Log(Error, "EHCI qtd->status = ERROR_NAK");
+                }
+                else if (status & (1<<2)) {
+                    ret = 0; //ERROR_TIME_OUT;
+                    Log(Error, "EHCI qtd->status = ERROR_TIME_OUT");
+                }
+                else {
+                    Log(Error, "EHCI qtd->status = %x", status);
+                    ret = 0; //ERROR_UNKNOWN;
+                }
+                return ret;
+            }
+            if ((((status & 0x7FFF0000) >> 16) > 0) && (((status & (3<<8))>>8) == 1)) {
+                if ((td->altNextQTD & 1) == 0) {
+                    td = (e_transferDescriptor_t*)td->altNextQTDVirt;
+                    timer = timeout;
+                } 
+                else
+                    return ret;
+            } else {
+                if ((td->nextQTD & 1) == 0) {
+                    td = (e_transferDescriptor_t*)td->nextQTDVirt;
+                    timer = timeout;
+                } 
+                else
+                    return ret;
+            }
+        }
+        System::pit->Sleep(1);
+        timer--;
+    }
+    
+    if (ret == -1) {
+        Log(Error, "USB EHCI Interrupt wait timed out.");
+        ret = 0; //ERROR_TIME_OUT;
+    }
+    
+    return ret;
+}
+
+bool EHCIController::ControlOut(const int devAddress, const int packetSize, const int len, const uint8_t requestType, const uint8_t request, const uint16_t valueHigh, const uint16_t valueLow, const uint16_t index)
+{
+    // Create setupPacket
+    uint32_t setupPacketPhys;
+    REQUEST_PACKET* setupPacket = (REQUEST_PACKET*)KernelHeap::alignedMalloc(sizeof(REQUEST_PACKET), 16, &setupPacketPhys);
+    {
+        setupPacket->request_type = requestType;
+        setupPacket->request = request;
+        setupPacket->value = (valueHigh << 8) | valueLow;
+        setupPacket->index = index;
+        setupPacket->length = len;
+    }
+
+    uint32_t queuePhys; // Physical address of queue
+    uint32_t td0Phys; // Physical address of start of transfer descriptors
+    e_queueHead_t* queue = (e_queueHead_t*)KernelHeap::alignedMalloc(sizeof(e_queueHead_t), 64, &queuePhys);
+    e_transferDescriptor_t* td0 = (e_transferDescriptor_t*)KernelHeap::alignedMalloc(sizeof(e_transferDescriptor_t) * 2, 64, &td0Phys);
+    
+    // Clear both buffers to 0
+    MemoryOperations::memset(queue, 0, sizeof(e_queueHead_t));
+    MemoryOperations::memset(td0, 0, sizeof(e_transferDescriptor_t) * 2);
+    
+    // Setup queue head
+    queue->flags = (8<<28) | (EHCI_MPS << 16) | (0<<15) | (1<<14) | (QH_HS_EPS_HS<<12) | (ENDP_CONTROL << 8) | (0<<7) | (devAddress & 0x7F);
+    queue->hubFlags = (1<<30) | (0<<23) | (0<<16);
+    queue->transferDescriptor.nextQTD = td0Phys;
+
+    MakeSetupTransferDesc(td0, td0Phys, setupPacketPhys);
+    MakeTransferDesc(td0+1, td0Phys + sizeof(e_transferDescriptor_t), 0, 0, 0, 0, true, 1, EHCI_TD_PID_IN, packetSize);
+
+    InsertIntoQueue(queue, queuePhys, QH_HS_TYPE_QH);
+    int ret = WaitForTransferComplete(td0, 2000, 0);
+    RemoveFromQueue(queue);
+
+    KernelHeap::allignedFree(queue);
+    KernelHeap::allignedFree(td0);
+    KernelHeap::allignedFree(setupPacket);
+    
+    return (ret == 1);
+}
+bool EHCIController::ControlIn(void* targ, const int devAddress, const int packetSize, const int len, const uint8_t requestType, const uint8_t request, const uint16_t valueHigh, const uint16_t valueLow, const uint16_t index) 
+{
+    // Create Request Packet
+    uint32_t requestPacketPhys;
+    REQUEST_PACKET* requestPacket = (REQUEST_PACKET*)KernelHeap::alignedMalloc(sizeof(REQUEST_PACKET), 16, &requestPacketPhys);
+    {
+        requestPacket->request_type = requestType;
+        requestPacket->request = request;
+        requestPacket->value = (valueHigh << 8) | valueLow;
+        requestPacket->index = index;
+        requestPacket->length = len;
+    }
+    
+    uint32_t queuePhys; // Physical address of queue
+    uint32_t td0Phys; // Physical address of start of transfer descriptors
+    e_queueHead_t* queue = (e_queueHead_t*)KernelHeap::alignedMalloc(sizeof(e_queueHead_t), 64, &queuePhys);
+    e_transferDescriptor_t* td0 = (e_transferDescriptor_t*)KernelHeap::alignedMalloc(sizeof(e_transferDescriptor_t) * 16, 64, &td0Phys);
+    
+    // Clear both buffers to 0
+    MemoryOperations::memset(queue, 0, sizeof(e_queueHead_t));
+    MemoryOperations::memset(td0, 0, sizeof(e_transferDescriptor_t) * 16);
+    
+    uint32_t bufferPhys;
+    uint8_t* bufferVirt = (uint8_t*)KernelHeap::malloc(len, &bufferPhys);  // get a physical address buffer and then copy from it later
+    
+    const int last = 1 + ((len + (packetSize-1)) / packetSize);
+    
+    // Setup queue head
+    queue->flags = (8<<28) | (EHCI_MPS << 16) | (0<<15) | (1<<14) | (QH_HS_EPS_HS<<12) | (ENDP_CONTROL << 8) | (0<<7) | (devAddress & 0x7F);
+    queue->hubFlags = (1<<30) | (0<<23) | (0<<16);
+    queue->transferDescriptor.nextQTD = td0Phys;
+
+    MakeSetupTransferDesc(td0, td0Phys, requestPacketPhys);
+    MakeTransferDesc(td0 + 1, td0Phys + sizeof(e_transferDescriptor_t), td0 + last, td0Phys + (last * sizeof(e_transferDescriptor_t)), bufferPhys, len, false, 1, EHCI_TD_PID_IN, packetSize);
+    MakeTransferDesc(td0 + last, td0Phys + (last * sizeof(e_transferDescriptor_t)), 0, 0, 0, 0, true, 1, EHCI_TD_PID_OUT, packetSize);
+
+    InsertIntoQueue(queue, queuePhys, QH_HS_TYPE_QH);
+    int ret = WaitForTransferComplete(td0, 2000, 0);
+    RemoveFromQueue(queue);
+
+    KernelHeap::allignedFree(queue);
+    KernelHeap::allignedFree(td0);
+    
+    if (ret == 1) {
+        // now copy from the physical buffer to the specified buffer
+        MemoryOperations::memcpy(targ, bufferVirt, len);
+        KernelHeap::free(bufferVirt);
+        KernelHeap::allignedFree(requestPacket);
+        return true;
+    }
+    
+    KernelHeap::free(bufferVirt);
+    KernelHeap::allignedFree(requestPacket);
+    return false;
+}
+
+bool EHCIController::BulkOut(USBEndpoint* toggleSrc, const int devAddress, const int packetSize, const int endP, void* bufPtr, const int len)
+{
+    uint32_t bufPhys;
+    void* tempBuffer = KernelHeap::malloc(len, &bufPhys);
+    MemoryOperations::memcpy(tempBuffer, bufPtr, len);
+
+    uint32_t queuePhys; // Physical address of queue
+    uint32_t td0Phys; // Physical address of start of transfer descriptors
+    e_queueHead_t* queue = (e_queueHead_t*)KernelHeap::alignedMalloc(sizeof(e_queueHead_t), 64, &queuePhys);
+    e_transferDescriptor_t* td0 = (e_transferDescriptor_t*)KernelHeap::alignedMalloc(sizeof(e_transferDescriptor_t) * 16, 64, &td0Phys);
+    
+    // Clear both buffers to 0
+    MemoryOperations::memset(queue, 0, sizeof(e_queueHead_t));
+    MemoryOperations::memset(td0, 0, sizeof(e_transferDescriptor_t) * 16);
+    
+    // Setup queue head
+    queue->flags = (8<<28) | (packetSize << 16) | (0<<15) | (1<<14) | (QH_HS_EPS_HS<<12) | (endP << 8) | (0<<7) | (devAddress & 0x7F);
+    queue->hubFlags = (1<<30) | (0<<23) | (0<<16);
+    queue->transferDescriptor.nextQTD = td0Phys;
+
+    MakeTransferDesc(td0, td0Phys, 0, 0, bufPhys, len, true, toggleSrc->Toggle(), EHCI_TD_PID_OUT, packetSize);
+    for(int t = 0; t < (1 + ((len + (packetSize-1)) / packetSize)); t++)
+        toggleSrc->Toggle();
+
+    InsertIntoQueue(queue, queuePhys, QH_HS_TYPE_QH);
+    int ret = WaitForTransferComplete(td0, 2000, 0);
+    RemoveFromQueue(queue);
+
+    KernelHeap::allignedFree(queue);
+    KernelHeap::allignedFree(td0);
+    KernelHeap::free(tempBuffer);
+    
+    return (ret == 1);
+}
+bool EHCIController::BulkIn(USBEndpoint* toggleSrc, const int devAddress, const int packetSize, const int endP, void* bufPtr, const int len)
+{
+    uint32_t bufferPhys;
+    uint8_t* bufferVirt = (uint8_t*)KernelHeap::malloc(len, &bufferPhys);  // get a physical address buffer and then copy from it later
+
+    uint32_t queuePhys; // Physical address of queue
+    uint32_t td0Phys; // Physical address of start of transfer descriptors
+    e_queueHead_t* queue = (e_queueHead_t*)KernelHeap::alignedMalloc(sizeof(e_queueHead_t), 64, &queuePhys);
+    e_transferDescriptor_t* td0 = (e_transferDescriptor_t*)KernelHeap::alignedMalloc(sizeof(e_transferDescriptor_t) * 16, 64, &td0Phys);
+    
+    // Clear both buffers to 0
+    MemoryOperations::memset(queue, 0, sizeof(e_queueHead_t));
+    MemoryOperations::memset(td0, 0, sizeof(e_transferDescriptor_t) * 16);
+    
+    // Setup queue head
+    queue->flags = (8<<28) | (packetSize << 16) | (0<<15) | (1<<14) | (QH_HS_EPS_HS<<12) | (endP << 8) | (0<<7) | (devAddress & 0x7F);
+    queue->hubFlags = (1<<30) | (0<<23) | (0<<16);
+    queue->transferDescriptor.nextQTD = td0Phys;
+
+    MakeTransferDesc(td0, td0Phys, 0, 0, bufferPhys, len, true, toggleSrc->Toggle(), EHCI_TD_PID_IN, packetSize);
+    for(int t = 0; t < (1 + ((len + (packetSize-1)) / packetSize)); t++)
+        toggleSrc->Toggle();
+
+    InsertIntoQueue(queue, queuePhys, QH_HS_TYPE_QH);
+    int ret = WaitForTransferComplete(td0, 2000, 0);
+    RemoveFromQueue(queue);
+    
+    if (ret == 1) {
+        // now copy from the physical buffer to the specified buffer
+        MemoryOperations::memcpy(bufPtr, bufferVirt, len);
+    }
+    
+    KernelHeap::allignedFree(queue);
+    KernelHeap::allignedFree(td0);
+    KernelHeap::free(bufferVirt);
+    
+    return (ret == 1);
+}
+
+uint32_t EHCIController::ReadOpReg(uint32_t reg)
+{
+    return readMemReg(regBase + operRegsOffset + reg);
+}
+
+void EHCIController::WriteOpReg(uint32_t reg, uint32_t val)
+{
+    writeMemReg(regBase + operRegsOffset + reg, val);
+}
+
+void EHCIController::DisplayRegisters()
+{
+    Log(Info, "------------------- EHCI Register Dump-----------------------");
+    Log(Info, "EHCI %s %x", "EHCI_CAPS_CapLength",      readMemReg(this->regBase + EHCI_CAPS_CapLength));
+    Log(Info, "EHCI %s %x", "EHCI_CAPS_Reserved",       readMemReg(this->regBase + EHCI_CAPS_Reserved));
+    Log(Info, "EHCI %s %x", "EHCI_CAPS_IVersion",       readMemReg(this->regBase + EHCI_CAPS_IVersion));
+    Log(Info, "EHCI %s %x", "EHCI_CAPS_HCSParams",      readMemReg(this->regBase + EHCI_CAPS_HCSParams));
+    Log(Info, "EHCI %s %x", "EHCI_CAPS_HCCParams",      readMemReg(this->regBase + EHCI_CAPS_HCCParams));
+    Log(Info, "EHCI %s %x", "EHCI_CAPS_HCSPPortRoute",  readMemReg(this->regBase + EHCI_CAPS_HCSPPortRoute));
+
+    Log(Info, "EHCI %s %x", "EHCI_OPS_USBCommand",          ReadOpReg(EHCI_OPS_USBCommand));
+    Log(Info, "EHCI %s %x", "EHCI_OPS_USBStatus",           ReadOpReg(EHCI_OPS_USBStatus));
+    Log(Info, "EHCI %s %x", "EHCI_OPS_USBInterrupt",        ReadOpReg(EHCI_OPS_USBInterrupt));
+    Log(Info, "EHCI %s %x", "EHCI_OPS_FrameIndex",          ReadOpReg(EHCI_OPS_FrameIndex));
+    Log(Info, "EHCI %s %x", "EHCI_OPS_CtrlDSSegment",       ReadOpReg(EHCI_OPS_CtrlDSSegment));
+    Log(Info, "EHCI %s %x", "EHCI_OPS_PeriodicListBase",    ReadOpReg(EHCI_OPS_PeriodicListBase));
+    Log(Info, "EHCI %s %x", "EHCI_OPS_AsyncListBase",       ReadOpReg(EHCI_OPS_AsyncListBase));
+    Log(Info, "EHCI %s %x", "EHCI_OPS_ConfigFlag",          ReadOpReg(EHCI_OPS_ConfigFlag));
+    Log(Info, "EHCI Port dump:");
+    for(uint8_t i = 0; i < this->numPorts; i++)
+        Log(Info, "     %d. %x", i,          ReadOpReg(EHCI_OPS_PortStatus + (i*4)));
+    Log(Info, "-------------------------------------------------------------");
+}
+void EHCIController::PrintTransferDescriptors(e_transferDescriptor_t* td)
+{
+    Log(Info, "------- EHCI TD Dump %x -------", (uint32_t)td);
+    
+    while(td)
+    {
+        Log(Info, "%x: NextTD -> %x : %x", (uint32_t)td, td->nextQTD, (uint32_t)td->nextQTDVirt);
+        Log(Info, "%x: AltTD  -> %x : %x", (uint32_t)td, td->altNextQTD, (uint32_t)td->altNextQTDVirt);
+        Log(Info, "%x: Flags  -> %x", (uint32_t)td, td->flags);
+        Log(Info, "  |-> Status=%x PID=%d C-ERR=%d C-PAGE=%d IOC=%d TBTT=%d DT=%d", td->flags & 0xFF, (td->flags & (0b11<<8))>>8, (td->flags & (0b11<<10))>>10, (td->flags & (0b111<<12))>>12, (td->flags & (1<<15))>>15, (td->flags & (0b111111111111111<<16))>>16, (td->flags & (1<<31))>>31);
+        Log(Info, "------------------------------");
+
+        td = td->nextQTDVirt;
+    }
+}
+void EHCIController::PrintQueueHead(e_queueHead_t* qh)
+{
+    Log(Info, "------- EHCI QH Dump %x -------", (uint32_t)qh);
+    
+    Log(Info, "%x: Horizontal -> %x : %x", (uint32_t)qh, qh->horzPointer, (uint32_t)qh->horzPointerVirt);
+    Log(Info, "%x: Previous   -> %x : %x", (uint32_t)qh, qh->prevPointerPhys, (uint32_t)qh->prevPointerVirt);
+    Log(Info, "%x: Flags      -> %x", (uint32_t)qh, qh->flags);
+    Log(Info, "  |-> Addr=%d I=%d Endp=%d EPS=%d dtc=%d H=%d MaxPacket=%d C=%d RL=%d", qh->flags & 0x7F, (qh->flags & (1<<7))>>7, (qh->flags & (0b111<<8))>>8, (qh->flags & (0b11<<12))>>12, (qh->flags & (1<<14))>>14, (qh->flags & (1<<15))>>15, (qh->flags & (0b1111111111<<16))>>16, (qh->flags & (1<<27))>>27, (qh->flags & (0b111<<28))>>28);
+    Log(Info, "%x: Hubflags   -> %x", (uint32_t)qh, qh->hubFlags);
+    Log(Info, "  |-> sMask=%x cMask=%x HubAddr=%d Port=%d Mult=%d", qh->hubFlags & 0xFF, (qh->hubFlags & (0xFF<<8))>>8, (qh->hubFlags & (0b11111<<16))>>16, (qh->hubFlags & (0b1111111<<23))>>23, (qh->hubFlags & (0b11<<30))>>30);
+    Log(Info, "%x: CurrentTD  -> %x", (uint32_t)qh, qh->curQTD);
+
+    e_transferDescriptor_t* td = &qh->transferDescriptor;
+
+    Log(Info, "------ EHCI TD Overlay of QH --");
+    Log(Info, "    NextTD -> %x : %x", td->nextQTD, (uint32_t)td->nextQTDVirt);
+    Log(Info, "    AltTD  -> %x : %x", td->altNextQTD, (uint32_t)td->altNextQTDVirt);
+    Log(Info, "    Flags  -> %x", td->flags);
+    Log(Info, "       |-> Status=%x PID=%d C-ERR=%d C-PAGE=%d IOC=%d TBTT=%d DT=%d", td->flags & 0xFF, (td->flags & (0b11<<8))>>8, (td->flags & (0b11<<10))>>10, (td->flags & (0b111<<12))>>12, (td->flags & (1<<15))>>15, (td->flags & (0b111111111111111<<16))>>16, (td->flags & (1<<31))>>31);
+
+    Log(Info, "------------------------------");
+}
+void EHCIController::PrintAsyncQueue()
+{
+    Log(Info, "------------------------------");
+    Log(Info, "     Start Of Queue Dump      ");
+    Log(Info, "------------------------------");
+
+    e_queueHead_t* qh = this->asyncList;
+    while(qh)
+    {
+        PrintQueueHead(qh);
+
+        qh = qh->horzPointerVirt;
+        if(qh == this->asyncList)
+            break;
+    }
+
+    Log(Info, "------------------------------");
+    Log(Info, "     End Of Queue Dump      ");
+    Log(Info, "------------------------------");
+}
+
+/////////
+// USB Controller Functions
+/////////
+
+bool EHCIController::BulkIn(USBDevice* device, void* retBuffer, int len, int endP)
+{
+    return BulkIn(device->endpoints[endP-1], device->devAddress, device->endpoints[endP-1]->maxPacketSize, endP, retBuffer, len);
+}
+bool EHCIController::BulkOut(USBDevice* device, void* sendBuffer, int len, int endP)
+{
+    return BulkOut(device->endpoints[endP-1], device->devAddress, device->endpoints[endP-1]->maxPacketSize, endP, sendBuffer, len);
+}
+
+bool EHCIController::ControlIn(USBDevice* device, void* target, const int len, const uint8_t requestType, const uint8_t request, const uint16_t valueHigh, const uint16_t valueLow, const uint16_t index)
+{
+    return ControlIn(target, device->devAddress, 64, len, requestType, request, valueHigh, valueLow, index);
+}
+bool EHCIController::ControlOut(USBDevice* device, const int len, const uint8_t requestType, const uint8_t request, const uint16_t valueHigh, const uint16_t valueLow, const uint16_t index)
+{
+    return ControlOut(device->devAddress, 64, len, requestType, request, valueHigh, valueLow, index);
+}
+
+void EHCIController::InterruptIn(USBDevice* device, int len, int endP)
+{
+
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/usb/controllers/ohci.cpp b/kernelz/src/system/drivers/usb/controllers/ohci.cpp
new file mode 100644
index 0000000..f7f7fad
--- /dev/null
+++ b/kernelz/src/system/drivers/usb/controllers/ohci.cpp
@@ -0,0 +1,811 @@
+#include <system/drivers/usb/controllers/ohci.h>
+#include <system/system.h>
+#include <system/memory/deviceheap.h>
+#include <system/drivers/usb/usbdefs.h>
+#include <system/drivers/usb/usbdriver.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+OHCIController::OHCIController(PCIDevice* device)
+: USBController(OHCI), Driver("OHCI USB Controller", "Controller for a OHCI device"),
+  InterruptHandler(IDT_INTERRUPT_OFFSET + device->interrupt) 
+{
+    this->pciDevice = device;
+}
+
+bool OHCIController::Initialize()
+{
+    BaseAddressRegister BAR0 = System::pci->GetBaseAddressRegister(pciDevice->bus, pciDevice->device, pciDevice->function, 0);
+    if(BAR0.type == InputOutput)
+        return false; // We only want memory mapped controllers
+
+    uint32_t memStart = pageRoundDown((uint32_t)BAR0.address); // Assuming 32-Bit address
+    uint32_t memEnd = pageRoundUp((uint32_t)BAR0.address + BAR0.size);
+    
+    // Allocate virtual chuck of memory that we can use for device
+    this->regBase = DeviceHeap::AllocateChunk(memEnd - memStart) + ((uint32_t)BAR0.address % PAGE_SIZE);
+
+    // Map memory so that we can use it
+    VirtualMemoryManager::mapVirtualToPhysical((void*)memStart, (void*)this->regBase, memEnd - memStart, true, true);
+
+    // Enable BUS Mastering
+    System::pci->Write(pciDevice->bus, pciDevice->device, pciDevice->function, 0x04, 0x0006);
+
+    // First, read the version register and check for version 1.0
+    if ((readMemReg(regBase + OHCRevision) & 0xFF) != 0x10)
+        return false;
+
+    // Reset the controller, returning false after 30mS if it doesn't reset
+    uint8_t timeout = 30;
+    writeMemReg(regBase + OHCCommandStatus, (1 << 0));
+    while (readMemReg(regBase + OHCCommandStatus) & (1 << 0)) {
+        System::pit->Sleep(1);
+        if (--timeout == 0)
+            return false;
+    }
+
+    // See if the controllers funtional state is in the suspend state
+    if ((readMemReg(regBase + OHCControl) & 0xC0) != 0xC0)
+        return false;
+    
+    // See if the frameinterval register is 0x2EDF
+    if ((readMemReg(regBase + OHCFmInterval) & 0x00003FFF) != 0x2EDF)
+        return false;
+
+    // Add ourself to known controllers
+    System::usbManager->AddController(this);
+
+    return true;
+}
+void OHCIController::Setup()
+{
+    // First get allignment of HCCA
+    // Write 0xFFFFFFFF to register
+    writeMemReg(regBase + OHCHCCA, 0xFFFFFFFF);
+    // Read back modified address
+    uint32_t ret = readMemReg(regBase + OHCHCCA);
+    // Allocate Memory for HCCA
+    this->hcca = (OHCI_HCCA*)KernelHeap::alignedMalloc(131072, ~ret + 1, &hccaPhys);
+    if(this->hcca == 0){
+        Log(Error, "[OHCI] Error Allocating HCCA Memory, Alignment = %x", ~ret + 1);
+        return;
+    }
+    // Clear structure
+    MemoryOperations::memset(this->hcca, 0x0, sizeof(OHCI_HCCA));
+
+    
+    /////////////////
+    // Create Control list
+    /////////////////
+    uint32_t controlEDBase = (uint32_t)KernelHeap::alignedMalloc(sizeof(o_endpointDescriptor_t) * NUM_CONTROL_EDS, 16);
+    for(int i = 0; i < NUM_CONTROL_EDS; i++) { // First Allocate all ED's
+        this->controlEndpoints[i] = (o_endpointDescriptor_t*)(controlEDBase + sizeof(o_endpointDescriptor_t) * i);
+        this->controlEndpointsPhys[i] = (uint32_t)VirtualMemoryManager::virtualToPhysical(this->controlEndpoints[i]);
+        MemoryOperations::memset(this->controlEndpoints[i], 0, sizeof(o_endpointDescriptor_t));
+    }
+    // Now make it a linked list
+    for (int i = 0; i < NUM_CONTROL_EDS; i++) {
+        controlEndpoints[i]->nextED = i < 15 ? controlEndpointsPhys[i + 1] : 0x00000000;
+        controlEndpoints[i]->flags = (1<<14); // sKip bit, should be 14 right? Not 13
+    }
+
+
+    /////////////////
+    // Create Bulk list
+    /////////////////
+    uint32_t bulkEDBase = (uint32_t)KernelHeap::alignedMalloc(sizeof(o_endpointDescriptor_t) * NUM_BULK_EDS, 16);
+    for(int i = 0; i < NUM_BULK_EDS; i++) { // First Allocate all ED's
+        this->bulkEndpoints[i] = (o_endpointDescriptor_t*)(bulkEDBase + sizeof(o_endpointDescriptor_t) * i);
+        this->bulkEndpointsPhys[i] = (uint32_t)VirtualMemoryManager::virtualToPhysical(this->bulkEndpoints[i]);
+        MemoryOperations::memset(this->bulkEndpoints[i], 0, sizeof(o_endpointDescriptor_t));
+    }
+    // Now make it a linked list
+    for (int i = 0; i < NUM_BULK_EDS; i++) {
+        bulkEndpoints[i]->nextED = i < 15 ? bulkEndpointsPhys[i + 1] : 0x00000000;
+        bulkEndpoints[i]->flags = (1<<14); // sKip bit, should be 14 right? Not 13
+    }
+
+    /////////////////
+    // Create Interrupt list
+    /////////////////
+    uint32_t interruptPhysical = 0;
+    this->interruptEndpoints = (o_endpointDescriptor_t*)KernelHeap::alignedMalloc(sizeof(o_endpointDescriptor_t) * 32, 16, &interruptPhysical);
+    uint8_t  routingTable[16] = { 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 };
+    for(int i = 0; i < 16; i++) {
+        hcca->HccaInterruptTable[i] = hcca->HccaInterruptTable[i+16] = interruptPhysical + sizeof(o_endpointDescriptor_t) * routingTable[i];
+    }
+
+    int j = 16;
+    for(int i = 0; i < 30; i+=2, j++) {
+        this->interruptEndpoints[i].nextED = this->interruptEndpoints[i+1].nextED = interruptPhysical + sizeof(o_endpointDescriptor_t) * j;
+    }
+    this->interruptEndpoints[30].nextED = 0;
+
+    for(int i = 0; i < 32; i++) {
+        this->interruptEndpoints[i].flags = (1<<14);
+        this->interruptEndpoints[i].headp = (1<<0);
+    }
+
+
+    // Reset the root hub
+    writeMemReg(regBase + OHCControl, 0x00000000);
+    System::pit->Sleep(50);
+    writeMemReg(regBase + OHCControl, 0x000000C0);  // Suspend (stop reset)
+    
+    // Set the Frame Interval, periodic start
+    writeMemReg(regBase + OHCFmInterval, 0xA7782EDF);
+    writeMemReg(regBase + OHCPeriodicStart, 0x00002A2F);
+
+    // Get the number of downstream ports
+    numPorts = (uint8_t)(readMemReg(regBase + OHCRhDescriptorA) & 0x000000FF);
+    Log(Info, "[OHCI] Found %d root hub ports.", numPorts);
+    
+    // Write the offset of our HCCA
+    writeMemReg(regBase + OHCHCCA, hccaPhys);
+
+    // write the offset of the control head ed
+    writeMemReg(regBase + OHCControlHeadED, controlEndpointsPhys[0]);
+    writeMemReg(regBase + OHCControlCurrentED, 0x00000000);
+    writeMemReg(regBase + OHCBulkHeadED, bulkEndpointsPhys[0]);
+    writeMemReg(regBase + OHCBulkCurrentED, 0x00000000);
+
+    // Enable all needed interrupts
+    writeMemReg(regBase + OHCInterruptEnable, (1<<0) | (1<<1) | (1<<2) | (1<<3) | (1<<4)| (0<<5) | (1<<6) | (1<<30) | (1<<31));
+    
+    // Start the controller  
+    writeMemReg(regBase + OHCControl, (1<<2) | (1<<4) | (1<<5) | (1<<7) | (1<<9) | (1<<10));  // CLE & operational
+    
+    // Set port power switching
+    uint32_t val = readMemReg(regBase + OHCRhDescriptorA);
+    // Read Power On To Power Good Time (Is in units of 2 mS)
+    uint16_t potpgt = (uint16_t) (((val >> 24) * 2) + 2);  // plus two to make sure we wait long enough
+    writeMemReg(regBase + OHCRhDescriptorA, ((val & OHCRhDescriptorA_MASK) & ~(1<<9)) | (1<<8));
+
+    // Loop through the ports
+    for (int i = 0; i < numPorts; i++) {
+        // Power the port
+        writeMemReg(regBase + OHCRhPortStatus + (i * 4), (1<<8));
+        System::pit->Sleep(potpgt);
+        
+        val = readMemReg(regBase + OHCRhPortStatus + (i * 4));
+        if (val & 1) {
+            if (!ResetPort(i))
+                continue;
+            
+            SetupNewDevice(i);
+        }
+    }
+}
+void OHCIController::SetupNewDevice(uint8_t port)
+{
+    struct DEVICE_DESC devDesc;
+
+    // Port has been reset, and is ready to be used
+    bool ls_device = (readMemReg(regBase + OHCRhPortStatus + (port * 4)) & (1<<9)) ? 1 : 0;
+    Log(Info, "[OHCI] Found Device at port %d, low speed = %b", port, ls_device);
+
+    // Some devices will only send the first 8 bytes of the device descriptor
+    // while in the default state.  We must request the first 8 bytes, then reset
+    // The port, set address, then request all 18 bytes.
+    bool good_ret = ControlIn(&devDesc, ls_device, 0, 8, 8, STDRD_GET_REQUEST, GET_DESCRIPTOR, DEVICE);
+    if (good_ret) {                
+        // Reset the port again
+        if (!ResetPort(port))
+            return;
+       
+        // Set address
+        good_ret = ControlOut(ls_device, 0, devDesc.max_packet_size, 0, STDRD_SET_REQUEST, SET_ADDRESS, 0, this->newDeviceAddress);
+        if (!good_ret) {
+            Log(Error, "[OHCI] Error when trying to set device address to %d", this->newDeviceAddress);
+            return;
+        }
+
+        // Create Device
+        USBDevice* newDev = new USBDevice();
+        newDev->controller = this;
+        newDev->devAddress = this->newDeviceAddress++;
+        newDev->portNum = port;
+        newDev->ohciProperties.desc_mps = devDesc.max_packet_size;
+        newDev->ohciProperties.ls_device = ls_device;
+        
+        System::usbManager->AddDevice(newDev);
+    }
+}
+void OHCIController::ControllerChecksThread()
+{
+    for (int i = 0; i < numPorts; i++) 
+    {        
+        uint32_t portSts = readMemReg(regBase + OHCRhPortStatus + (i * 4));
+        if(portSts & (1<<16)) // Port Connection Change Bit
+        {
+            writeMemReg(regBase + OHCRhPortStatus + (i * 4), (1<<16));
+            Log(Info, "[OHCI] Port %d Connection change, now %s", i, (portSts & (1<<0)) ? "Connected" : "Not Connected");
+
+            if((portSts & (1<<0)) == 1) { // Connected
+                if(ResetPort(i))
+                    SetupNewDevice(i);
+            }
+            else { // Not Connected
+                System::usbManager->RemoveDevice(this, i);
+            }
+        }
+    }
+}
+bool OHCIController::ResetPort(uint8_t port) {
+    int timeout = 300;
+    writeMemReg(regBase + OHCRhPortStatus + (port * 4), (1<<4)); // Reset port
+    while ((readMemReg(regBase + OHCRhPortStatus + (port * 4)) & (1<<20)) == 0) {
+        System::pit->Sleep(1);
+        if (--timeout == 0)
+            break;
+    }
+    if (timeout == 0) {
+        Log(Warning, "[OHCI] Port %d did not reset after 300mS.", port);
+        return false;
+    }
+    System::pit->Sleep(USB_TRSTRCY);  // Hold for USB_TRSTRCY ms (reset recovery time)
+    
+    // Clear status change bits
+    writeMemReg(regBase + OHCRhPortStatus + (port * 4), (0x1F<<16));
+    
+    return true;
+}
+bool OHCIController::ControlOut(const bool lsDevice, const int devAddress, const int packetSize, const int len, const uint8_t requestType, const uint8_t request, const uint16_t valueHigh, const uint16_t valueLow, const uint16_t index) 
+{
+    // Create setupPacket
+    uint32_t setupPacketPhys;
+    REQUEST_PACKET* setupPacket = (REQUEST_PACKET*)KernelHeap::alignedMalloc(sizeof(REQUEST_PACKET), 16, &setupPacketPhys);
+    {
+        setupPacket->request_type = requestType;
+        setupPacket->request = request;
+        setupPacket->value = (valueHigh << 8) | valueLow;
+        setupPacket->index = index;
+        setupPacket->length = len;
+    }
+
+    // Allocate Transfer Descriptors
+    uint32_t tdPhys;
+    o_transferDescriptor_t* td = (o_transferDescriptor_t*)KernelHeap::alignedMalloc(sizeof(o_transferDescriptor_t) * 2, 16, &tdPhys);
+    MemoryOperations::memset(td, 0, sizeof(o_transferDescriptor_t) * 2);
+    
+    // Create the setup td
+    td[0].flags = (14<<28) | (2<<24) | (7<<21) | (TD_DP_SETUP<<19);
+    td[0].curBufPtr = setupPacketPhys;
+    td[0].nextTd = tdPhys + sizeof(o_transferDescriptor_t);
+    td[0].bufEnd = td[0].curBufPtr + 7;
+    
+    // Create the status td
+    td[1].flags = (14<<28) | (3<<24) | (0<<21) | (TD_DP_IN<<19);
+    td[1].curBufPtr = 0;
+    td[1].nextTd = tdPhys + (sizeof(o_transferDescriptor_t) * 2);
+    td[1].bufEnd = 0;
+    
+    // Create the ED, using one already in the control list
+    this->controlEndpoints[0]->flags = (packetSize << 16) | (0 << 15) | (0 << 14) | (lsDevice ? (1<<13) : 0) | (0 << 11) | (ENDP_CONTROL << 7) | (devAddress & 0x7F);
+    this->controlEndpoints[0]->tailp = tdPhys + sizeof(o_transferDescriptor_t) * 2;
+    this->controlEndpoints[0]->headp = tdPhys;
+    
+    // Set ControlListFilled bit
+    writeMemReg(regBase + OHCCommandStatus, (1<<1));
+    
+    // Wait for TD completion
+    for(int c = 0; c <= 1; c++) {
+        int timeOut = OHCI_TD_TIMEOUT;
+        while((((td[c].flags & 0xF0000000) >> 28) == 14) && (timeOut > 0)) // This TD Has not been accesed
+        { 
+            timeOut--; 
+            System::pit->Sleep(1); 
+        }
+        //Log(Info, "OHCI TD %d Finished by controller err=%d timeout=%d", c, ((td[c].flags & 0xF0000000) >> 28), timeOut);
+    }
+
+    // Reset Used ED
+    this->controlEndpoints[0]->flags = (1<<14);
+    this->controlEndpoints[0]->tailp = 0;
+    this->controlEndpoints[0]->headp = 0;
+    
+    bool ret = true;
+    for (int i = 0; i < 2; i++) {
+        if ((td[i].flags & 0xF0000000) != 0) {
+            ret = false;
+            Log(Error, "[OHCI] our_tds[%d].cc != 0  (%d)", i, (td[i].flags & 0xF0000000) >> 28);
+            break;
+        }
+    }
+    
+    // Free td's
+    KernelHeap::allignedFree(td);
+    // Free Packet
+    KernelHeap::allignedFree(setupPacket);
+
+    return ret;
+}
+bool OHCIController::ControlIn(void* targ, const bool lsDevice, const int devAddress, const int packetSize, const int len, const uint8_t requestType, const uint8_t request, const uint16_t valueHigh, const uint16_t valueLow, const uint16_t index) {
+    // Create Request Packet
+    uint32_t requestPacketPhys;
+    REQUEST_PACKET* requestPacket = (REQUEST_PACKET*)KernelHeap::alignedMalloc(sizeof(REQUEST_PACKET), 16, &requestPacketPhys);
+    {
+        requestPacket->request_type = requestType;
+        requestPacket->request = request;
+        requestPacket->value = (valueHigh << 8) | valueLow;
+        requestPacket->index = index;
+        requestPacket->length = len;
+    }
+
+    // Create temporary buffer and clear it
+    uint32_t returnBufPhys;
+    uint8_t* returnBuf = (uint8_t*)KernelHeap::malloc(len, &returnBufPhys);
+    MemoryOperations::memset(returnBuf, 0, len);
+    
+    // Allocate Transfer Descriptors
+    uint32_t tdPhys;
+    o_transferDescriptor_t* td = (o_transferDescriptor_t*)KernelHeap::alignedMalloc(sizeof(o_transferDescriptor_t) * 10, 16, &tdPhys);
+    MemoryOperations::memset(td, 0, sizeof(o_transferDescriptor_t) * 10);
+    
+    // Create the setup td
+    td[0].flags = (14<<28) | (0 << 26) | (2 << 24) | (7<<21) | (TD_DP_SETUP << 19);
+    td[0].curBufPtr = requestPacketPhys;
+    td[0].nextTd = tdPhys + sizeof(o_transferDescriptor_t);
+    td[0].bufEnd = td[0].curBufPtr + 7;
+    
+    // Create the rest of the in td's
+    int i = 1; int p = 0; int t = 1;
+    int cnt = len;
+    while (cnt > 0) {
+        td[i].flags = (14<<28) | (0 << 26) | ((2 | (t & 1)) << 24) | (7<<21) | (TD_DP_IN << 19);
+        td[i].curBufPtr = returnBufPhys + p;
+        td[i].nextTd = td[i-1].nextTd + sizeof(o_transferDescriptor_t);
+        td[i].bufEnd = td[i].curBufPtr + ((cnt > packetSize) ? (packetSize - 1) : (cnt - 1));
+        t ^= 1;
+        p += packetSize;
+        i++;
+        cnt -= packetSize;
+    }
+    
+    // Create the status td
+    td[i].flags = (14<<28) | (0 << 26) | (3 << 24) | (0<<21) | (TD_DP_OUT << 19);
+    td[i].curBufPtr = 0;
+    td[i].nextTd = tdPhys + (sizeof(o_transferDescriptor_t) * i) + sizeof(o_transferDescriptor_t);
+    td[i].bufEnd = 0;
+    
+    // Create the ED, using one already in the control list
+    this->controlEndpoints[0]->flags = (packetSize << 16) | (0 << 15) | (0 << 14) | (lsDevice ? (1<<13) : 0) | (0 << 11) | (ENDP_CONTROL << 7) | (devAddress & 0x7F);
+    this->controlEndpoints[0]->tailp = td[i].nextTd;
+    this->controlEndpoints[0]->headp = tdPhys;
+
+    // Set ControlListFilled bit
+    writeMemReg(regBase + OHCCommandStatus, (1<<1));
+    
+    // Wait for TD completion
+    for(int c = 0; c <= i; c++) {
+        int timeOut = OHCI_TD_TIMEOUT;
+        while((((td[c].flags & 0xF0000000) >> 28) == 14) && (timeOut > 0)) // This TD Has not been accesed
+        { 
+            timeOut--; 
+            System::pit->Sleep(1); 
+        }
+        //Log(Info, "OHCI TD %d Finished by controller err=%d timeout=%d", c, ((td[c].flags & 0xF0000000) >> 28), timeOut);
+    }
+
+    // Reset Used ED
+    this->controlEndpoints[0]->flags = (1<<14);
+    this->controlEndpoints[0]->tailp = 0;
+    this->controlEndpoints[0]->headp = 0;
+    
+    // Calculate how many tds to check.
+    cnt = len;
+    if (cnt > 0)
+        cnt /= 8;
+    cnt += 2;
+    
+    bool ret = true;
+    for (int i = 0; i < cnt; i++) {
+        if ((td[i].flags & 0xF0000000) != 0) {
+            uint8_t err = (td[i].flags & 0xF0000000) >> 28;
+            ret = false;
+            Log(Error, "[OHCI] our_tds[%d].cc != 0  (%d)", i, err);
+            break;
+        }
+    }
+
+    if(ret) {
+        // Copy the descriptor to the passed memory block
+        MemoryOperations::memcpy(targ, returnBuf, len);
+    }
+    
+    // Free temporary buffer
+    KernelHeap::free(returnBuf);
+    // Free td's
+    KernelHeap::allignedFree(td);
+    // Free packet
+    KernelHeap::allignedFree(requestPacket);
+    
+    return ret;
+}
+bool OHCIController::BulkOut(const bool lsDevice, const int devAddress, const int packetSize, const int endP, void* bufPtr, const int len)
+{
+    uint32_t bufPhys = (uint32_t)VirtualMemoryManager::virtualToPhysical(bufPtr); 
+
+    // Allocate Transfer Descriptors
+    uint32_t tdPhys;
+    o_transferDescriptor_t* td = (o_transferDescriptor_t*)KernelHeap::alignedMalloc(sizeof(o_transferDescriptor_t) * 10, 16, &tdPhys);
+    MemoryOperations::memset(td, 0, sizeof(o_transferDescriptor_t) * 10);
+    
+    // Create the rest of the in td's
+    int i = 0; int p = 0; int toggle = 1;
+    int cnt = len;
+    while (cnt > 0) {
+        td[i].flags = (14<<28) | (0 << 26) | ((2 | (toggle & 1)) << 24) | (7<<21) | (0 << 19);
+        td[i].curBufPtr = bufPhys + p;
+        td[i].nextTd = ((i > 0) ? td[i-1].nextTd : tdPhys) + sizeof(o_transferDescriptor_t);
+        td[i].bufEnd = td[i].curBufPtr + ((cnt > packetSize) ? (packetSize - 1) : (cnt - 1));
+        toggle ^= 1;
+        p += packetSize;
+        i++;
+        cnt -= packetSize;
+    }
+    
+    // Create the ED, using one already in the bulk list
+    this->bulkEndpoints[0]->flags = (packetSize << 16) | (0 << 15) | (0 << 14) | (lsDevice ? (1<<13) : 0) | (TD_DP_OUT << 11) | (endP << 7) | (devAddress & 0x7F);
+    this->bulkEndpoints[0]->tailp = tdPhys + sizeof(o_transferDescriptor_t) * i;
+    this->bulkEndpoints[0]->headp = tdPhys;
+    
+    // Set BulkListFilled bit
+    writeMemReg(regBase + OHCCommandStatus, (1<<2));
+    
+    // Wait for TD completion
+    for(int c = 0; c < i; c++) {
+        int timeOut = OHCI_TD_TIMEOUT;
+        while((((td[c].flags & 0xF0000000) >> 28) == 14) && (timeOut > 0)) //This TD Has not been accesed
+        { 
+            timeOut--; 
+            System::pit->Sleep(1); 
+        }
+        //Log(Info, "OHCI TD %d Finished by controller err=%d timeout=%d", c, ((td[c].flags & 0xF0000000) >> 28), timeOut);
+        if(timeOut == 0)
+            break;
+    }
+
+    // Reset Used ED
+    this->bulkEndpoints[0]->flags = (1<<14);
+    this->bulkEndpoints[0]->tailp = 0;
+    this->bulkEndpoints[0]->headp = 0;
+    
+    bool ret = true;
+    for (int c = 0; c < i; c++) {
+        if ((td[c].flags & 0xF0000000) != 0) {
+            ret = false;
+            Log(Error, "[OHCI] our_tds[%d].cc != 0  (%d)", c, (td[c].flags & 0xF0000000) >> 28);
+            break;
+        }
+    }
+    
+    // Free td's
+    KernelHeap::allignedFree(td);
+    return ret;
+}
+bool OHCIController::BulkIn(const bool lsDevice, const int devAddress, const int packetSize, const int endP, void* bufPtr, const int len)
+{
+    // Create temporary buffer and clear it
+    uint32_t returnBufPhys;
+    uint8_t* returnBuf = (uint8_t*)KernelHeap::malloc(len, &returnBufPhys);
+    MemoryOperations::memset(returnBuf, 0, len);
+    
+    // Allocate Transfer Descriptors
+    uint32_t tdPhys;
+    o_transferDescriptor_t* td = (o_transferDescriptor_t*)KernelHeap::alignedMalloc(sizeof(o_transferDescriptor_t) * 10, 16, &tdPhys);
+    MemoryOperations::memset(td, 0, sizeof(o_transferDescriptor_t) * 10);
+    
+    // Create the rest of the in td's
+    int i = 0; int p = 0; int t = 1;
+    int cnt = len;
+    while (cnt > 0) {
+        td[i].flags = (14<<28) | (0 << 26) | ((2 | (t & 1)) << 24) | (7<<21) | (0 << 19) | (1<<18);
+        td[i].curBufPtr = returnBufPhys + p;
+        td[i].nextTd = ((i > 0) ? td[i-1].nextTd : tdPhys) + sizeof(o_transferDescriptor_t);
+        td[i].bufEnd = td[i].curBufPtr + ((cnt > packetSize) ? (packetSize - 1) : (cnt - 1));
+        t ^= 1;
+        p += packetSize;
+        i++;
+        cnt -= packetSize;
+    }
+    
+    // Create the ED, using one already in the bulk list
+    this->bulkEndpoints[0]->flags = (packetSize << 16) | (0 << 15) | (0 << 14) | (lsDevice ? (1<<13) : 0) | (TD_DP_IN << 11) | (endP << 7) | (devAddress & 0x7F);
+    this->bulkEndpoints[0]->tailp = tdPhys + sizeof(o_transferDescriptor_t) * i;
+    this->bulkEndpoints[0]->headp = tdPhys;
+
+    // Set BulklListFilled bit
+    writeMemReg(regBase + OHCCommandStatus, (1<<2));
+    
+    // Wait for TD completion
+    for(int c = 0; c < i; c++) {
+        int timeOut = OHCI_TD_TIMEOUT;
+        while((((td[c].flags & 0xF0000000) >> 28) == 14) && (timeOut > 0)) //This TD Has not been accesed
+        { 
+            timeOut--; 
+            System::pit->Sleep(1); 
+        }
+        //Log(Info, "OHCI TD %d Finished by controller err=%d timeout=%d", c, ((td[c].flags & 0xF0000000) >> 28), timeOut);
+    }
+
+    // Reset Used ED
+    this->bulkEndpoints[0]->flags = (1<<14);
+    this->bulkEndpoints[0]->tailp = 0;
+    this->bulkEndpoints[0]->headp = 0;
+    
+    bool ret = true;
+    for (int c = 0; c < i; c++) {
+        if ((td[c].flags & 0xF0000000) != 0) {
+            uint8_t err = (td[c].flags & 0xF0000000) >> 28;
+            ret = false;
+            Log(Error, "[OHCI] our_tds[%d].cc != 0  (%d)", c, err);
+            break;
+        }
+    }
+
+    if(ret) {
+        // Copy the descriptor to the passed memory block
+        MemoryOperations::memcpy(bufPtr, returnBuf, len);
+    }
+    
+    // Free temporary buffer
+    KernelHeap::free(returnBuf);
+    // Free td's
+    KernelHeap::allignedFree(td);
+    
+    return ret;
+}
+int OHCIController::CalculateRequiredQueue(int interval)
+{
+    uint8_t numAvailible = 0;
+    uint8_t chosenQueue = 0;
+    
+    switch(interval)
+    {
+        case 0 ... 1:
+        {
+            return 30;
+        }
+        case 2 ... 3:
+        {
+            chosenQueue = 28;
+            numAvailible = 2;
+            break;
+        }
+        case 4 ... 7:
+        {
+            chosenQueue = 24;
+            numAvailible = 4;
+            break;
+        }
+        case 8 ... 15:
+        {
+            chosenQueue = 16;
+            numAvailible = 8;
+            break;
+        }
+        default:
+        {
+            chosenQueue = 0;
+            numAvailible = 16;
+            break;
+        }
+    }
+    for(int i = chosenQueue; i < (chosenQueue + numAvailible); i++) {
+        if(this->interruptEndpoints[i].flags & (1<<14))
+            return i;
+    }
+    return -1;
+}
+void OHCIController::InterruptIn(const bool lsDevice, const int devAddress, const int packetSize, const int endP, int interval, USBDriver* handler, const int len)
+{
+    // Create temporary buffer and clear it
+    uint32_t returnBufPhys;
+    uint8_t* returnBuf = (uint8_t*)KernelHeap::malloc(len, &returnBufPhys);
+    MemoryOperations::memset(returnBuf, 0, len);
+    
+    // Allocate Transfer Descriptors
+    uint32_t tdPhys;
+    o_transferDescriptor_t* td = (o_transferDescriptor_t*)KernelHeap::alignedMalloc(sizeof(o_transferDescriptor_t) * 10, 16, &tdPhys);
+    MemoryOperations::memset(td, 0, sizeof(o_transferDescriptor_t) * 10);
+    
+    // Create the rest of the in td's
+    int i = 0; int p = 0;
+    int cnt = len;
+    while (cnt > 0) {
+        td[i].flags = (14<<28) | (0 << 26) | ((2 | (handler->device->endpoints[endP-1]->Toggle())) << 24) | (7<<21) | (0 << 19) | (1<<18);
+        td[i].curBufPtr = returnBufPhys + p;
+        td[i].nextTd = ((i > 0) ? td[i-1].nextTd : tdPhys) + sizeof(o_transferDescriptor_t);
+        td[i].bufEnd = td[i].curBufPtr + ((cnt > packetSize) ? (packetSize - 1) : (cnt - 1));
+
+        p += packetSize;
+        i++;
+        cnt -= packetSize;
+    }  
+
+    // Create Interrupt transfer info
+    InterruptTransfer_t* transfer = new InterruptTransfer_t();
+    transfer->bufferLen = len;
+    transfer->bufferPointer = returnBuf;
+    transfer->handler = handler;
+
+    transfer->queueIndex = CalculateRequiredQueue(interval);
+    if(transfer->queueIndex == -1) {
+        Log(Error, "[OHCI] no place left inside queue for interval %d", interval);
+        return;
+    }
+
+
+    // Controller specific
+    transfer->td = td;
+    transfer->numTd = i;
+    transfer->tdPhys = tdPhys;
+    transfer->qh = 0;
+    transfer->bufferPhys = returnBufPhys;
+    transfer->endpoint = endP;
+
+    // Add transfer to list
+    this->interrupTransfers.push_back(transfer);
+
+    // Place transfer in interrupt list
+    this->interruptEndpoints[transfer->queueIndex].headp = tdPhys;
+    this->interruptEndpoints[transfer->queueIndex].tailp = tdPhys + sizeof(o_transferDescriptor_t) * i;
+    this->interruptEndpoints[transfer->queueIndex].flags = (packetSize << 16) | (0 << 15) | (0 << 14) | (lsDevice ? (1<<13) : 0) | (TD_DP_IN << 11) | (endP << 7) | (devAddress & 0x7F);
+}
+
+int OHCIController::CheckTransferDone(o_transferDescriptor_t* td, int numTDs)
+{
+    bool noError = true;
+
+    // Check if any TD has a error or a NAK is received. If not then the transfer is complete.
+    for (int i = 0; i < numTDs; i++) {
+        uint32_t status = ((td[i].flags & 0xF0000000) >> 28);    
+        //Log(Info, "Status = %b", status);
+        if (status != 0) { // Check if any error bit is set or not done
+            if((status & (1<<3)) == (1<<3))
+                return 2; // (Only) Stall bit set
+            if(status == 14)
+                return 3; // (Only) Active bit set
+            
+            noError = false;
+            break;
+        }
+    }
+
+    return noError ? 0 : 1;
+}
+
+uint32_t OHCIController::HandleInterrupt(uint32_t esp)
+{
+    uint32_t val = readMemReg(regBase + OHCInterruptStatus);
+    if(val == 0)
+        return esp;
+
+    if (!((val & (1<<2)) || (val & (1<<6))))
+    {
+        Log(Info, "[OHCI] USB OHCI %d: ", this->hcca->HccaFrameNumber);
+    }
+
+    if (val & (1<<0))
+    {
+        Log(Info, "[OHCI] Scheduling overrun.");
+    }
+
+    if(val & (1<<1))
+    {
+        //Log(Info, "[OHCI] Writeback Done Head");
+    }
+
+    if(val & (1<<2))
+    {
+        //Log(Info, "OHCI: SOF");
+        for(InterruptTransfer_t* transfer : this->interrupTransfers) {
+            uint8_t status = CheckTransferDone((o_transferDescriptor_t*)transfer->td, transfer->numTd);
+
+            if(status != 3) // Done or error
+            {
+                //Log(Info, "OHCI, Transfer finished with status -> %d", status);
+
+                // Check if it is a succesfull transfer, if not just clear the buffer
+                if(status == 1 || status == 2)
+                    MemoryOperations::memset(transfer->bufferPointer, 0, transfer->bufferLen);
+
+                if(status == 2)
+                    Log(Warning, "[OHCI] Received NAK");
+                
+                bool rescedule = transfer->handler->HandleInterruptPacket(transfer);
+                
+                if(rescedule) {
+                    MemoryOperations::memset(transfer->bufferPointer, 0, transfer->bufferLen);
+                    
+                    o_transferDescriptor_t* td = (o_transferDescriptor_t*)transfer->td;
+                    for(int i = 0; i < transfer->numTd; i++) {
+                        td[i].flags |= (14<<28); // Mark all transfer descriptors as active again
+                        td[i].flags = (td[i].flags & ~(1 << 24)) | (transfer->handler->device->endpoints[transfer->endpoint-1]->Toggle() << 24);
+                        td[i].curBufPtr = transfer->bufferPhys;
+                        td[i].bufEnd = transfer->bufferPhys + transfer->bufferLen - 1;
+                        td[i].nextTd = transfer->tdPhys + i * sizeof(o_transferDescriptor_t);
+                    }
+
+                    this->interruptEndpoints[transfer->queueIndex].headp = transfer->tdPhys;
+
+
+                    //uint32_t* b = (uint32_t*)td;
+                    //Log(Info, "AC -> TD Bytes %x %x %x %x", b[0], b[1], b[2], b[3]);
+
+                    //uint32_t* b2 = (uint32_t*)&this->interruptEndpoints[transfer->queueIndex];
+                    //Log(Info, "AC -> TD Bytes %x %x %x %x", b2[0], b2[1], b2[2], b2[3]);
+                }
+                else {
+                    this->interruptEndpoints[transfer->queueIndex].flags = (1<<14);
+                    
+                    // Free temporary buffer
+                    if(transfer->bufferPointer) KernelHeap::free(transfer->bufferPointer);
+                    // Free td's
+                    if(transfer->td) KernelHeap::allignedFree(transfer->td);
+
+                    this->interrupTransfers.Remove(transfer);
+                    delete transfer;
+                }
+            }
+        }
+    }
+
+    if (val & (1<<3))
+    {
+        Log(Info, "[OHCI] Resume detected.");
+    }
+
+    if (val & (1<<4))
+    {
+        Log(Info, "[OHCI] Unrecoverable HC error.");
+    }
+
+    if (val & (1<<5))
+    {
+        Log(Info, "[OHCI] Frame number overflow");
+    }
+    if ((val & (1<<6)))
+    {
+        Log(Info, "[OHCI] Root hub status change");
+    }
+    if (val & (1<<30))
+    {
+        Log(Info, "[OHCI] ownership change");
+    }
+
+    writeMemReg(regBase + OHCInterruptStatus, val); // reset interrupts
+
+    return esp;
+}
+/////////
+// USB Controller Functions
+/////////
+
+bool OHCIController::BulkIn(USBDevice* device, void* retBuffer, int len, int endP)
+{
+    return BulkIn(device->ohciProperties.ls_device, device->devAddress, device->endpoints[endP-1]->maxPacketSize, endP, retBuffer, len);
+}
+bool OHCIController::BulkOut(USBDevice* device, void* sendBuffer, int len, int endP)
+{
+    return BulkOut(device->ohciProperties.ls_device, device->devAddress, device->endpoints[endP-1]->maxPacketSize, endP, sendBuffer, len);
+}
+
+bool OHCIController::ControlIn(USBDevice* device, void* target, const int len, const uint8_t requestType, const uint8_t request, const uint16_t valueHigh, const uint16_t valueLow, const uint16_t index)
+{
+    return ControlIn(target, device->ohciProperties.ls_device, device->devAddress, device->ohciProperties.desc_mps, len, requestType, request, valueHigh, valueLow, index);
+}
+bool OHCIController::ControlOut(USBDevice* device, const int len, const uint8_t requestType, const uint8_t request, const uint16_t valueHigh, const uint16_t valueLow, const uint16_t index)
+{
+    return ControlOut(device->ohciProperties.ls_device, device->devAddress, device->ohciProperties.desc_mps, len, requestType, request, valueHigh, valueLow, index);
+}
+
+void OHCIController::InterruptIn(USBDevice* device, int len, int endP)
+{
+    InterruptIn(device->ohciProperties.ls_device, device->devAddress, device->endpoints[endP-1]->maxPacketSize, endP, device->endpoints[endP-1]->interval, device->driver, len);
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/usb/controllers/uhci.cpp b/kernelz/src/system/drivers/usb/controllers/uhci.cpp
new file mode 100644
index 0000000..d140b4b
--- /dev/null
+++ b/kernelz/src/system/drivers/usb/controllers/uhci.cpp
@@ -0,0 +1,776 @@
+#include <system/drivers/usb/controllers/uhci.h>
+#include <system/drivers/usb/usbdefs.h>
+#include <system/drivers/usb/usbdriver.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+UHCIController::UHCIController(PCIDevice* device)
+: USBController(UHCI), Driver("UHCI USB Controller", "Controller for a UHCI device"), InterruptHandler(IDT_INTERRUPT_OFFSET + device->interrupt)
+{
+    this->pciDevice = device;
+    this->numRootPorts = 0;
+}
+
+void UHCIController::InsertQueue(uhci_queue_head_t* queue, uint32_t queuePhys, const int queueIndex)
+{
+    uhci_queue_head_t* curQueue = &this->queueStackList[queueIndex];
+
+    if((curQueue->vert_ptr & QUEUE_HEAD_T) == QUEUE_HEAD_T) { // First time a queue is added to this chain
+        curQueue->vert_ptr = queuePhys | QUEUE_HEAD_Q;
+        curQueue->nextQueuePointer = queue;
+
+        queue->horz_ptr = QUEUE_HEAD_T; // Should be set already, just to be sure
+        queue->parentQueuePointer = curQueue;
+    }
+    else // Queue can be added horizontaly to existing entries
+    {
+        while(curQueue->nextQueuePointer != 0)
+            curQueue = (uhci_queue_head_t*)curQueue->nextQueuePointer;
+
+        queue->horz_ptr = curQueue->horz_ptr;
+        curQueue->horz_ptr = queuePhys | QUEUE_HEAD_Q;
+
+        queue->nextQueuePointer = curQueue->nextQueuePointer;
+
+        curQueue->nextQueuePointer = queue;
+        queue->parentQueuePointer = curQueue;
+    }
+}
+
+void UHCIController::RemoveQueue(uhci_queue_head_t* queue, const int queueIndex)
+{
+    uhci_queue_head_t* parent = (uhci_queue_head_t*)queue->parentQueuePointer;
+    uhci_queue_head_t* child = (uhci_queue_head_t*)queue->nextQueuePointer;
+
+    if(parent == &this->queueStackList[queueIndex]) { // Queue is Below first Queue head of skeleton 
+        parent->vert_ptr = queue->horz_ptr;
+        if(child)
+            child->parentQueuePointer = parent;
+    }
+    else { // Queue is not the first entry in the chain
+        parent->horz_ptr = queue->horz_ptr;
+        parent->nextQueuePointer = child;
+
+        if(child)
+            child->parentQueuePointer = parent;
+    }
+}
+
+int UHCIController::CalculateRequiredQueue(int interval)
+{
+    switch(interval)
+    {
+        case 0 ... 1:
+            return U_QUEUE_Q1;
+        case 2 ... 3:
+            return U_QUEUE_Q2;
+        case 4 ... 7:
+            return U_QUEUE_Q4;
+        case 8 ... 15:
+            return U_QUEUE_Q8;
+        case 16 ... 31:
+            return U_QUEUE_Q16;
+        case 32 ... 63:
+            return U_QUEUE_Q32;
+        case 64 ... 127:
+            return U_QUEUE_Q64;
+        default:
+            return U_QUEUE_Q128;
+    }
+}
+
+bool UHCIController::Initialize()
+{
+    // We do not want memory mapped controllers
+    if(System::pci->GetBaseAddressRegister(pciDevice->bus, pciDevice->device, pciDevice->function, 4).type == BaseAddressRegisterType::MemoryMapping)
+        return false;
+    
+    uint32_t base = pciDevice->portBase;
+
+    // Enable BUS Mastering
+    System::pci->Write(pciDevice->bus, pciDevice->device, pciDevice->function, 0x04, 0b101);
+
+    // Disable All interrupts
+    outportw(pciDevice->portBase + UHCI_INTERRUPT, 0b0000);
+
+    // Perform a global reset
+    for(int i = 0; i < 5; i++) {
+        outportw(base + UHCI_COMMAND, 0x0004);
+        System::pit->Sleep(11);
+        outportw(base + UHCI_COMMAND, 0x0000);
+    }
+
+    // Check if command register has default value
+    if(inportw(base+UHCI_COMMAND) != 0x0000) return false;
+    // Check if status register has default value
+    if(inportw(base+UHCI_STATUS) != 0x0020) return false;
+
+    // Clear status register
+    outportw(base+UHCI_STATUS, 0x00FF);
+
+    // Read SOF Value
+    uint8_t sofBeforeReset = inportb(base + UHCI_SOF_MOD);
+
+    // Set bit 1 in command register, should be reset automaticly
+    outportw(base+UHCI_COMMAND, 0x0002);
+
+    // Give the controller some time
+    System::pit->Sleep(42);
+
+    // Bit should be clear
+    if(inportw(base+UHCI_COMMAND) & 0x0002) return false;
+
+    // Write SOF back to device
+    outportb(base + UHCI_SOF_MOD, sofBeforeReset);
+
+    // Disable Legacy Support
+    System::pci->Write(pciDevice->bus, pciDevice->device, pciDevice->function, UHCI_LEGACY, 0xAF00);
+
+    // Add ourself to known controllers
+    System::usbManager->AddController(this);
+
+    return true;
+}
+void UHCIController::Setup()
+{
+    // Enable All interrupts
+    outportw(pciDevice->portBase + UHCI_INTERRUPT, 0b1111);
+    // Set frame number register to 0
+    outportw(pciDevice->portBase + UHCI_FRAME_NUM, 0x0000);
+
+    // Allocate Stack frame
+    this->frameList = (uint32_t*)KernelHeap::alignedMalloc(1024 * sizeof(uint32_t), 4096, &this->frameListPhys);
+    MemoryOperations::memset(this->frameList, 0x0, 1024 * sizeof(uint32_t));
+
+    // Allocate queue stack list
+    uint32_t queuePhysStart = 0;
+    this->queueStackList = (uhci_queue_head_t*)KernelHeap::alignedMalloc(sizeof(uhci_queue_head_t) * NUM_UHCI_QUEUES, 16, &queuePhysStart);
+    MemoryOperations::memset(this->queueStackList, 0x0, sizeof(uhci_queue_head_t) * NUM_UHCI_QUEUES);
+
+    // Set all queue entries to invalid
+    for(int i = 0; i < NUM_UHCI_QUEUES; i++) {
+        this->queueStackList[i].horz_ptr = QUEUE_HEAD_T;
+        this->queueStackList[i].vert_ptr = QUEUE_HEAD_T;
+    }
+
+    // Setup queue entries to point to each other
+    // 128 -> 64 -> 32 -> 16 -> 8 -> 4 -> 2 -> 1 -> QControl -> QBulk
+    for(int i = 0; i < NUM_UHCI_QUEUES - 1; i++) {
+        this->queueStackList[i].horz_ptr = (queuePhysStart + (i + 1) * sizeof(uhci_queue_head_t)) | QUEUE_HEAD_Q;
+    }
+
+    // Setup UHCI stack frame
+    for(int i = 0; i < 1024; i++) {
+        int queueStart = U_QUEUE_Q1;
+        if((i + 1) % 2 == 0) queueStart--;
+        if((i + 1) % 4 == 0) queueStart--;
+        if((i + 1) % 8 == 0) queueStart--;
+        if((i + 1) % 16 == 0) queueStart--;
+        if((i + 1) % 32 == 0) queueStart--;
+        if((i + 1) % 64 == 0) queueStart--;
+        if((i + 1) % 128 == 0) queueStart--;
+
+        this->frameList[i] = (queuePhysStart + queueStart * sizeof(uhci_queue_head_t)) | QUEUE_HEAD_Q;
+    }
+
+    // Set stack frame address
+    outportl(pciDevice->portBase + UHCI_FRAME_BASE, frameListPhys);
+    // Clear status register
+    outportw(pciDevice->portBase + UHCI_STATUS, 0xFFFF);
+    // Finally enable controller (Max Packet bit, Configured bit and run bit)
+    outportw(pciDevice->portBase + UHCI_COMMAND, (1<<7) | (1<<6) | (1<<0));
+
+    /////////////
+    // Device Enumeration
+    /////////////
+    uint8_t port = 0x10; // Start of ports
+    while (PortPresent(port)) {
+        numRootPorts++;
+        // Reset the port
+        if (ResetPort(port)) {
+            // Is a device is attached?
+            if (inportw(pciDevice->portBase + port) & 1) {
+                SetupNewDevice(port);
+            }
+        }
+        port += 2;  // Move to next port
+    }
+}
+void UHCIController::SetupNewDevice(uint8_t port)
+{
+    struct DEVICE_DESC dev_desc;
+
+    bool ls_device = (inportw(pciDevice->portBase + port) & (1<<8)) ? true : false;
+    Log(Info, "[UHCI] Found Device at port %d, low speed = %b", (port - 0x10) / 2, ls_device);
+
+    // Get first 8 bytes of descriptor
+    if (ControlIn(&dev_desc, ls_device, 0, 8, 8, STDRD_GET_REQUEST, DeviceRequest::GET_DESCRIPTOR, DescriptorTypes::DEVICE)) 
+    {
+        // Reset the port again
+        ResetPort(port);
+        // Set address of device
+        if (ControlOut(ls_device, 0, dev_desc.max_packet_size, 0, STDRD_SET_REQUEST, SET_ADDRESS, 0, this->newDeviceAddress)) 
+        {
+            // Setup device
+            USBDevice* newDev = new USBDevice();
+            newDev->controller = this;
+            newDev->devAddress = this->newDeviceAddress++;
+            newDev->portNum = (port - 0x10) / 2;
+            newDev->uhciProperties.lowSpeedDevice = ls_device;
+            newDev->uhciProperties.maxPacketSize = dev_desc.max_packet_size;
+            System::usbManager->AddDevice(newDev);
+        } 
+        else
+            Log(Error, "[UHCI] Error setting device address.");
+    } 
+    else
+        Log(Error, "[UHCI] Error getting first 8 bytes of descriptor.");
+}
+void UHCIController::ControllerChecksThread()
+{
+    for(int i = 0; i < numRootPorts; i++)
+    {
+        uint8_t port = 0x10 + i*2;
+
+        uint16_t portSts = inportw(pciDevice->portBase + port);
+        if(portSts & (1<<1)) // Port Connection Change Bit
+        {
+            outportw(pciDevice->portBase + port, (1<<1));
+            Log(Info, "[UHCI] Port %d Connection change, now %s", i, (portSts & (1<<0)) ? "Connected" : "Not Connected");
+
+            if((portSts & (1<<0)) == 1) { // Connected
+                if(ResetPort(port))
+                    SetupNewDevice(port);
+            }
+            else { // Not Connected
+                System::usbManager->RemoveDevice(this, i);
+            }
+        }
+    }
+}
+bool UHCIController::PortPresent(uint8_t port)
+{
+    uint32_t base = pciDevice->portBase;
+
+    // If bit 7 is 0, not a port
+    if ((inportw(base+port) & 0x0080) == 0) return false;
+
+    // Try to clear it
+    outportw(base+port, inportw(base+port) & ~0x0080);
+    if ((inportw(base+port) & 0x0080) == 0) return false;
+
+    // Try to write/clear it
+    outportw(base+port, inportw(base+port) | 0x0080);
+    if ((inportw(base+port) & 0x0080) == 0) return false;
+
+    // Let's see if we write a 1 to bits 3:1, if they come back as zero
+    outportw(base+port, inportw(base+port) | 0x000A);
+    if ((inportw(base+port) & 0x000A) != 0) return false;
+  
+    // We should be able to assume this is a valid port if we get here
+    return true;
+}
+bool UHCIController::ResetPort(uint8_t port)
+{
+    uint32_t base = pciDevice->portBase;
+    bool ret = false;
+    
+    outportw(base+port, inportw(base + port) | (1<<9));
+    System::pit->Sleep(USB_TDRSTR);
+    outportw(base + port, inportw(base+port) & ~(1<<9));
+    
+    for (int i = 0; i < 10; i++) {
+        System::pit->Sleep(USB_TRSTRCY);  // Hold for USB_TRSTRCY ms (reset recovery time)
+        
+        uint16_t val = inportw(base + port);
+        
+        // If bit 0 is clear, nothing attached, don't enable
+        if (!(val & (1<<0))) {
+            ret = false;
+            break;
+        }
+        
+        // If either enable_change or connection_change, clear them and continue.
+        if (val & ((1<<3) | (1<<1))) {
+            outportw(base + port, val & UHCI_PORT_WRITE_MASK);
+            continue;
+        }
+        
+        // If the enable bit is set, break.
+        if (val & (1<<2)) {
+            ret = true;
+            break;
+        }
+        
+        // Else, set the enable bit
+        outportw(base + port, val | (1<<2));
+    }
+    
+    return ret;
+}
+
+int UHCIController::CheckTransferDone(u_transferDescriptor_t* td, int numTDs)
+{
+    bool noError = true;
+
+    // Check if any TD has a error or a NAK is received. If not then the transfer is complete.
+    for (int i = 0; i < numTDs; i++) {
+        uint8_t status = td[i].reply & (0xFF << 16);
+        //Log(Info, "Status = %b", status);
+        if (status != 0) { // Check if any error bit is set or not done
+            if((status & (1<<3)) == (1<<3))
+                return 2; // (Only) NAK bit set
+            if((status & (1<<7)) == (1<<7))
+                return 3; // (Only) Active bit set
+            
+            noError = false;
+            break;
+        }
+    }
+
+    return noError ? 0 : 1;
+}
+
+// Set up a queue, and enough TD's to get 'size' bytes
+bool UHCIController::ControlIn(void* targ, const bool lsDevice, const int devAddress, const int packetSize, const int len, const uint8_t requestType, const uint8_t request, const uint16_t valueHigh, const uint16_t valueLow, const uint16_t index) {
+    // Create Request Packet
+    uint32_t requestPacketPhys;
+    REQUEST_PACKET* requestPacket = (REQUEST_PACKET*)KernelHeap::alignedMalloc(sizeof(REQUEST_PACKET), 16, &requestPacketPhys);
+    {
+        requestPacket->request_type = requestType;
+        requestPacket->request = request;
+        requestPacket->value = (valueHigh << 8) | valueLow;
+        requestPacket->index = index;
+        requestPacket->length = len;
+    }
+
+    // Create temporary buffer and clear it
+    uint32_t returnBufPhys;
+    uint8_t* returnBuf = (uint8_t*)KernelHeap::malloc(len, &returnBufPhys);
+    MemoryOperations::memset(returnBuf, 0, len);
+    
+    // Allocate Transfer Descriptors
+    uint32_t tdPhys;
+    u_transferDescriptor_t* td = (u_transferDescriptor_t*)KernelHeap::alignedMalloc(sizeof(u_transferDescriptor_t) * 10, 16, &tdPhys);
+    MemoryOperations::memset(td, 0, sizeof(u_transferDescriptor_t) * 10);
+
+    // Allocate queue head
+    uint32_t queuePhys;
+    uhci_queue_head_t* queue = (uhci_queue_head_t*)KernelHeap::alignedMalloc(sizeof(uhci_queue_head_t), 16, &queuePhys);
+    MemoryOperations::memset(queue, 0, sizeof(uhci_queue_head_t));
+    queue->horz_ptr = QUEUE_HEAD_T;
+    queue->vert_ptr = tdPhys;
+
+    // Setup Transfer Descriptor
+    td[0].link_ptr = ((tdPhys & ~0xF) + sizeof(u_transferDescriptor_t));
+    td[0].reply = (lsDevice ? (1<<26) : 0) | (3<<27) | (0x80 << 16);
+    td[0].info = (7<<21) | ((devAddress & 0x7F)<<8) | (ENDP_CONTROL<<15) | TOKEN_SETUP;
+    td[0].buff_ptr = requestPacketPhys;
+    
+    int i = 1;
+    int sz = len;
+    // Transfer Descriptors depending on size of request
+    while ((sz > 0) && (i<9)) {
+        td[i].link_ptr = ((td[i-1].link_ptr & ~0xF) + sizeof(u_transferDescriptor_t));
+        td[i].reply = (lsDevice ? (1<<26) : 0) | (3<<27) | (0x80 << 16);
+        int t = ((sz <= packetSize) ? sz : packetSize);
+        td[i].info = ((t-1)<<21) | ((i & 1) ? (1<<19) : 0)  | (ENDP_CONTROL<<15) | ((devAddress & 0x7F)<<8) | TOKEN_IN;
+        td[i].buff_ptr = returnBufPhys + (8 * (i-1));
+        sz -= t;
+        i++;
+    }    
+
+    // Acknowledge Transfer Descriptor (Status)
+    td[i].link_ptr = 0x00000001;
+    td[i].reply = (lsDevice ? (1<<26) : 0) | (3<<27) | (0<<24) | (0x80 << 16);
+    td[i].info = (0x7FF<<21) | (1<<19) | (ENDP_CONTROL<<15) | ((devAddress & 0x7F)<<8) | TOKEN_OUT;
+    td[i].buff_ptr = 0x00000000;
+    i++; // for a total count
+
+    // Instert queue into QControl list
+    InsertQueue(queue, queuePhys, U_QUEUE_QControl);
+    
+    // Wait for transfer completion
+    int timeout = 1000;
+    int status = 3; // We need to wait at least 10ms because some VM's (like qemu) clear the active bit first before actualy writing the data
+    while (status == 3 && (timeout > 0)) {
+        timeout -= 10;
+        System::pit->Sleep(10);
+        status = CheckTransferDone(td, i);
+    }
+    //Log(Info, "UHCI, Transfer finished with status -> %d", status);
+    RemoveQueue(queue, U_QUEUE_QControl);
+
+    if (timeout == 0) {
+        Log(Warning, "[UHCI] timed out.");
+        return false;
+    }
+    
+    if(status == 0) {
+        // Copy the descriptor to the passed memory block
+        MemoryOperations::memcpy(targ, returnBuf, len);
+    }
+    
+    // Free temporary buffer
+    KernelHeap::free(returnBuf);
+    // Free td's
+    KernelHeap::allignedFree(td);
+    // Free queue head
+    KernelHeap::allignedFree(queue);
+    // Free Packet
+    KernelHeap::allignedFree(requestPacket);
+
+    return status == 0;
+}
+bool UHCIController::ControlOut(const bool lsDevice, const int devAddress, const int packetSize, const int len, const uint8_t requestType, const uint8_t request, const uint16_t valueHigh, const uint16_t valueLow, const uint16_t index) {
+    // Create setupPacket
+    uint32_t setupPacketPhys;
+    REQUEST_PACKET* setupPacket = (REQUEST_PACKET*)KernelHeap::alignedMalloc(sizeof(REQUEST_PACKET), 16, &setupPacketPhys);
+    {
+        setupPacket->request_type = requestType;
+        setupPacket->request = request;
+        setupPacket->value = (valueHigh << 8) | valueLow;
+        setupPacket->index = index;
+        setupPacket->length = len;
+    }
+    
+    // Allocate Transfer Descriptors
+    uint32_t tdPhys;
+    u_transferDescriptor_t* td = (u_transferDescriptor_t*)KernelHeap::alignedMalloc(sizeof(u_transferDescriptor_t) * 2, 16, &tdPhys);
+    MemoryOperations::memset(td, 0, sizeof(u_transferDescriptor_t) * 2);
+
+    // Allocate queue head
+    uint32_t queuePhys;
+    uhci_queue_head_t* queue = (uhci_queue_head_t*)KernelHeap::alignedMalloc(sizeof(uhci_queue_head_t), 16, &queuePhys);
+    MemoryOperations::memset(queue, 0, sizeof(uhci_queue_head_t));
+    queue->horz_ptr = QUEUE_HEAD_T;
+    queue->vert_ptr = tdPhys;
+    
+    // Create setup td
+    td[0].link_ptr = ((tdPhys & ~0xF) + sizeof(u_transferDescriptor_t));
+    td[0].reply = (lsDevice ? (1<<26) : 0) | (3<<27) | (0x80 << 16);
+    td[0].info = (7<<21) | (ENDP_CONTROL<<15) | ((devAddress & 0x7F)<<8) | TOKEN_SETUP;
+    td[0].buff_ptr = setupPacketPhys;
+    
+    // Create status td
+    td[1].link_ptr = 0x00000001;
+    td[1].reply = (lsDevice ? (1<<26) : 0) | (3<<27) | (0<<24) | (0x80 << 16);
+    td[1].info = (0x7FF<<21) | (1<<19) | (ENDP_CONTROL<<15) | ((devAddress & 0x7F)<<8) | TOKEN_IN;
+    td[1].buff_ptr = 0x00000000;
+    
+    // Instert queue into QControl list
+    InsertQueue(queue, queuePhys, U_QUEUE_QControl);
+    
+    // Wait for transfer completion
+    int timeout = 1000;
+    int status = 3; // We need to wait at least 10ms because some VM's (like qemu) clear the active bit first before actualy writing the data
+    while (status == 3 && (timeout > 0)) {
+        timeout -= 10;
+        System::pit->Sleep(10);
+        status = CheckTransferDone(td, 2);
+    }
+    //Log(Info, "UHCI, Transfer finished with status -> %d", status);
+    RemoveQueue(queue, U_QUEUE_QControl);
+
+    // Free td's
+    KernelHeap::allignedFree(td);
+    // Free queue head
+    KernelHeap::allignedFree(queue);
+    // Free packet
+    KernelHeap::allignedFree(setupPacket);
+
+    return status == 0;
+}
+bool UHCIController::BulkOut(const bool lsDevice, const int devAddress, const int packetSize, const int endP, void* bufPtr, const int len)
+{
+    uint32_t bufPhys = (uint32_t)VirtualMemoryManager::virtualToPhysical(bufPtr); 
+
+    // Allocate Transfer Descriptors
+    uint32_t tdPhys;
+    u_transferDescriptor_t* td = (u_transferDescriptor_t*)KernelHeap::alignedMalloc(sizeof(u_transferDescriptor_t) * 10, 16, &tdPhys);
+    MemoryOperations::memset(td, 0, sizeof(u_transferDescriptor_t) * 10);
+
+    // Allocate queue head
+    uint32_t queuePhys;
+    uhci_queue_head_t* queue = (uhci_queue_head_t*)KernelHeap::alignedMalloc(sizeof(uhci_queue_head_t), 16, &queuePhys);
+    MemoryOperations::memset(queue, 0, sizeof(uhci_queue_head_t));
+    queue->horz_ptr = QUEUE_HEAD_T;
+    queue->vert_ptr = tdPhys;
+    
+    int i = 0;
+    int sz = len;
+    // Transfer Descriptors depending on size of request
+    while ((sz > 0) && (i<9)) {
+        td[i].link_ptr = (i > 0 ? (td[i-1].link_ptr & ~0xF) : tdPhys) + sizeof(u_transferDescriptor_t);
+        td[i].reply = (lsDevice ? (1<<26) : 0) | (3<<27) | (0x80 << 16);
+        int t = ((sz <= packetSize) ? sz : packetSize);
+        td[i].info = ((t-1)<<21) | ((i & 1) ? (1<<19) : 0)  | (endP<<15) | ((devAddress & 0x7F)<<8) | TOKEN_OUT;
+        td[i].buff_ptr = bufPhys + (packetSize*i);
+        sz -= t;
+        i++;
+    }
+
+    // Instert queue into QBulk list
+    InsertQueue(queue, queuePhys, U_QUEUE_QBulk);
+    
+    // Wait for transfer completion
+    int timeout = 1000;
+    int status = 3; // We need to wait at least 10ms because some VM's (like qemu) clear the active bit first before actualy writing the data
+    while (status == 3 && (timeout > 0)) {
+        timeout -= 10;
+        System::pit->Sleep(10);
+        status = CheckTransferDone(td, i);
+    }
+    //Log(Info, "UHCI, Transfer finished with status -> %d", status);
+    RemoveQueue(queue, U_QUEUE_QBulk);
+    
+    // Free td's
+    KernelHeap::allignedFree(td);
+    // Free queue head
+    KernelHeap::allignedFree(queue);
+
+    return status == 0;
+}
+bool UHCIController::BulkIn(const bool lsDevice, const int devAddress, const int packetSize, const int endP, void* bufPtr, const int len)
+{
+    // Create temporary buffer and clear it
+    uint32_t returnBufPhys;
+    uint8_t* returnBuf = (uint8_t*)KernelHeap::malloc(len, &returnBufPhys);
+    MemoryOperations::memset(returnBuf, 0, len);
+    
+    // Allocate Transfer Descriptors
+    uint32_t tdPhys;
+    u_transferDescriptor_t* td = (u_transferDescriptor_t*)KernelHeap::alignedMalloc(sizeof(u_transferDescriptor_t) * 10, 16, &tdPhys);
+    MemoryOperations::memset(td, 0, sizeof(u_transferDescriptor_t) * 10);
+
+    // Allocate queue head
+    uint32_t queuePhys;
+    uhci_queue_head_t* queue = (uhci_queue_head_t*)KernelHeap::alignedMalloc(sizeof(uhci_queue_head_t), 16, &queuePhys);
+    MemoryOperations::memset(queue, 0, sizeof(uhci_queue_head_t));
+    queue->horz_ptr = QUEUE_HEAD_T;
+    queue->vert_ptr = tdPhys;
+    
+    int i = 0;
+    int sz = len;
+    // Transfer Descriptors depending on size of request
+    while ((sz > 0) && (i<9)) {
+        td[i].link_ptr = (i > 0 ? (td[i-1].link_ptr & ~0xF) : tdPhys) + sizeof(u_transferDescriptor_t);
+        td[i].reply = (lsDevice ? (1<<26) : 0) | (3<<27) | (0x80 << 16);
+        int t = ((sz <= packetSize) ? sz : packetSize);
+        td[i].info = ((t-1)<<21) | ((i & 1) ? (1<<19) : 0)  | (endP<<15) | ((devAddress & 0x7F)<<8) | TOKEN_IN;
+        td[i].buff_ptr = returnBufPhys + (packetSize*i);
+        sz -= t;
+        i++;
+    }
+    
+    // Instert queue into QBulk list
+    InsertQueue(queue, queuePhys, U_QUEUE_QBulk);
+    
+    // Wait for transfer completion
+    int timeout = 1000;
+    int status = 3; // We need to wait at least 10ms because some VM's (like qemu) clear the active bit first before actualy writing the data
+    while (status == 3 && (timeout > 0)) {
+        timeout -= 10;
+        System::pit->Sleep(10);
+        status = CheckTransferDone(td, i);
+    }
+    //Log(Info, "UHCI, Transfer finished with status -> %d", status);
+    RemoveQueue(queue, U_QUEUE_QBulk);
+    
+    if(status == 0) {
+        // copy the descriptor to the passed memory block
+        MemoryOperations::memcpy(bufPtr, returnBuf, len);
+    }
+    
+    // Free temporary buffer
+    KernelHeap::free(returnBuf);
+    // Free td's
+    KernelHeap::allignedFree(td);
+    // Free queue head
+    KernelHeap::allignedFree(queue);
+
+    return status == 0;
+}
+void UHCIController::InterruptIn(const bool lsDevice, const int devAddress, const int packetSize, const int endP, int interval, USBDriver* handler, const int len)
+{
+    // Create temporary buffer and clear it
+    uint32_t returnBufPhys;
+    uint8_t* returnBuf = (uint8_t*)KernelHeap::malloc(len, &returnBufPhys);
+    MemoryOperations::memset(returnBuf, 0, len); 
+
+    // Allocate Transfer Descriptors
+    uint32_t tdPhys;
+    u_transferDescriptor_t* td = (u_transferDescriptor_t*)KernelHeap::alignedMalloc(sizeof(u_transferDescriptor_t) * 10, 16, &tdPhys);
+    MemoryOperations::memset(td, 0, sizeof(u_transferDescriptor_t) * 10);
+
+    // Allocate queue head
+    uint32_t queuePhys;
+    uhci_queue_head_t* queue = (uhci_queue_head_t*)KernelHeap::alignedMalloc(sizeof(uhci_queue_head_t), 16, &queuePhys);
+    MemoryOperations::memset(queue, 0, sizeof(uhci_queue_head_t));
+    queue->horz_ptr = QUEUE_HEAD_T;
+    queue->vert_ptr = tdPhys;
+    
+    int i = 0;
+    int sz = len;
+    // Transfer Descriptors depending on size of request
+    while ((sz > 0) && (i<9)) {
+        td[i].link_ptr = (i > 0 ? (td[i-1].link_ptr & ~0xF) : tdPhys) + sizeof(u_transferDescriptor_t);
+        td[i].reply = (lsDevice ? (1<<26) : 0) | (3<<27) | (0x80 << 16);
+        int t = ((sz <= packetSize) ? sz : packetSize);
+        td[i].info = ((t-1)<<21) | (handler->device->endpoints[endP-1]->Toggle() ? (1<<19) : 0) | (endP<<15) | ((devAddress & 0x7F)<<8) | TOKEN_IN;
+        td[i].buff_ptr = returnBufPhys + (packetSize*i);
+        sz -= t;
+        i++;
+    }
+    td[i-1].reply |= (1<<24); // Enable IOC
+
+    // Create Interrupt transfer info
+    InterruptTransfer_t* transfer = new InterruptTransfer_t();
+    transfer->bufferLen = len;
+    transfer->bufferPointer = returnBuf;
+    transfer->handler = handler;
+    transfer->queueIndex = CalculateRequiredQueue(interval);
+
+    // Controller specific
+    transfer->td = td;
+    transfer->numTd = i;
+    transfer->tdPhys = tdPhys;
+    transfer->qh = queue;
+    transfer->endpoint = endP;
+
+    // Add transfer to list
+    this->interrupTransfers.push_back(transfer);
+    
+    // Instert queue into list
+    InsertQueue(queue, queuePhys, transfer->queueIndex);
+}
+uint32_t UHCIController::HandleInterrupt(uint32_t esp)
+{
+    uint16_t val = inportw(pciDevice->portBase + UHCI_STATUS);
+    uint16_t writeBack = 0;
+
+    if(val == 0) // Interrupt came from another UHCI device
+    {
+        //Log(Info, "Interrupt came from another UHCI device!");
+        return esp;
+    }
+
+    if (val & UHCI_STS_USBINT)
+    {
+        //Log(Info, "UHCI: Interrupt Transfer Complete!");
+        writeBack |= UHCI_STS_USBINT;
+
+        for(InterruptTransfer_t* transfer : this->interrupTransfers) {
+            uint8_t status = CheckTransferDone((u_transferDescriptor_t*)transfer->td, transfer->numTd);
+            //Log(Info, "UHCI, Transfer finished with status -> %d", status);
+            if(status != 3) // Done or error
+            {
+                // Check if it is a succesfull transfer, if not just clear the buffer
+                if(status == 1 || status == 2)
+                    MemoryOperations::memset(transfer->bufferPointer, 0, transfer->bufferLen);
+
+                if(status == 2) {
+                    Log(Warning, "[UHCI] Received NAK");
+                }
+                
+                bool rescedule = transfer->handler->HandleInterruptPacket(transfer);
+
+                if(rescedule) {
+                    MemoryOperations::memset(transfer->bufferPointer, 0, transfer->bufferLen);
+                    
+                    u_transferDescriptor_t* td = (u_transferDescriptor_t*)transfer->td;
+                    uhci_queue_head_t* qh = (uhci_queue_head_t*)transfer->qh;
+                    for(int i = 0; i < transfer->numTd; i++) {
+                        td[i].reply |= (0x80 << 16); // Mark all transfer descriptors as active again
+                        td[i].info = (td[i].info & ~(1 << 19)) | (transfer->handler->device->endpoints[transfer->endpoint-1]->Toggle() << 19);
+                    }
+
+                    // Queue head automaticaly points to next transfer descriptor on completion
+                    // So we need to set it to the initial position
+                    qh->vert_ptr = transfer->tdPhys;
+                }
+                else {
+                    RemoveQueue((uhci_queue_head_t*)transfer->qh, transfer->queueIndex);
+                    
+                    // Free temporary buffer
+                    if(transfer->bufferPointer) KernelHeap::free(transfer->bufferPointer);
+                    // Free td's
+                    if(transfer->td) KernelHeap::allignedFree(transfer->td);
+                    // Free queue head
+                    if(transfer->qh) KernelHeap::allignedFree(transfer->qh);
+
+                    this->interrupTransfers.Remove(transfer);
+                    delete transfer;
+                }
+            }
+        }
+    }
+
+    if (val & UHCI_STS_RESUME_DETECT)
+    {
+        Log(Info, "[UHCI] Resume Detect");
+        writeBack |= UHCI_STS_RESUME_DETECT;
+    }
+
+    if (val & UHCI_STS_HCHALTED)
+    {
+        Log(Error, "[UHCI] Host Controller Halted");
+        writeBack |= UHCI_STS_HCHALTED;
+    }
+
+    if (val & UHCI_STS_HC_PROCESS_ERROR)
+    {
+        Log(Error, "[UHCI] Host Controller Process Error");
+        writeBack |= UHCI_STS_HC_PROCESS_ERROR;
+    }
+
+    if (val & UHCI_STS_USB_ERROR)
+    {
+        Log(Error, "[UHCI] USB Error");
+        int num = inportw(pciDevice->portBase + UHCI_FRAME_NUM) & 0b1111111111;
+        Log(Info, "[UHCI] Frame Base: %x Frame Num: %d Frame: %x", inportl(pciDevice->portBase + UHCI_FRAME_BASE), num, this->frameList[num]);
+        
+        writeBack |= UHCI_STS_USB_ERROR;
+    }
+
+    if (val & UHCI_STS_HOST_SYSTEM_ERROR)
+    {
+        Log(Error, "[UHCI] Host System Error");
+        writeBack |= UHCI_STS_HOST_SYSTEM_ERROR;
+    }
+
+    outportw(pciDevice->portBase + UHCI_STATUS, writeBack);
+    return esp;
+}
+
+/////////
+// USB Controller Functions
+/////////
+
+bool UHCIController::BulkIn(USBDevice* device, void* retBuffer, int len, int endP)
+{
+    return BulkIn(device->uhciProperties.lowSpeedDevice, device->devAddress, device->endpoints[endP-1]->maxPacketSize, endP, retBuffer, len);
+}
+bool UHCIController::BulkOut(USBDevice* device, void* sendBuffer, int len, int endP)
+{
+    return BulkOut(device->uhciProperties.lowSpeedDevice, device->devAddress, device->endpoints[endP-1]->maxPacketSize, endP, sendBuffer, len);
+}
+
+bool UHCIController::ControlIn(USBDevice* device, void* target, const int len, const uint8_t requestType, const uint8_t request, const uint16_t valueHigh, const uint16_t valueLow, const uint16_t index)
+{
+    return ControlIn(target, device->uhciProperties.lowSpeedDevice, device->devAddress, device->uhciProperties.maxPacketSize, len, requestType, request, valueHigh, valueLow, index);
+}
+bool UHCIController::ControlOut(USBDevice* device, const int len, const uint8_t requestType, const uint8_t request, const uint16_t valueHigh, const uint16_t valueLow, const uint16_t index)
+{
+    return ControlOut(device->uhciProperties.lowSpeedDevice, device->devAddress, device->uhciProperties.maxPacketSize, len, requestType, request, valueHigh, valueLow, index);
+}
+
+void UHCIController::InterruptIn(USBDevice* device, int len, int endP)
+{
+    InterruptIn(device->uhciProperties.lowSpeedDevice, device->devAddress, device->endpoints[endP-1]->maxPacketSize, endP, device->endpoints[endP-1]->interval, device->driver, len);
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/usb/controllers/xhci.cpp b/kernelz/src/system/drivers/usb/controllers/xhci.cpp
new file mode 100644
index 0000000..85f84f7
--- /dev/null
+++ b/kernelz/src/system/drivers/usb/controllers/xhci.cpp
@@ -0,0 +1,693 @@
+#ifdef XHCI_SUPPORTED
+
+#include <system/drivers/usb/controllers/xhci.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+XHCIController::XHCIController(PCIDevice* device)
+: USBController(xHCI), Driver("XHCI USB Controller", "Controller for a XHCI device"),
+InterruptHandler(IDT_INTERRUPT_OFFSET + device->interrupt)
+{
+    this->pciDevice = device;
+    MemoryOperations::memset(this->port_info, 0, 16 * sizeof(struct S_XHCI_PORT_INFO));
+}
+
+bool XHCIController::Initialize()
+{
+    BaseAddressRegister BAR0 = System::pci->GetBaseAddressRegister(pciDevice->bus, pciDevice->device, pciDevice->function, 0);
+    if(BAR0.type == InputOutput)
+        return false; //We only want memory mapped controllers
+    
+    //Save Register memory base
+    this->regBase = BAR0.address;
+
+    //Enable BUS Mastering
+    System::pci->Write(pciDevice->bus, pciDevice->device, pciDevice->function, 0x04, 0x0006);
+
+    //Map memory so that we can use it
+    VirtualMemoryManager::mapVirtualToPhysical((void*)this->regBase, (void*)this->regBase, pageRoundUp(BAR0.size), true, true);
+
+    // Write to the FLADJ register incase the BIOS didn't
+    // At the time of this writing, there wasn't a BIOS that supported xHCI yet :-)
+    System::pci->Write(pciDevice->bus, pciDevice->device, pciDevice->function, 0x61, 0x20);
+
+    //Read the version register (just a small safety check)
+    if (readMemReg(regBase + xHC_CAPS_IVersion) < 0x95)
+        return false;
+  
+    //If it is a Panther Point device, make sure sockets are xHCI controlled.
+    if ((System::pci->Read(pciDevice->bus, pciDevice->device, pciDevice->function, 0) == 0x8086) && 
+        (System::pci->Read(pciDevice->bus, pciDevice->device, pciDevice->function, 2) == 0x1E31) && 
+        (System::pci->Read(pciDevice->bus, pciDevice->device, pciDevice->function, 8) == 4)) {
+        System::pci->Write(pciDevice->bus, pciDevice->device, pciDevice->function, 0xD8, 0xFFFFFFFF);
+        System::pci->Write(pciDevice->bus, pciDevice->device, pciDevice->function, 0xD0, 0xFFFFFFFF);
+    }
+
+    //Read Register offset
+    opRegOffset = (uint8_t) readMemReg(regBase + xHC_CAPS_CapLength);
+
+    //Set Run/Stop bit to clear
+    WriteOpReg(xHC_OPS_USBCommand, ReadOpReg(xHC_OPS_USBCommand) & ~(1<<0));
+
+    //Wait for HcHalted bit to be set.
+    uint32_t timeout = 20;
+    while (!((ReadOpReg(xHC_OPS_USBStatus) & (1<<0)))) {
+        if(--timeout == 0) {
+            Log(Error, "xHCI Did not halt within 20 ms.");
+            return false;
+        }
+        System::pit->Sleep(1);
+    }
+
+    //Set hcreset bit
+    //Wait for hcreset bit and CtrlNotReady to clear
+    timeout = 500;
+    WriteOpReg(xHC_OPS_USBCommand, (1<<1));
+    while ((ReadOpReg(xHC_OPS_USBCommand) & (1<<1)) || (ReadOpReg(xHC_OPS_USBCommand) & (1<<11))) {
+        if (--timeout == 0) {
+            Log(Error, "xHCI Did not reset within 500 ms.");
+            return false;
+        }
+        
+        System::pit->Sleep(1);
+    }
+    System::pit->Sleep(USB_TRSTRCY);
+
+    //Read HCCParams1 register and store its value, now we can read 64 bit values
+    hccparams1 = readMemReg(regBase + xHC_CAPS_HCCParams1);
+    hccparams2 = readMemReg(regBase + xHC_CAPS_HCCParams2);
+    hcsparams1 = readMemReg(regBase + xHC_CAPS_HCSParams1);
+    hcsparams2 = readMemReg(regBase + xHC_CAPS_HCSParams2);
+    rts_offset = readMemReg(regBase + xHC_CAPS_RTSOFF) & ~0x1F;  // bits 4:0 are reserved
+    db_offset = readMemReg(regBase + xHC_CAPS_DBOFF) & ~0x03;    // bits 1:0 are reserved
+    context_size = (hccparams1 & (1<<2)) ? 64 : 32;
+    uint32_t xECP = (((hccparams1 & 0xFFFF0000) >> 16) * 4);
+
+    //Check for default values of the operational registers
+    if(ReadOpReg(xHC_OPS_USBCommand) != 0)
+        return false;
+    if(ReadOpReg(xHC_OPS_USBDnctrl) != 0)
+        return false;
+    if(ReadOpReg64(xHC_OPS_USBCrcr) != 0)
+        return false;
+    if(ReadOpReg64(xHC_OPS_USBDcbaap) != 0)
+        return false;
+    if(ReadOpReg(xHC_OPS_USBConfig) != 0)
+        return false;
+
+    // Turn off legacy support for Keyboard and Mice
+    if (!StopLegacy(xECP)) {
+        Log(Error, "[xHCI] BIOS did not release Legacy support...");
+        return false;
+    }
+
+    //Add ourself to known controllers
+    System::usbManager->AddController(this);
+
+    return true;
+}
+void XHCIController::Setup()
+{
+    //Get num_ports from XHCI's HCSPARAMS1 register
+	numPorts = (uint8_t) ((hcsparams1 & 0xFF000000) >> 24);
+    Log(Info, "[xHCI] Found %d (virtual) root hub ports.", numPorts);
+
+    // Get protocol of each port
+    //  Each physical port will have a USB3 and a USB2 PortSC register set.
+    //  Most likely a controller will only have one protocol item for each version.
+    //   i.e.:  One for USB 3 and one for USB 2, they will not be fragmented.
+    //  However, it doesn't state anywhere that it can't be fragmented, so the below
+    //   code allows for fragmented protocol items
+    uint32_t ext_caps_off = (((hccparams1 & 0xFFFF0000) >> 16) * 4);
+    uint32_t next = ext_caps_off;
+    uint16_t flags;
+    int cnt, offset, ports_usb2 = 0, ports_usb3 = 0;
+    
+    // find the USB 2.0 ports and mark the port_info byte as USB2 if found
+    while (next) {
+        next = GetProtoOffset(next, 2, &offset, &cnt, &flags);
+        if (cnt) {
+            for (int i = 0; i < cnt; i++) {
+                port_info[offset + i].offset = ports_usb2++;
+                port_info[offset + i].flags = xHCI_PROTO_USB2;
+                if (flags & 2)
+                    port_info[offset + i].flags |= xHCI_PROTO_HSO;
+            }
+        }
+    }
+    
+    // find the USB 3.0 ports and mark the port_info byte as USB3 if found
+    next = ext_caps_off;
+    while (next) {
+        next = GetProtoOffset(next, 3, &offset, &cnt, &flags);
+        if (cnt) {
+            for (int i = 0; i < cnt; i++) {
+                port_info[offset + i].offset = ports_usb3++;
+                port_info[offset + i].flags = xHCI_PROTO_USB3;
+            }
+        }
+    }
+    
+    // pair up each USB3 port with it's companion USB2 port
+    for (int i = 0; i < numPorts; i++) {
+        for (int k = 0; k < numPorts; k++) {
+            if ((port_info[k].offset == port_info[i].offset) && ((port_info[k].flags & xHCI_PROTO_INFO) != (port_info[i].flags & xHCI_PROTO_INFO))) {
+                port_info[i].other_port_num = k;
+                port_info[i].flags |= xHCI_PROTO_HAS_PAIR;
+                port_info[k].other_port_num = i;
+                port_info[k].flags |= xHCI_PROTO_HAS_PAIR;
+            }
+        }
+    }
+    
+    // mark all USB3 ports and any USB2 only ports as active, deactivating any USB2 ports that have a USB3 companion
+    for (int i = 0; i < numPorts; i++) {
+        if (xHCI_IS_USB3_PORT(i) || (xHCI_IS_USB2_PORT(i) && !xHCI_HAS_PAIR(i)))
+            port_info[i].flags |= xHCI_PROTO_ACTIVE;
+    }
+
+    pageSize = (ReadOpReg(xHC_OPS_USBPageSize) & 0xFFFF) << 12;
+    Log(Info, "[xHCI] Page Size = %d", pageSize);
+    const uint32_t max_slots = hcsparams1 & 0xFF;
+    
+    //Allocate Device Context Area
+    devContextAreaVirt = (uint32_t)KernelHeap::alignedMalloc(2048, pageSize, &devContextAreaPhys);
+    MemoryOperations::memset((void*)devContextAreaVirt, 0, 2048); //And set it to zero's
+
+    //Write physical address of Context Data Structure
+    WriteOpReg64(xHC_OPS_USBDcbaap, devContextAreaPhys);
+
+    //Allocate Command Ring
+    commandRingVirt = CreateRing(CMND_RING_TRBS);
+    commandRingPhys = (uint32_t)VirtualMemoryManager::virtualToPhysical((void*)commandRingVirt);
+    commandTrbPhys = commandRingPhys;
+    commandTrbVirt = commandRingVirt;
+    commandTrbCycle = TRB_CYCLE_ON;
+
+    //Write physical address to Ring Control Register
+    WriteOpReg64(xHC_OPS_USBCrcr, commandRingPhys | TRB_CYCLE_ON);
+
+    //Let the controller know the amount of slots we support
+    WriteOpReg(xHC_OPS_USBConfig, max_slots);
+
+    //Set bit in Device Notification Control
+    WriteOpReg(xHC_OPS_USBDnctrl, (1<<1));
+
+    int maxEventSegments = (1 << ((hcsparams2 & 0x000000F0) >> 4));
+    int maxInterrupters = ((hcsparams1 & 0x0007FF00) >> 8);
+    uint32_t eventRingAddr = CreateEventRing(4096, &curEventRingAddrVirt);
+    curEventRingAddrPhys = (uint32_t)VirtualMemoryManager::virtualToPhysical((void*)curEventRingAddrVirt);
+    curEventRingCycle = 1;
+    
+    //Write the registers
+    writePrimaryIntr(xHC_INTERRUPTER_IMAN, (1 << 1) | (1 << 0));  // enable bit & clear pending bit
+    writePrimaryIntr(xHC_INTERRUPTER_IMOD, 0);                    // disable throttling
+    writePrimaryIntr(xHC_INTERRUPTER_TAB_SIZE, 1);                // count of segments (table size)
+    writePrimaryIntr64(xHC_INTERRUPTER_DEQUEUE, (curEventRingAddrPhys | (1 << 3)));
+    writePrimaryIntr64(xHC_INTERRUPTER_ADDRESS, (uint32_t)VirtualMemoryManager::virtualToPhysical((void*)eventRingAddr));
+
+    //Clear the status register bits
+    WriteOpReg(xHC_OPS_USBStatus, (1<<10) | (1<<4) | (1<<3) | (1<<2));
+
+    //Set and start the Host Controllers schedule
+    WriteOpReg(xHC_OPS_USBCommand, (1<<3) | (1<<2) | (1<<0));
+    System::pit->Sleep(100);
+
+    // loop through the ports, starting with the USB3 ports
+    for (int i = 0; i < numPorts; i++) {
+        if (xHCI_IS_USB3_PORT(i) && xHCI_IS_ACTIVE(i)) {
+            // power and reset the port
+            if (ResetPort(i)) {
+                // if the reset was good, get the descriptor
+                // if the reset was bad, the reset routine will mark this port as inactive,
+                //  and mark the USB2 port as active.
+                Log(Info, "Getting USB3 Descriptor of port %d", i);
+                GetDescriptor(i);
+            }
+        }
+    }
+    
+    // now the USB2 ports
+    for (int i = 0; i < numPorts; i++) {
+        if (xHCI_IS_USB2_PORT(i) && xHCI_IS_ACTIVE(i)) {
+            // power and reset the port
+            if (ResetPort(i)) {
+                // if the reset was good, get the descriptor
+                Log(Info, "Getting USB2 Descriptor of port %d", i);
+                GetDescriptor(i);
+            }
+        }
+    }
+}
+uint32_t XHCIController::HandleInterrupt(uint32_t esp)
+{ 
+    Log(Info, "[xHCI] Interrupt");
+
+    // acknowledge interrupt (status register first)
+    // clear the status register bits
+    WriteOpReg(xHC_OPS_USBStatus, ReadOpReg(xHC_OPS_USBStatus));
+    
+    const uint32_t dword = readPrimaryIntr(xHC_INTERRUPTER_IMAN);
+    if ((dword & 3) == 3) {
+        // acknowledge the interrupter's IP bit being set
+        writePrimaryIntr(xHC_INTERRUPTER_IMAN, dword | 3);
+        
+        // do the work
+        struct xHCI_TRB event, org;
+        uint32_t org_address;
+        uint32_t last_addr = curEventRingAddrVirt;
+        GetTrb(&event, curEventRingAddrVirt);
+        
+        while ((event.command & 1) == curEventRingAddrPhys) {
+            if ((event.command & (1<<2)) == 0) {
+                switch (TRB_GET_COMP_CODE(event.status)) {
+                case TRB_SUCCESS:
+                    switch (TRB_GET_TYPE(event.command)) {
+                    // Command Completion Event
+                    case COMMAND_COMPLETION:
+                        org_address = (uint32_t) event.param;
+                        GetTrb(&org, org_address);
+                        switch (TRB_GET_TYPE(org.command)) {
+                            case ENABLE_SLOT:
+                                org.command &= 0x00FFFFFF;
+                                org.command |= (event.command & 0xFF000000); // return slot ID (1 based)
+                                org.status = event.status;
+                                break;
+                                
+                            default:
+                                org.status = event.status;
+                                break;
+                        }
+                        
+                        // mark the command as done
+                        org.status |= XHCI_IRQ_DONE;
+                        // and write it back
+                        SetTrb(&org, org_address);
+                        break;
+                    }
+                    break;
+                }
+                
+                // mark the TRB as done
+            } else {
+                switch (TRB_GET_TYPE(event.command)) {
+                    case TRANS_EVENT: // If SPD was encountered in this TD, comp_code will be SPD, else it should be SUCCESS (specs 4.10.1.1)
+                        *(uint32_t*)((uint32_t) event.param) = (event.status | XHCI_IRQ_DONE); // return code + bytes *not* transferred
+                        break;
+                        
+                    default:
+                        ;
+                }
+            }
+            
+            // get next one
+            last_addr = curEventRingAddrVirt;
+            curEventRingAddrVirt += sizeof(struct xHCI_TRB);
+            curEventRingAddrPhys += sizeof(struct xHCI_TRB);
+            GetTrb(&event, curEventRingAddrVirt);
+        }
+        
+        // advance the dequeue pointer (clearing the busy bit)
+        writePrimaryIntr64(xHC_INTERRUPTER_DEQUEUE, last_addr | (1<<3));
+    }
+    return esp;
+}
+
+bool XHCIController::ResetPort(const int port) {
+    bool ret = false;
+    uint32_t HCPortStatusOff = xHC_OPS_USBPortSt + (port * 16);
+    uint32_t val;
+    
+    // power the port?
+    if ((ReadOpReg(HCPortStatusOff + xHC_Port_PORTSC) & (1<<9)) == 0) {
+        WriteOpReg(HCPortStatusOff + xHC_Port_PORTSC, (1<<9));
+        System::pit->Sleep(20);
+        if ((ReadOpReg(HCPortStatusOff + xHC_Port_PORTSC) & (1<<9)) == 0)
+            return false;  // return bad reset.
+    }
+    
+    // we need to make sure that the status change bits are clear
+    WriteOpReg(HCPortStatusOff + xHC_Port_PORTSC, (1<<9) | xHC_PortUSB_CHANGE_BITS);
+    
+    // set bit 4 (USB2) or 31 (USB3) to reset the port
+    if (xHCI_IS_USB3_PORT(port))
+        WriteOpReg(HCPortStatusOff + xHC_Port_PORTSC, (1<<9) | (1<<31));
+    else
+        WriteOpReg(HCPortStatusOff + xHC_Port_PORTSC, (1<<9) | (1<<4));
+    
+    // wait for bit 21 to set
+    int timeout = 500;
+    while (timeout) {
+        val = ReadOpReg(HCPortStatusOff + xHC_Port_PORTSC);
+        if (val & (1<<21))
+            break;
+        timeout--;
+        System::pit->Sleep(1);
+    }
+    
+    // if we didn't time out
+    if (timeout > 0) {
+        // reset recovery time
+        System::pit->Sleep(USB_TRHRSI);
+        
+        // if after the reset, the enable bit is non zero, there was a successful reset/enable
+        val = ReadOpReg(HCPortStatusOff + xHC_Port_PORTSC);
+        
+        if (val & (1<<1)) {
+            // clear the status change bit(s)
+            WriteOpReg(HCPortStatusOff + xHC_Port_PORTSC, (1<<9) | xHC_PortUSB_CHANGE_BITS);
+            
+            // success
+            ret = true;
+        }
+    } else
+        Log(Warning, "[xHCI] Port Reset Timed out port=%d", port);
+    
+    // if we have a successful USB2 reset, we need to make sure this port is marked active,
+    //  and if it has a paired port, it is marked inactive
+    if ((ret == true) && xHCI_IS_USB2_PORT(port)) {
+        port_info[port].flags |= xHCI_PROTO_ACTIVE;
+        if (port_info[port].flags & xHCI_PROTO_HAS_PAIR)
+            port_info[port_info[port].other_port_num].flags &= ~xHCI_PROTO_ACTIVE;
+    }
+    
+    // if error resetting USB3 protocol, deactivate this port and activate the paired USB2 port.
+    //  it will be paired since all USB3 ports must be USB2 compatible.
+    if (!ret && xHCI_IS_USB3_PORT(port)) {
+        port_info[port].flags &= ~xHCI_PROTO_ACTIVE;
+        port_info[port_info[port].other_port_num].flags |= xHCI_PROTO_ACTIVE;
+    }
+    
+    return ret;
+}
+
+bool XHCIController::StopLegacy(uint32_t xECP) {
+    if(xECP != 0)
+    {
+        uint8_t xECP_id = 0;
+
+        while (xECP) // 00h indicates end of the ext. cap. list.
+        {
+            xECP_id = *(uint8_t*)(regBase + xECP);
+            if (xECP_id == 1)
+                break;
+
+            uint8_t offset = *(uint8_t*)(regBase + xECP + 1);
+            if (!offset)
+                xECP = 0;
+            else
+                xECP += offset << 2;
+        }
+        uint16_t BIOSownedSemaphore = xECP + 2; // R/W - only Bit 16 (Bit 23:17 Reserved, must be set to zero)
+        uint16_t OSownedSemaphore = xECP + 3;   // R/W - only Bit 24 (Bit 31:25 Reserved, must be set to zero)
+        uint16_t USBLEGCTLSTS = xECP + 4;       // USB Legacy Support Control/Status
+
+        // Legacy-Support-EC found? BIOS-Semaphore set?
+        if (xECP_id == 1 && *(uint8_t*)(regBase + BIOSownedSemaphore) & 0x01)
+        {
+            //Set Semaphore
+            *(uint8_t*)(regBase + OSownedSemaphore) = 0x01;
+
+            uint32_t timeOut = 250;
+            while(timeOut && !((*(uint8_t*)(regBase + BIOSownedSemaphore) & 0x01) == 0)) {
+                timeOut--;
+                System::pit->Sleep(1);
+            }
+            if(timeOut == 0) {
+                Log(Error, "[xHCI] BIOS-Semaphore still set.");
+                return false;
+            }
+
+            timeOut = 250;
+            while(timeOut && !((*(uint8_t*)(regBase + OSownedSemaphore) & 0x01) != 0)) {
+                timeOut--;
+                System::pit->Sleep(1);
+            }
+            if(timeOut == 0) {
+                Log(Error, "[xHCI] OS-Semaphore still cleared.");
+                return false;
+            }
+
+            // USB SMI Enable R/W. 0=Default. The OS tries to set SMI to disabled in case that BIOS bit stays at one.
+            *(uint32_t*)(regBase + USBLEGCTLSTS) = 0x00000000; // USB SMI disabled
+            return true;
+        }
+        else
+            Log(Info, "[xHCI] BIOS did not own the xHCI. No action needed.");
+    }
+    return true;
+}
+
+uint32_t XHCIController::GetProtoOffset(uint32_t list_off, const int version, int* offset, int* count, uint16_t* flags) {
+    uint32_t next;
+    *count = 0;  // mark that there isn't any to begin with
+
+    do {
+        // calculate next item position
+        uint8_t item_next = *(uint8_t*)(regBase + list_off + 1);
+        next = (item_next) ? (list_off + (item_next * 4)) : 0;
+        
+        // is this a protocol item and if so, is it the version we are looking for?
+        if ((*(uint8_t*)(regBase + list_off + 0) == xHC_xECP_ID_PROTO) && (*(uint8_t*)(regBase + list_off + 3) == version)) {
+            *offset = *(uint8_t*)(regBase + list_off + 8) - 1;  // make it zero based
+            *count = *(uint8_t*)(regBase + list_off + 9);
+            *flags = *(uint16_t*)(regBase + list_off + 10) & 0x0FFF;
+            return next;
+        }
+        
+        // point to next item
+        list_off = next;
+    } while (list_off);
+    
+    // return no more
+    return 0;
+}
+
+uint32_t XHCIController::CreateRing(const int trbs) {
+    const uint32_t addr = (uint32_t)KernelHeap::alignedMalloc(trbs * sizeof(struct xHCI_TRB), 0x10000);
+    MemoryOperations::memset((void*)addr, 0, trbs * sizeof(struct xHCI_TRB));
+    
+    // make the last one a link TRB to point to the first one
+    uint32_t pos = addr + ((trbs - 1) * sizeof(struct xHCI_TRB));
+    *(uint64_t*)(pos + 0) = addr;           // param
+    *(uint32_t*)(pos +  8) = (0 << 22) | 0;  // status
+    *(uint32_t*)(pos + 12) = TRB_LINK_CMND;  // command
+    
+    return addr;
+}
+
+uint32_t XHCIController::CreateEventRing(const int trbs, uint32_t* ret_addr) {
+    // Please note that 'trbs' should be <= 4096 or you will need to make multiple segments
+    // I only use one here.
+    const uint32_t table_addr = (uint32_t)KernelHeap::alignedMalloc(64, 64);  // min 16 bytes on a 64 byte alignment, no boundary requirements
+    MemoryOperations::memset((void*)table_addr, 0, 64);
+    const uint32_t addr = (uint32_t)KernelHeap::alignedMalloc((trbs * sizeof(struct xHCI_TRB)), 0x10000); // 16 * trbs, 64 byte alignment, 64k boundary
+    MemoryOperations::memset((void*)addr, 0, trbs * sizeof(struct xHCI_TRB));
+
+    // we only use 1 segment for this example
+    *(uint64_t*)(table_addr) = addr;
+    *(uint32_t*)(table_addr + 8) = trbs;  // count of TRB's
+    *(uint32_t*)(table_addr + 12) = 0;
+    
+    *ret_addr = addr;
+    return table_addr;
+}
+bool XHCIController::GetDescriptor(const int port) {
+    uint32_t dword;
+    uint32_t HCPortStatusOff = xHC_OPS_USBPortSt + (port * 16);
+    struct DEVICE_DESC dev_desc;
+    
+    // port has been reset, and is ready to be used
+    // we have a port that has a device attached and is ready for data transfer.
+    // so lets create our stack and send it along.
+    dword = ReadOpReg(HCPortStatusOff + xHC_Port_PORTSC);
+    int speed = ((dword & (0xF << 10)) >> 10); // FULL = 1, LOW = 2, HI = 3, SS = 4
+    /*
+    * Some devices will only send the first 8 bytes of the device descriptor
+    *  while in the default state.  We must request the first 8 bytes, then reset
+    *  the port, set address, then request all 18 bytes.
+    */
+    
+    // send the initialize and enable slot command
+    int max_packet;
+    
+    // send the command and wait for it to return
+    struct xHCI_TRB trb;
+    trb.param = 0;
+    trb.status = 0;
+    trb.command = TRB_SET_STYPE(0) | TRB_SET_TYPE(ENABLE_SLOT);
+    if (SendCommand(&trb, true))
+        return false;
+    
+    // once we get the interrupt, we can get the slot_id
+    uint32_t slot_id = TRB_GET_SLOT(trb.command);
+    
+    // if the slot id > 0, we have a valid slot id
+    if (slot_id > 0) {
+        // calculate initial Max Packet Size (xHCI requires this or will not set address)
+        switch (speed) {
+            case xHCI_SPEED_LOW:
+                max_packet = 8;
+                break;
+            case xHCI_SPEED_FULL:
+            case xHCI_SPEED_HI:
+                max_packet = 64;
+                break;
+            case xHCI_SPEED_SUPER:
+                max_packet = 512;
+                break;
+        }
+        /*
+        // initialize the device/slot context
+        uint32_t slot_addr = xhci_initialize_slot(slot_id, port, speed, max_packet);
+        // send the address_device command
+        xhci_set_address(slot_addr, slot_id, true);
+        // now send the "get_descriptor" packet (get 8 bytes)
+        xhci_control_in(&dev_desc, 8, slot_id, max_packet);
+        
+        // TODO: if the dev_desc.max_packet was different than what we have as max_packet,
+        //       you would need to change it here and in the slot context by doing a
+        //       evaluate_slot_context call.
+        
+        // reset the port
+        ResetPort(port);
+        
+        // send set_address_command again
+        xhci_set_address(slot_addr, slot_id, false);
+        
+        // get the whole packet.
+        xhci_control_in(&dev_desc, 18, slot_id, max_packet);
+        
+        // print the descriptor
+        Log(Info, "Found Device Descriptor:"
+                "\n                 len: %d"
+                "\n                type: %d"
+                "\n             version: %b.%b"
+                "\n               class: %d"
+                "\n            subclass: %d"
+                "\n            protocol: %d"
+                "\n     max packet size: %d"
+                "\n           vendor id: %w"
+                "\n          product id: %w"
+                "\n         release ver: %d%d.%d%d"
+                "\n   manufacture index: %d (index to a string)"
+                "\n       product index: %d"
+                "\n        serial index: %d"
+                "\n   number of configs: %d",
+                dev_desc.len, dev_desc.type, dev_desc.usb_ver >> 8, dev_desc.usb_ver & 0xFF, dev_desc._class, dev_desc.subclass, 
+                dev_desc.protocol, dev_desc.max_packet_size, dev_desc.vendorid, dev_desc.productid, 
+                (dev_desc.device_rel & 0xF000) >> 12, (dev_desc.device_rel & 0x0F00) >> 8,
+                (dev_desc.device_rel & 0x00F0) >> 4,  (dev_desc.device_rel & 0x000F) >> 0,
+                dev_desc.manuf_indx, dev_desc.prod_indx, dev_desc.serial_indx, dev_desc.configs);
+        */
+    }
+    
+    return true;
+}
+// inserts a command into the command ring at the current command trb location
+// returns TRUE if timed out
+bool XHCIController::SendCommand(struct xHCI_TRB* trb, const bool ring_it) {
+    // we monitor bit 31 in the command dword
+    uint32_t org_trb_addr = commandTrbVirt;
+    
+    // must write param and status fields to the ring before the command field.
+    *(uint64_t*)(commandTrbVirt) = trb->param;                       // param
+    *(uint32_t*)(commandTrbVirt +  8) = trb->status;                   // status
+    *(uint32_t*)(commandTrbVirt + 12) = trb->command | commandTrbCycle; // command
+    
+    commandTrbVirt += sizeof(struct xHCI_TRB);
+    commandTrbPhys += sizeof(struct xHCI_TRB);
+    
+    // if the next trb is the link trb, then move to the first TRB
+    // ** for this example, we assume that we are moving to the first TRB in the command ring **
+    uint32_t cmnd = *(uint32_t*)(commandTrbVirt + 12);
+    if (TRB_GET_TYPE(cmnd) == LINK) {
+        *(uint32_t*)(commandTrbVirt + 12, (cmnd & ~1) | commandTrbCycle);
+        commandTrbVirt = commandRingVirt;
+        commandTrbPhys = commandRingPhys;
+        commandTrbCycle ^= 1;
+    }
+    
+    if (ring_it) {
+        WriteDoorbell(0, 0);   // ring the doorbell
+        
+        // Now wait for the interrupt to happen
+        // We use bit 31 of the command dword since it is reserved
+        int timer = 2000;
+        while (timer && (*(uint32_t*)(org_trb_addr + 8) & XHCI_IRQ_DONE) == 0) {
+            System::pit->Sleep(1);
+            timer--;
+        }
+        if (timer == 0) {
+            Log(Error, "[xHCI] Command Interrupt wait timed out.");
+            return true;
+        } else {
+            GetTrb(trb, org_trb_addr);  // retrieve the trb data
+            trb->status &= ~XHCI_IRQ_DONE;    // clear off the done bit
+        }
+    }
+    
+    return false;
+}
+void XHCIController::GetTrb(struct xHCI_TRB* trb, const uint32_t address) {
+    trb->param =   *(uint64_t*)(address);
+    trb->status =  *(uint32_t*)(address +  8);
+    trb->command = *(uint32_t*)(address + 12);
+}
+
+void XHCIController::SetTrb(struct xHCI_TRB* trb, const uint32_t address) {
+    *(uint64_t*)(address) = trb->param;
+    *(uint32_t*)(address +  8) = trb->status;
+    *(uint32_t*)(address + 12) = trb->command;
+}
+
+void XHCIController::WriteOpReg(const uint32_t offset, const uint32_t val) {
+    writeMemReg(regBase + opRegOffset + offset, val);
+}
+
+void XHCIController::WriteOpReg64(const uint32_t offset, const uint64_t val) {
+    writeMemReg(regBase + opRegOffset + offset, val);
+    if (hccparams1 & 1)
+        writeMemReg(regBase + opRegOffset + offset + 4, (uint32_t) (val >> 32));
+}
+
+uint32_t XHCIController::ReadOpReg(const uint32_t offset) {
+    return readMemReg(regBase + opRegOffset + offset);
+}
+
+uint64_t XHCIController::ReadOpReg64(const uint32_t offset) {
+    if (hccparams1 & 1)
+        return (readMemReg(regBase + opRegOffset + offset) | ((uint64_t) readMemReg(regBase + opRegOffset + offset + 4) << 32));
+    else
+        return readMemReg(regBase + opRegOffset + offset);
+}
+
+void XHCIController::WriteDoorbell(const uint32_t slot_id, const uint32_t val) {
+    *(uint32_t*)(regBase + db_offset + (slot_id * sizeof(uint32_t))) = val; // ring a doorbell
+}
+void XHCIController::writePrimaryIntr(const uint32_t offset, const uint32_t val) {
+    *(uint32_t*)(regBase + (rts_offset + 0x20) + offset) = val;
+}
+
+void XHCIController::writePrimaryIntr64(const uint32_t offset, const uint64_t val) {
+    *(uint32_t*)(regBase + (rts_offset + 0x20) + offset) = val;
+    if (hccparams1 & 1)
+        *(uint32_t*)(regBase + (rts_offset + 0x20) + offset + 4) = (uint32_t)(val >> 32);
+}
+
+uint32_t XHCIController::readPrimaryIntr(const uint32_t offset) {
+    return *(uint32_t*)(regBase + (rts_offset + 0x20) + offset);
+}
+
+uint64_t XHCIController::readPrimaryIntr64(const uint32_t offset) {
+    if (hccparams1 & 1)
+        return (*(uint32_t*)(regBase + (rts_offset + 0x20) + offset) |((uint64_t) *(uint32_t*)(regBase + (rts_offset + 0x20) + offset + 4) << 32));
+    else
+        return *(uint32_t*)(regBase + (rts_offset + 0x20) + offset);
+}
+#endif
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/usb/mass_storage.cpp b/kernelz/src/system/drivers/usb/mass_storage.cpp
new file mode 100644
index 0000000..689eb35
--- /dev/null
+++ b/kernelz/src/system/drivers/usb/mass_storage.cpp
@@ -0,0 +1,406 @@
+#include <system/drivers/usb/mass_storage.h>
+#include <system/drivers/usb/usbdefs.h>
+#include <system/log.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+// Create new driver for a MSD
+USBMassStorageDriver::USBMassStorageDriver(USBDevice* dev)
+: USBDriver(dev, "USB Mass Storage"), Disk(0, 0, USBDisk, 0, 0, 0)
+{ }
+
+// Called when mass storage device is plugged into system
+bool USBMassStorageDriver::Initialize()
+{
+    for(USBEndpoint* ep : this->device->endpoints) {
+        if(ep->type == EndpointType::Bulk) { // Bulk Endpoint
+            if(ep->dir == EndpointDirection::In) //In
+                this->bulkInEP = ep->endpointNumber;
+            else //Out
+                this->bulkOutEP = ep->endpointNumber;
+        }
+    }
+
+    this->maxLUN = this->device->controller->GetMaxLuns(this->device);
+    if(this->maxLUN == 0xFF)
+        this->maxLUN = 0; // Some devices return 0xFF while they mean 0
+    
+    Log(Info, "MSD: Bulk in=%d Bulk Out=%d LUNS=%d", this->bulkInEP, this->bulkOutEP, this->maxLUN + 1);
+
+    ///////////////
+    // Test Unit Ready
+    ///////////////
+    CommandBlockWrapper checkReadyCMD = SCSIPrepareCommandBlock(SCSI_TEST_UNIT_READY, 0);
+    for(int i = 0; i < 3; i++) {
+        if(!SCSIRequest(&checkReadyCMD, 0, 0)) {
+            Log(Warning, "MSD Device not ready yet");
+            System::pit->Sleep(100);
+        }
+        else {
+            break;
+        }
+    }
+
+
+    ///////////////
+    // Inquiry
+    ///////////////
+    CommandBlockWrapper inquiryCMD = SCSIPrepareCommandBlock(SCSI_INQUIRY, sizeof(InquiryReturnBlock));
+    InquiryReturnBlock inquiryRet;
+    if(SCSIRequest(&inquiryCMD, (uint8_t*)&inquiryRet, sizeof(InquiryReturnBlock))) {
+        char vendorInfo[8 + 1]; vendorInfo[8] = '\0'; MemoryOperations::memcpy(vendorInfo, inquiryRet.vendorInformation, 8);
+        char productInfo[16 + 1]; productInfo[16] = '\0'; MemoryOperations::memcpy(productInfo, inquiryRet.productIdentification, 16);
+        char revision[4 + 1]; revision[4] = '\0'; MemoryOperations::memcpy(revision, inquiryRet.productRevisionLevel, 4);
+
+        Log(Info, "MSD Vendor: %s Product: %s Revision: %s", vendorInfo, productInfo, revision);
+
+        // Check if it is a Direct Access Block Device or CD-ROM/DVD device
+        if(inquiryRet.peripheralDeviceType != 0x00 && inquiryRet.peripheralDeviceType != 0x05)
+            return false;
+        
+        // Check if LUN is connected to something
+        if(inquiryRet.peripheralQualifier != 0)
+            return false;
+
+        // Response Data Format should be 0x01 or 0x02
+        if(inquiryRet.responseDataFormat != 0x01 && inquiryRet.responseDataFormat != 0x02)
+            return false;
+
+        // Create Identifier
+        int strLen = 16;
+        while(productInfo[strLen - 1] == ' ' && strLen > 1)
+            strLen--;
+        this->identifier = new char[strLen + 1];
+        MemoryOperations::memcpy(this->identifier, productInfo, strLen);
+        this->identifier[strLen] = '\0';
+    }
+    else {
+        return false;
+    }
+
+    ///////////////
+    // Read Format Capacities
+    // We try this command 3 times since it will stall at least once
+    ///////////////
+
+    /*
+    CommandBlockWrapper formatCapCMD = SCSIPrepareCommandBlock(SCSI_READ_FORMAT_CAPACITIES, 0xFC);
+    uint8_t formatCapRet[0xFC];
+    MemoryOperations::memset(formatCapRet, 0, 0xFC);
+
+    for(int i = 0; i < 3; i++) 
+    {
+        if(SCSIRequest(&formatCapCMD, formatCapRet, 0xFC)) {
+            CapacityListHeader* header = (CapacityListHeader*)formatCapRet;
+            if(header->listLength > 0) {
+                CapacityDescriptor* capDesc = (CapacityDescriptor*)(formatCapRet + 4);
+                Log(Info, "MSD Read Format Capacities results: %d * %d = %x", capDesc->numberOfBlocks, capDesc->blockLength, capDesc->blockLength * capDesc->numberOfBlocks);
+
+                // We have all the info we need, exit the for loop
+                break;
+            }
+        }
+        Log(Warning, "MSD Read Format Capacities try %d failed", i+1);
+    }
+    
+    if(this->numBlocks == 0 || this->blockSize == 0)
+        Log(Warning, "MSD Device does not support READ_FORMAT_CAPACITIES command");
+    */
+   
+    ///////////////
+    // Read Capacity
+    // Command might not be required since we already got the data from READ_FORMAT_CAPACITIES
+    ///////////////
+    CommandBlockWrapper readCapacityCMD = SCSIPrepareCommandBlock(SCSI_READ_CAPACITY_10, sizeof(Capacity10Block));
+    Capacity10Block readCapacityRet;
+    if(SCSIRequest(&readCapacityCMD, (uint8_t*)&readCapacityRet, sizeof(Capacity10Block)))
+    {
+        readCapacityRet.logicalBlockAddress = __builtin_bswap32(readCapacityRet.logicalBlockAddress);
+        readCapacityRet.blockLength = __builtin_bswap32(readCapacityRet.blockLength);
+
+        if(readCapacityRet.logicalBlockAddress == 0xFFFFFFFF) // We need to use Read Capacity 16
+        {
+            ////////////
+            // Read Capacity (16)
+            ////////////
+            CommandBlockWrapper readCapacity16CMD = SCSIPrepareCommandBlock(SCSI_READ_CAPACITY_16, sizeof(Capacity16Block));
+            Capacity16Block readCapacityRet16;
+            if(SCSIRequest(&readCapacity16CMD, (uint8_t*)&readCapacityRet16, sizeof(Capacity16Block))) {
+                readCapacityRet16.logicalBlockAddress = __builtin_bswap64(readCapacityRet16.logicalBlockAddress);
+                readCapacityRet16.blockLength = __builtin_bswap64(readCapacityRet16.blockLength);
+
+                this->numBlocks = readCapacityRet16.logicalBlockAddress - 1;
+                this->blockSize = readCapacityRet16.blockLength;
+                this->use16Base = true;
+            }
+        }
+        else
+        {
+            this->numBlocks = readCapacityRet.logicalBlockAddress - 1;
+            this->blockSize = readCapacityRet.blockLength;
+        }
+    }
+
+
+    Log(Info, "MSD Blocks=%d BlockSize=%d Size=%d Mb", this->numBlocks, this->blockSize, ((uint64_t)this->numBlocks * (uint64_t)this->blockSize) / 1024 / 1024);
+    this->size = this->numBlocks * this->blockSize;
+
+    System::diskManager->AddDisk(this);
+    
+    return true;
+}
+// Prepare Command Block for a specific request
+CommandBlockWrapper USBMassStorageDriver::SCSIPrepareCommandBlock(uint8_t command, int length, uint64_t lba, int sectors)
+{
+    CommandBlockWrapper cmd;
+    MemoryOperations::memset(&cmd, 0, sizeof(CommandBlockWrapper));
+
+    //Default parameters for each request
+    cmd.signature = CBW_SIGNATURE;
+    cmd.tag = 0xBEEF;
+    cmd.transferLen = length;
+    cmd.command[0] = command;
+
+    switch(command)
+    {
+        case SCSI_TEST_UNIT_READY:
+            cmd.flags = 0x0;
+            cmd.cmdLen = 0x6;
+            break;
+        case SCSI_REQUEST_SENSE:
+            cmd.flags = 0x80;
+            cmd.cmdLen = 0x6;
+            cmd.command[4] = 18;
+            break;
+        case SCSI_INQUIRY:
+            cmd.flags = 0x80;
+            cmd.cmdLen = 0x6;
+            cmd.command[4] = 36;
+            break;
+        case SCSI_READ_FORMAT_CAPACITIES:
+            cmd.flags = 0x80;
+            cmd.cmdLen = 10;
+            cmd.command[8] = 0xFC;
+            break;
+        case SCSI_READ_CAPACITY_10:
+            cmd.flags = 0x80;
+            cmd.cmdLen = 10;
+            break;
+        case SCSI_READ_CAPACITY_16:
+            cmd.flags = 0x80;
+            cmd.cmdLen = 16;
+            cmd.command[13] = 32;
+            break;
+        case SCSI_READ_10:
+            cmd.flags = 0x80;
+            cmd.cmdLen = 10;
+            cmd.command[2] = (lba >> 24) & 0xFF;
+            cmd.command[3] = (lba >> 16) & 0xFF;
+            cmd.command[4] = (lba >> 8) & 0xFF;
+            cmd.command[5] = (lba >> 0) & 0xFF;
+            cmd.command[7] = (sectors >> 8) & 0xFF;
+            cmd.command[8] = (sectors >> 0) & 0xFF;
+            break;
+        case SCSI_WRITE_10:
+            cmd.flags = 0x0;
+            cmd.cmdLen = 10;
+            cmd.command[2] = (lba >> 24) & 0xFF;
+            cmd.command[3] = (lba >> 16) & 0xFF;
+            cmd.command[4] = (lba >> 8) & 0xFF;
+            cmd.command[5] = (lba >> 0) & 0xFF;
+            cmd.command[7] = (sectors >> 8) & 0xFF;
+            cmd.command[8] = (sectors >> 0) & 0xFF;
+            break;
+        case SCSI_READ_16:
+            cmd.flags = 0x80;
+            cmd.cmdLen = 16;
+            cmd.command[2] = (lba >> 56) & 0xFF;
+            cmd.command[3] = (lba >> 48) & 0xFF;
+            cmd.command[4] = (lba >> 40) & 0xFF;
+            cmd.command[5] = (lba >> 32) & 0xFF;
+            cmd.command[6] = (lba >> 24) & 0xFF;
+            cmd.command[7] = (lba >> 16) & 0xFF;
+            cmd.command[8] = (lba >> 8) & 0xFF;
+            cmd.command[9] = (lba >> 0) & 0xFF;
+            cmd.command[10] = (sectors >> 24) & 0xFF;
+            cmd.command[11] = (sectors >> 16) & 0xFF;
+            cmd.command[12] = (sectors >> 8) & 0xFF;
+            cmd.command[13] = (sectors >> 0) & 0xFF;
+            break;
+        case SCSI_WRITE_16:
+            cmd.flags = 0x0;
+            cmd.cmdLen = 16;
+            cmd.command[2] = (lba >> 56) & 0xFF;
+            cmd.command[3] = (lba >> 48) & 0xFF;
+            cmd.command[4] = (lba >> 40) & 0xFF;
+            cmd.command[5] = (lba >> 32) & 0xFF;
+            cmd.command[6] = (lba >> 24) & 0xFF;
+            cmd.command[7] = (lba >> 16) & 0xFF;
+            cmd.command[8] = (lba >> 8) & 0xFF;
+            cmd.command[9] = (lba >> 0) & 0xFF;
+            cmd.command[10] = (sectors >> 24) & 0xFF;
+            cmd.command[11] = (sectors >> 16) & 0xFF;
+            cmd.command[12] = (sectors >> 8) & 0xFF;
+            cmd.command[13] = (sectors >> 0) & 0xFF;
+            break;         
+        default:
+            Log(Error, "Unkown Command %b", command);
+            break;
+    }
+    return cmd;
+}
+// Perform a reset recovery process after stall
+bool USBMassStorageDriver::ResetRecovery()
+{
+    // First send the MSD Reset Request
+    if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_CLASS | RECPT_INTERFACE, BULK_ONLY_RESET)) {
+        Log(Error, "MSD, Reset Failed!");
+        return false;
+    }
+
+    // Then the Clear feature for the IN-Endpoint
+    if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_STNDRD | RECPT_ENDPOINT, CLEAR_FEATURE, 0, 0, this->bulkInEP)) {
+        Log(Error, "MSD, Clear feature (HALT) Failed for Bulk-In!");
+        return false;
+    }
+    this->device->endpoints[this->bulkInEP-1]->SetToggle(0);
+
+    // Then the Clear feature for the OUT-Endpoint
+    if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_STNDRD | RECPT_ENDPOINT, CLEAR_FEATURE, 0, 0, this->bulkOutEP)) {
+        Log(Error, "MSD, Clear feature (HALT) Failed for Bulk-Out!");
+        return false;
+    }
+    this->device->endpoints[this->bulkOutEP-1]->SetToggle(0);
+
+    return true;
+}
+// Perform a SCSI In or Out operation on device
+bool USBMassStorageDriver::SCSIRequest(CommandBlockWrapper* request, uint8_t* dataPointer, int dataLength)
+{
+    // Send request to device
+    if(!this->device->controller->BulkOut(this->device, request, sizeof(CommandBlockWrapper), this->bulkOutEP)) {
+        Log(Error, "Error Sending command %b to bulk out endpoint", request->command[0]);
+        
+        // Clear HALT for the OUT-Endpoint
+        if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_STNDRD | RECPT_ENDPOINT, CLEAR_FEATURE, 0, 0, this->bulkOutEP)) {
+            Log(Error, "MSD, Clear feature (HALT) Failed for Bulk-Out!");
+            return false;
+        }
+        this->device->endpoints[this->bulkOutEP-1]->SetToggle(0);
+    }
+
+    // If this is a data command, recieve the data
+    if(dataLength > 0) {
+        if(request->flags == 0x80) { // In Transfer
+            if(!this->device->controller->BulkIn(this->device, dataPointer, dataLength, this->bulkInEP)) {
+                Log(Error, "Error receiving data after command %b from bulk endpoint, len=%d", request->command[0], dataLength);
+                
+                // Clear HALT feature for the IN-Endpoint
+                if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_STNDRD | RECPT_ENDPOINT, CLEAR_FEATURE, 0, 0, this->bulkInEP)) {
+                    Log(Error, "MSD, Clear feature (HALT) Failed for Bulk-In!");
+                    return false;
+                }
+                this->device->endpoints[this->bulkInEP-1]->SetToggle(0);
+            }
+        }
+        else { // Out Transfer
+            if(!this->device->controller->BulkOut(this->device, dataPointer, dataLength, this->bulkOutEP)) {
+                Log(Error, "Error sending data after command %b to bulk endpoint, len=%d", request->command[0], dataLength);
+                
+                // Clear HALT feature for the OUT-Endpoint
+                if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_STNDRD | RECPT_ENDPOINT, CLEAR_FEATURE, 0, 0, this->bulkOutEP)) {
+                    Log(Error, "MSD, Clear feature (HALT) Failed for Bulk-Out!");
+                    return false;
+                }
+                this->device->endpoints[this->bulkOutEP-1]->SetToggle(0);                
+            }
+        }
+    }
+
+    // Receive status descriptor from device.
+    // Also when receiving data failed this is required
+    CommandStatusWrapper status;
+    MemoryOperations::memset(&status, 0, sizeof(CommandStatusWrapper));
+    if(!this->device->controller->BulkIn(this->device, &status, sizeof(CommandStatusWrapper), this->bulkInEP)) {
+        Log(Error, "Error reading Command Status Wrapper from bulk in endpoint");
+
+        // Clear HALT feature for the IN-Endpoint
+        if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_STNDRD | RECPT_ENDPOINT, CLEAR_FEATURE, 0, 0, this->bulkInEP)) {
+            Log(Error, "MSD, Clear feature (HALT) Failed for Bulk-In!");
+            return false;
+        }
+        this->device->endpoints[this->bulkInEP-1]->SetToggle(0);        
+    }
+
+    if(status.signature != CSW_SIGNATURE) {
+        this->ResetRecovery();
+        return false;
+    }
+
+    if((status.status == 1) && (request->command[0] != SCSI_REQUEST_SENSE)) {
+        // Command did not succeed so Request the Sense data
+        CommandBlockWrapper requestSenseCMD = SCSIPrepareCommandBlock(SCSI_REQUEST_SENSE, sizeof(RequestSenseBlock));
+        RequestSenseBlock requestSenseRet;
+
+        if(SCSIRequest(&requestSenseCMD, (uint8_t*)&requestSenseRet, sizeof(RequestSenseBlock)))
+            Log(Info, "MSD Request Sense after ReadCap: Error=%b Valid=%d Additional=%d Key=%d ASC=%b ASCQ=%b", requestSenseRet.errorCode, requestSenseRet.valid, requestSenseRet.additionalLength, requestSenseRet.senseKey, requestSenseRet.ASC, requestSenseRet.ASCQ);
+        else
+            Log(Error, "MSD Could not request sense after read capacity failure");
+
+        return false;
+    }
+
+    if((status.status == 2) && (request->command[0] != SCSI_REQUEST_SENSE)) {
+        this->ResetRecovery();
+        return false;
+    }
+
+    if((status.status == 0) && (status.tag == request->tag))
+        return true;
+        
+    Log(Error, "Something wrong with Command Status Wrapper, status = %d", status.status);
+    return false;
+}
+
+// Called when mass storage device is unplugged from system
+void USBMassStorageDriver::DeInitialize()
+{
+    System::diskManager->RemoveDisk(this);
+}
+
+// Read Sector from mass storage device
+char USBMassStorageDriver::ReadSector(common::uint32_t lba, common::uint8_t* buf)
+{
+    this->readWriteLock.Lock();
+    CommandBlockWrapper sendBuf = SCSIPrepareCommandBlock(this->use16Base ? SCSI_READ_16 : SCSI_READ_10, this->blockSize, lba, 1);
+    if(SCSIRequest(&sendBuf, buf, this->blockSize)) {
+        this->readWriteLock.Unlock();
+        return 0; // Command Succes
+    }
+
+    Log(Error, "MSD Error reading sector %x", lba);
+
+    this->readWriteLock.Unlock();
+    return -1;
+}
+
+// Write Sector to mass storage device
+char USBMassStorageDriver::WriteSector(common::uint32_t lba, common::uint8_t* buf)
+{
+    this->readWriteLock.Lock();
+    CommandBlockWrapper sendBuf = SCSIPrepareCommandBlock(this->use16Base ? SCSI_WRITE_16 : SCSI_WRITE_10, this->blockSize, lba, 1);
+    if(SCSIRequest(&sendBuf, buf, this->blockSize)) {
+        this->readWriteLock.Unlock();
+        return 0; // Command Succes
+    }
+
+    Log(Error, "MSD Error writing sector %x", lba);
+
+    this->readWriteLock.Unlock();
+    return -1;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/usb/usbcomborecv.cpp b/kernelz/src/system/drivers/usb/usbcomborecv.cpp
new file mode 100644
index 0000000..d57e0b7
--- /dev/null
+++ b/kernelz/src/system/drivers/usb/usbcomborecv.cpp
@@ -0,0 +1,186 @@
+#include <system/drivers/usb/usbcomborecv.h>
+#include <system/drivers/usb/usbdefs.h>
+#include <system/log.h>
+#include <system/system.h>
+#include <system/usb/hidparser.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+USBComboReceiver::USBComboReceiver(USBDevice* dev)
+: USBDriver(dev, "USB Combo Receiver"), Keyboard(KeyboardType::USB)
+{
+    MemoryOperations::memset(this->prevPacket, 0, sizeof(this->prevPacket));
+}
+
+bool USBComboReceiver::Initialize()
+{
+    if(this->device->hidDescriptor == 0) // If no HID report is found we assume the device is not supported
+        return false;
+
+    // Since this is a device with multiple interfaces we need to request the config descriptor again
+    uint8_t* configBuffer = this->device->controller->GetConfigDescriptor(this->device);
+    if(configBuffer) {
+        uint8_t* startByte = configBuffer;
+        uint8_t* endByte = configBuffer + *(uint16_t*)(configBuffer + 2);
+
+        // Should we set the found endpoints to the mouse interface or the keyboard interface?
+        bool endpToMouse = false;
+
+        // Loop through all data
+        while ((uint32_t)startByte < (uint32_t)endByte) {
+            uint8_t length = startByte[0];
+            uint8_t type = startByte[1];
+
+            if (length == 9 && type == INTERFACE) {
+                struct INTERFACE_DESC* c = (struct INTERFACE_DESC*)startByte;
+                if(c->interface_protocol == 0x02) {
+                    endpToMouse = true;
+                    this->mouseInterface = c->interface_num;
+                }
+                else if(c->interface_protocol == 0x01) {
+                    endpToMouse = false;
+                    this->keyboardInterface = c->interface_num;
+                }
+            }
+            
+            else if (length == 7 && type == ENDPOINT) // ENDPOINT descriptor
+            {
+                USBEndpoint ep = USBEndpoint((struct ENDPOINT_DESC*)startByte);
+
+                if(ep.type == EndpointType::Interrupt) { // Interrupt Endpoint
+                    if(ep.dir == EndpointDirection::In) { // In
+                        if(endpToMouse)
+                            this->mouseIntEndpoint = ep.endpointNumber;
+                        else
+                            this->keyboardIntEndpoint = ep.endpointNumber;
+                    }
+                }
+                
+            }
+            else if (length == 0) // Unvalid entry
+                break;
+            else
+                Log(Warning, "Unknown part of ConfigDescriptor: length: %d type: %d", length, type);
+
+
+            startByte += length;
+        }
+        delete configBuffer;
+    }
+
+    // Check if both endpoints are found
+    if(this->mouseIntEndpoint == -1 || this->keyboardIntEndpoint == -1)
+        return false;
+
+    // Check if both interfaces are found
+    if(this->mouseInterface == -1 || this->keyboardInterface == -1)
+        return false;
+
+    Log(Info, "USBCombo Receiver initializing.... Keyboard -> %d,%d  Mouse -> %d,%d", this->keyboardIntEndpoint, this->keyboardInterface, this->mouseIntEndpoint, this->mouseInterface);
+
+    /////////////////
+    // Keyboard Initialization
+    /////////////////
+    
+    // Send set-idle request to device
+    if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_CLASS | RECPT_INTERFACE, HID_REQUEST_SET_IDLE, 0, 0, this->keyboardInterface))
+        Log(Warning, "USBCombo Keyboard not reacting to SetIdle request");
+
+    // Send set-protocol request to device for the boot protocol
+    if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_CLASS | RECPT_INTERFACE, HID_REQUEST_SET_PROTOCOL, 0, 0, this->keyboardInterface))
+        return false;
+
+    // Start recieving interrupt packets from device
+    this->device->controller->InterruptIn(this->device, 8, this->keyboardIntEndpoint);
+
+    /////////////////
+    // Mouse Initialization
+    // TODO: Don't use boot protocol for this device
+    /////////////////
+    
+    // Send set-idle request to device
+    if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_CLASS | RECPT_INTERFACE, HID_REQUEST_SET_IDLE, 0, 0, this->mouseInterface))
+        Log(Warning, "USBCombo Mouse not reacting to SetIdle request");
+
+    // Send set-protocol request to device for the boot protocol
+    if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_CLASS | RECPT_INTERFACE, HID_REQUEST_SET_PROTOCOL, 0, 0, this->mouseInterface))
+        return false;
+
+    // Start recieving interrupt packets from device
+    this->device->controller->InterruptIn(this->device, 4, this->mouseIntEndpoint);
+
+    return true;
+}
+void USBComboReceiver::DeInitialize()
+{ }
+
+bool USBComboReceiver::HandleInterruptPacket(InterruptTransfer_t* transfer)
+{
+    uint8_t* packet = transfer->bufferPointer;
+    //Log(Info, "USB Combo received packet -> %d", transfer->endpoint);
+
+    if(transfer->endpoint == this->mouseIntEndpoint)
+    {        
+        // Process buttons first, this is the same (we assume) for all mouse devices
+        System::systemInfo->MouseLeftButton = packet[0] & (1<<0);
+        System::systemInfo->MouseRightButton = packet[0] & (1<<1);
+        System::systemInfo->MouseMiddleButton = packet[0] & (1<<2);
+        
+        int realX = (int8_t)(packet[1]);
+        int realY = (int8_t)(packet[2]);
+        System::systemInfo->MouseZ += (int8_t)(packet[3]);
+        
+        // Boundry checking for desktop
+
+        int newX = (System::systemInfo->MouseX + realX);
+        if((newX >= 0) && (newX < (int)System::gfxDevice->width))
+            System::systemInfo->MouseX = newX;
+        else if(newX < 0)
+            System::systemInfo->MouseX = 0;
+        else if(newX >= (int)System::gfxDevice->width)
+            System::systemInfo->MouseX = System::gfxDevice->width - 1;
+        
+        int newY = (System::systemInfo->MouseY + realY);
+        if((newY >= 0) && (newY < (int)System::gfxDevice->height))
+            System::systemInfo->MouseY = newY;
+        else if(newY < 0)
+            System::systemInfo->MouseY = 0;
+        else if(newY >= (int)System::gfxDevice->height)
+            System::systemInfo->MouseY = System::gfxDevice->height - 1;
+    }
+    else if(transfer->endpoint == this->keyboardIntEndpoint)
+    {
+        // Update internal modifier keys
+        uint8_t modifier = packet[0];
+        this->status.LeftControl = modifier & (1<<0);
+        this->status.LeftShift = modifier & (1<<1);
+        this->status.Alt = modifier & (1<<2);
+        this->status.RightControl = modifier & (1<<4);
+        this->status.RightShift = modifier & (1<<5);
+        this->status.AltGr = modifier & (1<<6);
+
+        // Check for each keypacket field if there are any updates
+        for(int i = 2; i < 8; i++) {
+            uint8_t key = packet[i];
+            int pos[2];
+
+            bool b1 = this->ContainsKey(key, packet, &pos[0]);
+            bool b2 = this->ContainsKey(key, this->prevPacket, &pos[1]);
+
+            if(b1 && b2) // Key is still pressed
+                continue;
+            
+            if(b1 && !b2) // Key pressed for first time
+                System::keyboardManager->HandleKeyChange(this, packet[pos[0]], true);
+            else if(!b1 && b2) // Key is released
+                System::keyboardManager->HandleKeyChange(this, this->prevPacket[pos[1]], false);
+        }
+
+        MemoryOperations::memcpy(this->prevPacket, packet, sizeof(this->prevPacket));
+    }
+    return true;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/usb/usbdriver.cpp b/kernelz/src/system/drivers/usb/usbdriver.cpp
new file mode 100644
index 0000000..99a116e
--- /dev/null
+++ b/kernelz/src/system/drivers/usb/usbdriver.cpp
@@ -0,0 +1,30 @@
+#include <system/drivers/usb/usbdriver.h>
+#include <system/log.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+USBDriver::USBDriver(USBDevice* dev, char* driverName)
+: Driver(driverName)
+{
+    this->device = dev;
+}
+
+USBDriver::~USBDriver()
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+}
+
+void USBDriver::DeInitialize()
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+}
+
+bool USBDriver::HandleInterruptPacket(InterruptTransfer_t* transfer)
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+    return false;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/usb/usbkeyboard.cpp b/kernelz/src/system/drivers/usb/usbkeyboard.cpp
new file mode 100644
index 0000000..24c8daa
--- /dev/null
+++ b/kernelz/src/system/drivers/usb/usbkeyboard.cpp
@@ -0,0 +1,107 @@
+#include <system/drivers/usb/usbkeyboard.h>
+#include <system/drivers/usb/usbdefs.h>
+#include <system/log.h>
+#include <system/system.h>
+#include <system/usb/hidparser.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+USBKeyboard::USBKeyboard(USBDevice* dev)
+: USBDriver(dev, "USB HID Keyboard"), Keyboard(KeyboardType::USB)
+{ 
+    MemoryOperations::memset(this->prevPacket, 0, sizeof(this->prevPacket));
+}
+
+bool USBKeyboard::Initialize()
+{
+    if(this->device->hidDescriptor == 0)
+        return false;
+
+    // Find Interrupt Endpoint
+    for(USBEndpoint* ep : this->device->endpoints) {
+        if(ep->type == EndpointType::Interrupt) { // Interrupt Endpoint
+            if(ep->dir == EndpointDirection::In) { // In
+                this->InInterruptEndpoint = ep->endpointNumber;
+                break;
+            }
+        }
+    }
+
+    // Check if endpoint is found
+    if(this->InInterruptEndpoint == -1)
+        return false;
+
+    // Send set-idle request to device
+    if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_CLASS | RECPT_INTERFACE, HID_REQUEST_SET_IDLE))
+        Log(Warning, "USBKeyboard not reacting to SetIdle request");
+
+    // Send SET_PROTOCOL request to device for the boot protocol
+    if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_CLASS | RECPT_INTERFACE, HID_REQUEST_SET_PROTOCOL, 0, 0))
+        return false;
+
+    // Start recieving interrupt packets from device
+    this->device->controller->InterruptIn(this->device, 8, this->InInterruptEndpoint);
+
+    // Add ourself to the list of known keyboards
+    System::keyboardManager->keyboards.push_back(this);
+
+    return true;
+}
+
+void USBKeyboard::DeInitialize()
+{ 
+    // Remove ourself from the list of known keyboards
+    System::keyboardManager->keyboards.Remove(this);
+}
+
+bool USBKeyboard::HandleInterruptPacket(InterruptTransfer_t* transfer)
+{    
+    uint8_t* packet = transfer->bufferPointer;
+
+    // Update internal modifier keys
+    uint8_t modifier = packet[0];
+    this->status.LeftControl = modifier & (1<<0);
+    this->status.LeftShift = modifier & (1<<1);
+    this->status.Alt = modifier & (1<<2);
+    this->status.RightControl = modifier & (1<<4);
+    this->status.RightShift = modifier & (1<<5);
+    this->status.AltGr = modifier & (1<<6);
+
+    // Check for each keypacket field if there are any updates
+    for(int i = 2; i < 8; i++) {
+        uint8_t key = packet[i];
+        int pos[2];
+
+        bool b1 = this->ContainsKey(key, packet, &pos[0]);
+        bool b2 = this->ContainsKey(key, this->prevPacket, &pos[1]);
+
+        if(b1 && b2) // Key is still pressed
+            continue;
+        
+        if(b1 && !b2) // Key pressed for first time
+            System::keyboardManager->HandleKeyChange(this, packet[pos[0]], true);
+        else if(!b1 && b2) // Key is released
+            System::keyboardManager->HandleKeyChange(this, this->prevPacket[pos[1]], false);
+    }
+
+    MemoryOperations::memcpy(this->prevPacket, packet, sizeof(this->prevPacket));
+    return true; // Rescedule
+}
+
+void USBKeyboard::UpdateLEDS()
+{
+	uint8_t code = 0;
+
+	if(System::keyboardManager->sharedStatus.NumLock)
+		code |= 1 << 0;
+		
+	if(System::keyboardManager->sharedStatus.CapsLock)
+		code |= 1 << 1;
+
+    if(!this->device->controller->ControlOut(this->device, 1, HOST_TO_DEV | REQ_TYPE_CLASS | RECPT_INTERFACE, 0x9, 0x02, 0, 0))
+        Log(Warning, "USB KBD Could not update Leds");
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/usb/usbmouse.cpp b/kernelz/src/system/drivers/usb/usbmouse.cpp
new file mode 100644
index 0000000..5a13396
--- /dev/null
+++ b/kernelz/src/system/drivers/usb/usbmouse.cpp
@@ -0,0 +1,134 @@
+#include <system/drivers/usb/usbmouse.h>
+#include <system/drivers/usb/usbdefs.h>
+#include <system/log.h>
+#include <system/system.h>
+#include <system/usb/hidparser.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+USBMouse::USBMouse(USBDevice* dev)
+: USBDriver(dev, "USB HID Mouse")
+{ }
+
+bool USBMouse::GetHIDProperty(struct HID_DATA* target, uint8_t* buffer, int bufLen, HID_USAGE item)
+{
+    MemoryOperations::memset(target, 0, sizeof(struct HID_DATA));
+    target->type = ITEM_INPUT;
+    target->path.node[0].u_page = HID_PAGE_USAGE::GEN_DESKTOP;
+    target->path.node[0].usage = HID_USAGE::MOUSE;
+    target->path.node[1].u_page = HID_PAGE_USAGE::GEN_DESKTOP;
+    target->path.node[1].usage = HID_USAGE::POINTER;
+    target->path.node[2].u_page = HID_PAGE_USAGE::GEN_DESKTOP;
+    target->path.node[2].usage = item;
+    target->path.size = 3;
+    
+    this->hidParser.report_desc = (const uint8_t*)buffer;
+    this->hidParser.report_desc_size = bufLen;
+
+    return this->hidParser.FindObject(target);
+}
+
+bool USBMouse::Initialize()
+{
+    if(this->device->hidDescriptor == 0)
+        return false;
+
+    // Find Interrupt Endpoint
+    for(USBEndpoint* ep : this->device->endpoints) {
+        if(ep->type == EndpointType::Interrupt) { // Interrupt Endpoint
+            if(ep->dir == EndpointDirection::In) { // In
+                this->InInterruptEndpoint = ep->endpointNumber;
+                break;
+            }
+        }
+    }
+
+    // Check if endpoint is found
+    if(this->InInterruptEndpoint == -1)
+        return false;
+
+    // Send set-idle request to device
+    if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_CLASS | RECPT_INTERFACE, HID_REQUEST_SET_IDLE))
+        Log(Warning, "USBMouse not reacting to SetIdle request");
+    
+    // Get length of HID report from Interface HID Descriptor
+    uint16_t reportDescriptorLength = *(uint16_t*)(this->device->hidDescriptor + sizeof(IF_HID_DESC) + 1);
+    if(reportDescriptorLength == 0)
+        return false;
+
+    // Receive Report Descriptor
+    uint8_t* reportDescriptorBuffer = new uint8_t[reportDescriptorLength];
+    if(!this->device->controller->ControlIn(this->device, reportDescriptorBuffer, reportDescriptorLength, DEV_TO_HOST | REQ_TYPE_STNDRD | RECPT_INTERFACE, GET_DESCRIPTOR, 0x22))
+        return false;
+    
+    // Extract data returned from descriptor
+    bool b1 = GetHIDProperty(&this->hidX, reportDescriptorBuffer, reportDescriptorLength, HID_USAGE::POINTER_X);
+    bool b2 = GetHIDProperty(&this->hidY, reportDescriptorBuffer, reportDescriptorLength, HID_USAGE::POINTER_Y);
+    bool b3 = GetHIDProperty(&this->hidZ, reportDescriptorBuffer, reportDescriptorLength, HID_USAGE::POINTER_WHEEL);
+    
+    // Since all required data is present from the discriptor we can use the custom protocol
+    if(b1 && b2 && b3)
+        this->useCustomReport = true;
+
+    // Send SET_PROTOCOL request to device
+    if(!this->device->controller->ControlOut(this->device, 0, HOST_TO_DEV | REQ_TYPE_CLASS | RECPT_INTERFACE, HID_REQUEST_SET_PROTOCOL, 0, this->useCustomReport ? 1 : 0))
+        return false;
+
+    // Start recieving interrupt packets from device
+    this->device->controller->InterruptIn(this->device, 4, this->InInterruptEndpoint);
+
+    return true;
+}
+
+void USBMouse::DeInitialize()
+{ } // Mouse does not have any requirements for unplugging
+
+bool USBMouse::HandleInterruptPacket(InterruptTransfer_t* transfer)
+{
+    uint8_t* packet = transfer->bufferPointer;
+    //Log(Info, "Received mouse packet! %d %d %d %d", packet[0], (int8_t)packet[1], (int8_t)packet[2], packet[3]);
+    
+    // Process buttons first, this is the same (we assume) for all mouse devices
+    System::systemInfo->MouseLeftButton = packet[0] & (1<<0);
+    System::systemInfo->MouseRightButton = packet[0] & (1<<1);
+    System::systemInfo->MouseMiddleButton = packet[0] & (1<<2);
+
+    int realX = 0;
+    int realY = 0;
+    
+    // Then process XYZ information
+    if(this->useCustomReport) {
+        realX = (int8_t)(packet[this->hidX.offset / 8]);
+        realY = (int8_t)(packet[this->hidY.offset / 8]);
+        System::systemInfo->MouseZ += (int8_t)(packet[this->hidZ.offset / 8]);
+    }
+    else {
+        realX = (int8_t)(packet[1]);
+        realY = (int8_t)(packet[2]);
+        System::systemInfo->MouseZ += (int8_t)(packet[3]);
+    }
+
+    // Boundry checking for desktop
+
+    int newX = (System::systemInfo->MouseX + realX);
+    if((newX >= 0) && (newX < (int)System::gfxDevice->width))
+        System::systemInfo->MouseX = newX;
+    else if(newX < 0)
+        System::systemInfo->MouseX = 0;
+    else if(newX >= (int)System::gfxDevice->width)
+        System::systemInfo->MouseX = System::gfxDevice->width - 1;
+    
+    int newY = (System::systemInfo->MouseY + realY);
+    if((newY >= 0) && (newY < (int)System::gfxDevice->height))
+        System::systemInfo->MouseY = newY;
+    else if(newY < 0)
+        System::systemInfo->MouseY = 0;
+    else if(newY >= (int)System::gfxDevice->height)
+        System::systemInfo->MouseY = System::gfxDevice->height - 1;
+    
+    return true; // Rescedule
+}
\ No newline at end of file
diff --git a/kernelz/src/system/drivers/video/vmwaresvga.cpp b/kernelz/src/system/drivers/video/vmwaresvga.cpp
new file mode 100644
index 0000000..4dbddfe
--- /dev/null
+++ b/kernelz/src/system/drivers/video/vmwaresvga.cpp
@@ -0,0 +1,70 @@
+#include <system/drivers/video/vmwaresvga.h>
+
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+using namespace CactusOS::core;
+
+VMWARESVGAII::VMWARESVGAII(PCIDevice* pciDev)
+: Driver("VMWare SVGAII", "VMWare Graphics Adapter"),
+  GraphicsDevice("WMWare SVGAII Adapter")
+{
+    this->width = 0;
+    this->height = 0;
+    this->bpp = 0;
+    this->framebufferPhys = 0;
+
+    this->pciDevice = pciDev;
+}
+
+void VMWARESVGAII::WriteRegister(uint32_t index, uint32_t value)
+{
+    outportl(pciDevice->portBase + SVGA_INDEX_PORT, index);
+    outportl(pciDevice->portBase + SVGA_VALUE_PORT, value);
+}
+uint32_t VMWARESVGAII::ReadRegister(uint32_t index)
+{
+    outportl(pciDevice->portBase + SVGA_INDEX_PORT, index);
+    return inportl(pciDevice->portBase + SVGA_VALUE_PORT);
+}   
+
+bool VMWARESVGAII::Initialize()
+{
+    Log(Info, "Intializing VMWare Graphics Device");
+    
+    //Enable Device Memory
+    uint16_t com = System::pci->Read(pciDevice->bus, pciDevice->device, pciDevice->function, 0x04);
+    com |= 0x0007;
+    System::pci->Write(pciDevice->bus, pciDevice->device, pciDevice->function, 0x04, com);
+
+    WriteRegister(SVGA_REG_ID, SVGA_ID_2);
+    if (ReadRegister(SVGA_REG_ID) != SVGA_ID_2)
+        return false;
+
+    this->framebufferPhys = ReadRegister(SVGA_REG_FB_START);
+    Log(Info, "Framebuffer is at: %x", this->framebufferPhys);
+
+    Log(Warning, "Replacing fallback gfx device");
+    GraphicsDevice* old = System::gfxDevice;
+    System::gfxDevice = this;
+    delete old;
+
+    return true;
+}
+
+bool VMWARESVGAII::SelectBestVideoMode()
+{
+    WriteRegister(SVGA_REG_FB_Width, DEFAULT_SCREEN_WIDTH);
+    WriteRegister(SVGA_REG_FB_Height, DEFAULT_SCREEN_HEIGHT);
+    WriteRegister(SVGA_REG_FB_BitsPerPixel, DEFAULT_SCREEN_BPP);
+    WriteRegister(SVGA_REG_FB_Enable, 1);
+
+    this->width = DEFAULT_SCREEN_WIDTH;
+    this->height = DEFAULT_SCREEN_HEIGHT;
+    this->bpp = DEFAULT_SCREEN_BPP;
+    
+    return true;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/initrd.cpp b/kernelz/src/system/initrd.cpp
new file mode 100644
index 0000000..9972ceb
--- /dev/null
+++ b/kernelz/src/system/initrd.cpp
@@ -0,0 +1,42 @@
+#include <system/initrd.h>
+#include <system/log.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+void* locationInMemory = 0;
+
+void InitialRamDisk::Initialize(multiboot_info_t* mbi)
+{
+    if(mbi->mods_count <= 0)
+    {
+        Log(Info, "Error mods count is 0 or less");
+        return;
+    }
+    
+    uint32_t ramdiskLocation = *(uint32_t*)mbi->mods_addr;
+    uint32_t ramdiskEnd = *(uint32_t*)(mbi->mods_addr + 4);
+
+    Log(Info, "Ramdisk is at: %x", ramdiskLocation);
+    Log(Info, "Ramdisk size: %d", ramdiskEnd - ramdiskLocation);
+
+    locationInMemory = (void*)ramdiskLocation;
+}
+
+void* InitialRamDisk::ReadFile(const char* path, uint32_t* fileSizeReturn)
+{
+    InitrdFileHeader* header = (InitrdFileHeader*)locationInMemory;
+    while(header->size != 0)
+    {
+        if(String::strcmp(header->path, path))
+        {
+            if(fileSizeReturn != 0)
+                *fileSizeReturn = header->size;
+            return (void*)((uint32_t)header + sizeof(InitrdFileHeader));
+        }
+        
+        header = (InitrdFileHeader*)((uint32_t)header + sizeof(InitrdFileHeader) + header->size);
+    }
+    return 0;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/input/keyboard.cpp b/kernelz/src/system/input/keyboard.cpp
new file mode 100644
index 0000000..3a42cdb
--- /dev/null
+++ b/kernelz/src/system/input/keyboard.cpp
@@ -0,0 +1,24 @@
+#include <system/input/keyboard.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+Keyboard::Keyboard(KeyboardType type)
+{
+    this->type = type;
+    MemoryOperations::memset(&this->status, 0, sizeof(this->status));
+}
+
+void Keyboard::UpdateLEDS()
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+}
+
+bool Keyboard::ContainsKey(uint8_t key, uint8_t* packet, int* pos)
+{
+    for(int i = 2; i < 8; i++)
+        if(packet[i] == key) { *pos = i; return true; }
+    return false;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/input/keyboardmanager.cpp b/kernelz/src/system/input/keyboardmanager.cpp
new file mode 100644
index 0000000..a02383f
--- /dev/null
+++ b/kernelz/src/system/input/keyboardmanager.cpp
@@ -0,0 +1,147 @@
+#include <system/input/keyboardmanager.h>
+#include <../../lib/include/shared.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+KeyboardManager::KeyboardManager()
+{ 
+    MemoryOperations::memset(&this->sharedStatus, 0, sizeof(this->sharedStatus));
+}
+
+void KeyboardManager::HandleKeyChange(Keyboard* src, uint32_t key, bool pressed)
+{
+    if(src->type == KeyboardType::USB)
+        key = ConvertToPS2(key);
+
+    //Log(Info, "Got key %d from keyboard, pressed = %b", key, pressed);
+    
+    bool updateLeds = false;
+    LIBCactusOS::KeypressPacket packet = {.startByte = KEYPACKET_START, .keyCode = 0, .flags = pressed ? LIBCactusOS::Pressed : LIBCactusOS::NoFlags};
+
+    ////////////
+    // Update keyboards globals
+    ////////////
+    if(key == 0x3A && pressed) { // Toggle Keys
+        this->sharedStatus.CapsLock = !this->sharedStatus.CapsLock;
+        updateLeds = true;
+    }
+    else if(key == 0x45 && pressed) { //Toggle Keys
+        this->sharedStatus.NumLock = !this->sharedStatus.NumLock;
+        updateLeds = true;
+    }
+    
+    // Update packet flags
+    packet.flags = (packet.flags | (this->sharedStatus.CapsLock ? LIBCactusOS::CapsLock : LIBCactusOS::NoFlags));
+    packet.flags = (packet.flags | (this->sharedStatus.NumLock ? LIBCactusOS::NumLock : LIBCactusOS::NoFlags));
+    
+    packet.flags = (packet.flags | (src->status.LeftShift ? LIBCactusOS::LeftShift : LIBCactusOS::NoFlags));
+    packet.flags = (packet.flags | (src->status.RightShift ? LIBCactusOS::RightShift : LIBCactusOS::NoFlags));
+    packet.flags = (packet.flags | (src->status.LeftControl ? LIBCactusOS::LeftControl : LIBCactusOS::NoFlags));
+    packet.flags = (packet.flags | (src->status.RightControl ? LIBCactusOS::RightControl : LIBCactusOS::NoFlags));
+    packet.flags = (packet.flags | (src->status.Alt ? LIBCactusOS::Alt : LIBCactusOS::NoFlags));
+
+    // Set keycode
+    packet.keyCode = key;
+
+    if(System::screenMode == ScreenMode::GraphicsMode)
+        for(int i = 0; i < (int)sizeof(LIBCactusOS::KeypressPacket); i++)
+            this->Write(*((char*)((uint32_t)&packet + i)));
+    else if(System::setupMode == true && (packet.flags & LIBCactusOS::Pressed))
+        this->Write(key); //Make things easier for the setup
+
+    if(updateLeds) {
+        for(Keyboard* kbd : this->keyboards)
+            if(kbd->type != USB) // USB keyboards need interrupts enabled. TODO: Change this perhaps?
+                kbd->UpdateLEDS();
+    }
+}
+uint8_t KeyboardManager::ConvertToPS2(uint32_t key)
+{
+    if(key < 4)
+        return 0; // Invallid
+
+    switch(key)
+    {
+        case 0x4: return 0x1E;
+        case 0x5: return 0x30;
+        case 0x6: return 0x2E;
+        case 0x7: return 0x20;
+        case 0x8: return 0x12;
+        case 0x9: return 0x21;
+        case 0xA: return 0x22;
+        case 0xB: return 0x23;
+        case 0xC: return 0x17;
+        case 0xD: return 0x24;
+        case 0xE: return 0x25;
+        case 0xF: return 0x26;
+        case 0x10: return 0x32;
+        case 0x11: return 0x31;
+        case 0x12: return 0x18;
+        case 0x13: return 0x19;
+        case 0x14: return 0x10;
+        case 0x15: return 0x13;
+        case 0x16: return 0x1F;
+        case 0x17: return 0x14;
+        case 0x18: return 0x16;
+        case 0x19: return 0x2F;
+        case 0x1A: return 0x11;
+        case 0x1B: return 0x2D;
+        case 0x1C: return 0x15;
+        case 0x1D: return 0x2C;
+        case 0x1E ... 0x26: return (key - 0x1E + 2);
+        case 0x27: return 0xB;
+        case 0x28: return 0x1C;
+        case 0x29: return 0x1;
+        case 0x2A: return 0xE;
+        case 0x2B: return 0xF;
+        case 0x2C: return 0x39;
+        case 0x2D: return 0xC;
+        case 0x2E: return 0xD;
+        case 0x2F: return 0x1A;
+        case 0x30: return 0x1B;
+        case 0x31: return 0x2B;
+        case 0x32: return 0x2B;
+        case 0x33: return 0x27;
+        case 0x34: return 0x28;
+        case 0x35: return 0x29;
+        case 0x36: return 0x33;
+        case 0x37: return 0x34;
+        case 0x38: return 0x35;
+        case 0x39: return 0x3A;
+        case 0x3A ... 0x43: return key + 1;
+        case 0x44: return 0x57;
+        case 0x45: return 0x58;
+        case 0x49: return 0x52;
+        case 0x4A: return 0x47;
+        case 0x4B: return 0x49;
+        case 0x4C: return 0x53;
+        case 0x4D: return 0x4F;
+        case 0x4E: return 0x51;
+        case 0x4F: return 0x4D;
+        case 0x50: return 0x4B;
+        case 0x51: return 0x50;
+        case 0x52: return 0x48;
+        case 0x53: return 0x45;
+        case 0x54: return 0x35;
+        case 0x55: return 0x37;
+        case 0x56: return 0x4A;
+        case 0x57: return 0x4E;
+        case 0x58: return 0x1C;
+        case 0x59: return 0x4F;
+        case 0x5A: return 0x50;
+        case 0x5B: return 0x51;
+        case 0x5C: return 0x4B;
+        case 0x5D: return 0x4C;
+        case 0x5E: return 0x4D;
+        case 0x5F: return 0x47;
+        case 0x60: return 0x48;
+        case 0x61: return 0x49;
+        case 0x62: return 0x52;
+        case 0x63: return 0x53;
+
+        default: return 0;
+    }
+}
\ No newline at end of file
diff --git a/kernelz/src/system/interruptmanager.cpp b/kernelz/src/system/interruptmanager.cpp
new file mode 100644
index 0000000..02e52dc
--- /dev/null
+++ b/kernelz/src/system/interruptmanager.cpp
@@ -0,0 +1,61 @@
+#include <system/interruptmanager.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+
+InterruptHandler::InterruptHandler(uint8_t interruptNumber)
+{
+    InterruptManager::AddHandler(this, interruptNumber);
+}
+
+uint32_t InterruptHandler::HandleInterrupt(uint32_t esp)
+{
+    return esp;
+}
+
+
+
+List<InterruptHandler*>* InterruptManager::interruptCallbacks[256]; //Allows for multiple interrupt handlers per interrupt
+
+void InterruptManager::Initialize()
+{
+    for(int i = 0; i < 256; i++)
+    {
+        interruptCallbacks[i] = 0;
+    }
+}
+
+uint32_t InterruptManager::HandleInterrupt(uint8_t num, uint32_t esp)
+{
+    if(interruptCallbacks[num] == 0) //No list of callbacks present for specific interrupt
+        return esp;
+    
+    if(interruptCallbacks[num]->size() == 0) //The list contains no handlers
+        return esp;
+    
+    for(int i = 0; i < interruptCallbacks[num]->size(); i++)
+    {
+        InterruptHandler* handler = interruptCallbacks[num]->GetAt(i);
+        esp = handler->HandleInterrupt(esp);
+    }
+
+    return esp;
+}
+
+void InterruptManager::AddHandler(InterruptHandler* handler, uint8_t interrupt)
+{
+    if(interruptCallbacks[interrupt] == 0)
+        interruptCallbacks[interrupt] = new List<InterruptHandler*>(); //Create new list
+    
+    interruptCallbacks[interrupt]->push_back(handler);
+}
+void InterruptManager::RemoveHandler(InterruptHandler* handler, uint8_t interrupt)
+{
+    interruptCallbacks[interrupt]->Remove(handler);
+    if(interruptCallbacks[interrupt]->size() == 0) {
+        delete interruptCallbacks[interrupt];
+        interruptCallbacks[interrupt] = 0;
+    }
+}
\ No newline at end of file
diff --git a/kernelz/src/system/listings/directorylisting.cpp b/kernelz/src/system/listings/directorylisting.cpp
new file mode 100644
index 0000000..9bc0dc2
--- /dev/null
+++ b/kernelz/src/system/listings/directorylisting.cpp
@@ -0,0 +1,67 @@
+#include <system/listings/directorylisting.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+// List which holds the files in the current requested directory.
+List<LIBCactusOS::VFSEntry>* currentDirectoryList = 0;
+
+DirectoryListing::DirectoryListing()
+: ListingController() { }
+
+int DirectoryListing::BeginListing(Thread* thread, uint32_t pathPtr)
+{
+    char* path = (char*)pathPtr;
+    if(!System::vfs->DirectoryExists(path))
+        return -1;
+    
+    if(requestBusy)
+    {
+        waitingQueue.push_back(thread);
+        System::scheduler->Block(thread);
+    }
+
+    requestBusy = true;
+    currentReqThread = thread;
+
+    currentDirectoryList = System::vfs->DirectoryList(path);
+    return currentDirectoryList->size();
+}
+int DirectoryListing::GetEntry(Thread* thread, int entry, uint32_t bufPtr)
+{
+    char* buf = (char*)bufPtr;
+    if(currentReqThread != thread)
+    {
+        Log(Error, "Thread requested entry while it was not the original requestor");
+        return 0;
+    }
+
+    if(entry >= 0 && currentDirectoryList->size() > entry && buf != 0)
+    {
+        LIBCactusOS::VFSEntry item = currentDirectoryList->GetAt(entry);
+        MemoryOperations::memcpy(buf, &item, sizeof(LIBCactusOS::VFSEntry));
+
+        return 1;
+    }
+    
+    // End of items
+    return 0;
+}
+void DirectoryListing::EndListing(Thread* thread)
+{
+    if(currentReqThread != thread || currentReqThread == 0)
+    {
+        Log(Error, "Thread requested listing end while it was not the original requestor");
+        return;
+    }
+
+    requestBusy = false;
+    currentReqThread = 0;
+    delete currentDirectoryList;
+
+    if(waitingQueue.size() > 0) //Unblock first thread from queue.
+        System::scheduler->Unblock(waitingQueue[0]);
+}
\ No newline at end of file
diff --git a/kernelz/src/system/listings/listingcontroller.cpp b/kernelz/src/system/listings/listingcontroller.cpp
new file mode 100644
index 0000000..eb62e7e
--- /dev/null
+++ b/kernelz/src/system/listings/listingcontroller.cpp
@@ -0,0 +1,22 @@
+#include <system/listings/listingcontroller.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+ListingController::ListingController()
+: waitingQueue(), currentReqThread(), requestBusy(false) {}
+
+int ListingController::BeginListing(Thread* thread, uint32_t arg1) {
+    Log(Error, "ListingController Class is used directly while it is virtual");
+    return 0;
+}
+int ListingController::GetEntry(Thread* thread, int entry, uint32_t bufPtr) {
+    Log(Error, "ListingController Class is used directly while it is virtual");
+    return 0;
+}
+void ListingController::EndListing(Thread* thread) { 
+    Log(Error, "ListingController Class is used directly while it is virtual");
+}
\ No newline at end of file
diff --git a/kernelz/src/system/listings/systeminfo.cpp b/kernelz/src/system/listings/systeminfo.cpp
new file mode 100644
index 0000000..e3bf9bc
--- /dev/null
+++ b/kernelz/src/system/listings/systeminfo.cpp
@@ -0,0 +1,416 @@
+#include <system/listings/systeminfo.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+SIBIOS SystemInfoManager::bios;
+SISYSTEM SystemInfoManager::system;
+SIENCLOSURE SystemInfoManager::enclosure;
+SIPROCESSOR SystemInfoManager::processor;
+
+bool SystemInfoManager::HandleSysinfoRequest(void* arrayPointer, int count, common::uint32_t retAddr, bool getSize)
+{
+    LIBCactusOS::SIPropertyProvider* items = (LIBCactusOS::SIPropertyProvider*)arrayPointer;
+
+    if(items[0].type != LIBCactusOS::SIPropertyIdentifier::String || !items[0].id)
+        return false; // First identifier needs to be a string
+
+    if(String::strcmp(items[0].id, "properties"))
+    {
+        if(items[1].type != LIBCactusOS::SIPropertyIdentifier::String || !items[1].id)
+            return false; // Second identifier needs to be a string
+        
+        if(String::strcmp(items[1].id, "disks")) {
+            if(getSize) {
+                *((int*)retAddr) = System::diskManager->allDisks.size();
+                return true;
+            }
+            if(items[2].type != LIBCactusOS::SIPropertyIdentifier::Index || items[3].type != LIBCactusOS::SIPropertyIdentifier::String)
+                return false; // Needs to be index for collection and next needs to be property id
+
+            int index = items[2].index;
+            if(String::strcmp(items[3].id, "size")) {
+                *((uint64_t*)retAddr) = System::diskManager->allDisks[index]->size;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "identifier")) {
+                char* targ = (char*)retAddr;
+                int len = String::strlen(System::diskManager->allDisks[index]->identifier);
+                MemoryOperations::memcpy(targ, System::diskManager->allDisks[index]->identifier, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "blocks")) {
+                *((uint32_t*)retAddr) = System::diskManager->allDisks[index]->numBlocks;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "blocksize")) {
+                *((uint32_t*)retAddr) = System::diskManager->allDisks[index]->blockSize;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "type")) {
+                *((int*)retAddr) = (int)System::diskManager->allDisks[index]->type;
+                return true;
+            }
+            else
+                return false;         
+        }
+        else if(String::strcmp(items[1].id, "usbdevices")) {
+            if(getSize) {
+                *((int*)retAddr) = System::usbManager->deviceList.size();
+                return true;
+            }
+            if(items[2].type != LIBCactusOS::SIPropertyIdentifier::Index || items[3].type != LIBCactusOS::SIPropertyIdentifier::String)
+                return false; // Needs to be index for collection and next needs to be property id
+
+            int index = items[2].index;
+            if(String::strcmp(items[3].id, "name")) {
+                char* targ = (char*)retAddr;
+                char* src = System::usbManager->deviceList[index]->deviceName ? System::usbManager->deviceList[index]->deviceName : (char*)"N/A";
+                int len = String::strlen(src);
+                MemoryOperations::memcpy(targ, src, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "address")) {
+                *((int*)retAddr) = (int)System::usbManager->deviceList[index]->devAddress;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "controller")) {
+                *((int*)retAddr) = (int)System::usbManager->controllerList.IndexOf(System::usbManager->deviceList[index]->controller);
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "prodID")) {
+                *((uint16_t*)retAddr) = (int)System::usbManager->deviceList[index]->productID;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "vendID")) {
+                *((uint16_t*)retAddr) = (int)System::usbManager->deviceList[index]->vendorID;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "endpoints")) {
+                if(getSize) {
+                    *((int*)retAddr) = System::usbManager->deviceList[index]->endpoints.size();
+                    return true;
+                }
+                //TODO: Add more properties here
+            }
+            else
+                return false;            
+        }
+        else if(String::strcmp(items[1].id, "usbcontrollers")) {
+            if(getSize) {
+                *((int*)retAddr) = System::usbManager->controllerList.size();
+                return true;
+            }
+            if(items[2].type != LIBCactusOS::SIPropertyIdentifier::Index || items[3].type != LIBCactusOS::SIPropertyIdentifier::String)
+                return false; // Needs to be index for collection and next needs to be property id
+
+            int index = items[2].index;
+            if(String::strcmp(items[3].id, "type")) {
+                *((int*)retAddr) = System::usbManager->controllerList[index]->type;
+                return true;
+            }
+            else
+                return false;         
+        }
+        else if(String::strcmp(items[1].id, "pcidevs")) {
+            if(getSize) {
+                *((int*)retAddr) = System::pci->deviceList.size();
+                return true;
+            }
+            if(items[2].type != LIBCactusOS::SIPropertyIdentifier::Index || items[3].type != LIBCactusOS::SIPropertyIdentifier::String)
+                return false; // Needs to be index for collection and next needs to be property id
+
+            int index = items[2].index;
+            if(String::strcmp(items[3].id, "bus")) {
+                *((uint16_t*)retAddr) = System::pci->deviceList[index]->bus;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "classID")) {
+                *((uint8_t*)retAddr) = System::pci->deviceList[index]->classID;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "device")) {
+                *((uint16_t*)retAddr) = System::pci->deviceList[index]->device;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "deviceID")) {
+                *((uint16_t*)retAddr) = System::pci->deviceList[index]->deviceID;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "function")) {
+                *((uint16_t*)retAddr) = System::pci->deviceList[index]->function;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "interrupt")) {
+                *((uint8_t*)retAddr) = System::pci->deviceList[index]->interrupt;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "progIF")) {
+                *((uint8_t*)retAddr) = System::pci->deviceList[index]->programmingInterfaceID;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "revisionID")) {
+                *((uint8_t*)retAddr) = System::pci->deviceList[index]->revisionID;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "subclassID")) {
+                *((uint8_t*)retAddr) = System::pci->deviceList[index]->subclassID;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "vendorID")) {
+                *((uint16_t*)retAddr) = System::pci->deviceList[index]->vendorID;
+                return true;
+            }
+            else
+                return false;         
+        }
+        else if(String::strcmp(items[1].id, "gfxdevice")) {
+            if(items[2].type != LIBCactusOS::SIPropertyIdentifier::String)
+                return false; // Needs to be property id
+            
+            if(String::strcmp(items[2].id, "bpp")) {
+                *((uint8_t*)retAddr) = System::gfxDevice->bpp;
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "width")) {
+                *((uint32_t*)retAddr) = System::gfxDevice->width;
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "height")) {
+                *((uint32_t*)retAddr) = System::gfxDevice->height;
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "framebuffer")) {
+                *((uint32_t*)retAddr) = System::gfxDevice->framebufferPhys;
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "name")) {
+                char* targ = (char*)retAddr;
+                int len = String::strlen(System::gfxDevice->identifier);
+                MemoryOperations::memcpy(targ, System::gfxDevice->identifier, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else
+                return false;
+        }
+        else if(String::strcmp(items[1].id, "processes")) {
+            if(getSize) {
+                *((int*)retAddr) = ProcessHelper::Processes.size();
+                return true;
+            }
+            if(items[2].type != LIBCactusOS::SIPropertyIdentifier::Index || items[3].type != LIBCactusOS::SIPropertyIdentifier::String)
+                return false; // Needs to be index for collection and next needs to be property id
+
+            int index = items[2].index;
+            if(String::strcmp(items[3].id, "pid")) {
+                *((int*)retAddr) = ProcessHelper::Processes[index]->id;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "userspace")) {
+                *((bool*)retAddr) = ProcessHelper::Processes[index]->isUserspace;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "state")) {
+                *((int*)retAddr) = (int)ProcessHelper::Processes[index]->Threads[0]->state;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "membase")) {
+                *((uint32_t*)retAddr) = ProcessHelper::Processes[index]->excecutable.memBase;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "memsize")) {
+                *((uint32_t*)retAddr) = ProcessHelper::Processes[index]->excecutable.memSize;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "heap-start")) {
+                *((uint32_t*)retAddr) = ProcessHelper::Processes[index]->heap.heapStart;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "heap-end")) {
+                *((uint32_t*)retAddr) = ProcessHelper::Processes[index]->heap.heapEnd;
+                return true;
+            }
+            else if(String::strcmp(items[3].id, "filename")) {
+                char* targ = (char*)retAddr;
+                int len = String::strlen(ProcessHelper::Processes[index]->fileName);
+                MemoryOperations::memcpy(targ, ProcessHelper::Processes[index]->fileName, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else
+                return false;
+        }
+        else if(String::strcmp(items[1].id, "memory")) {
+            if(items[2].type != LIBCactusOS::SIPropertyIdentifier::String)
+                return false; // Needs to be property id
+            
+            if(String::strcmp(items[2].id, "total")) {
+                *((uint32_t*)retAddr) = PhysicalMemoryManager::AmountOfMemory();
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "used")) {
+                *((uint32_t*)retAddr) = PhysicalMemoryManager::UsedBlocks() * PAGE_SIZE;
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "free")) {
+                *((uint32_t*)retAddr) = PhysicalMemoryManager::FreeBlocks() * PAGE_SIZE;
+                return true;
+            }
+            else
+                return false;
+        }
+        else if(String::strcmp(items[1].id, "bios")) {
+            if(items[2].type != LIBCactusOS::SIPropertyIdentifier::String)
+                return false; // Needs to be property id
+
+            if(String::strcmp(items[2].id, "vendor")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::bios.vendor);
+                MemoryOperations::memcpy(targ, SystemInfoManager::bios.vendor, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "version")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::bios.version);
+                MemoryOperations::memcpy(targ, SystemInfoManager::bios.version, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "releasedate")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::bios.releaseDate);
+                MemoryOperations::memcpy(targ, SystemInfoManager::bios.releaseDate, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else
+                return false;
+        }
+        else if(String::strcmp(items[1].id, "system")) {
+            if(items[2].type != LIBCactusOS::SIPropertyIdentifier::String)
+                return false; // Needs to be property id
+
+            if(String::strcmp(items[2].id, "manufacturer")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::system.manufacturer);
+                MemoryOperations::memcpy(targ, SystemInfoManager::system.manufacturer, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "product")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::system.product);
+                MemoryOperations::memcpy(targ, SystemInfoManager::system.product, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "version")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::system.version);
+                MemoryOperations::memcpy(targ, SystemInfoManager::system.version, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "serial")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::system.serial);
+                MemoryOperations::memcpy(targ, SystemInfoManager::system.serial, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "sku")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::system.sku);
+                MemoryOperations::memcpy(targ, SystemInfoManager::system.sku, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "family")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::system.family);
+                MemoryOperations::memcpy(targ, SystemInfoManager::system.family, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else
+                return false;
+        }
+        else if(String::strcmp(items[1].id, "enclosure")) {
+            if(items[2].type != LIBCactusOS::SIPropertyIdentifier::String)
+                return false; // Needs to be property id
+
+            if(String::strcmp(items[2].id, "manufacturer")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::enclosure.manufacturer);
+                MemoryOperations::memcpy(targ, SystemInfoManager::enclosure.manufacturer, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "version")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::enclosure.version);
+                MemoryOperations::memcpy(targ, SystemInfoManager::enclosure.version, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "serial")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::enclosure.serial);
+                MemoryOperations::memcpy(targ, SystemInfoManager::enclosure.serial, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "sku")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::enclosure.sku);
+                MemoryOperations::memcpy(targ, SystemInfoManager::enclosure.sku, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else
+                return false;
+        }
+        else if(String::strcmp(items[1].id, "processor")) {
+            if(items[2].type != LIBCactusOS::SIPropertyIdentifier::String)
+                return false; // Needs to be property id
+
+            if(String::strcmp(items[2].id, "manufacturer")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::processor.manufacturer);
+                MemoryOperations::memcpy(targ, SystemInfoManager::processor.manufacturer, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "socket")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::processor.socket);
+                MemoryOperations::memcpy(targ, SystemInfoManager::processor.socket, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else if(String::strcmp(items[2].id, "version")) {                
+                char* targ = (char*)retAddr;
+                int len = String::strlen(SystemInfoManager::processor.version);
+                MemoryOperations::memcpy(targ, SystemInfoManager::processor.version, len);
+                targ[len] = '\0';
+                return true;
+            }
+            else
+                return false;
+        }
+        else
+            return false; // Unknown identifier
+    }
+    else
+        return false; // Unknown category
+
+    return false;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/log.cpp b/kernelz/src/system/log.cpp
new file mode 100644
index 0000000..697cd61
--- /dev/null
+++ b/kernelz/src/system/log.cpp
@@ -0,0 +1,146 @@
+#include <system/log.h>
+
+#include <system/bootconsole.h>
+#include <system/serialport.h>
+#include <system/system.h>
+
+#include <limits.h>
+#include <stdbool.h>
+#include <stdarg.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+char* logLevelMessage[3] {
+    "[Info]",
+    "[Warning]",
+    "[Error]"
+};
+
+#if LOG_SHOW_MS
+uint32_t GetMSSinceBoot()
+{
+    if(System::pit != 0)
+        return System::pit->Ticks();
+    return 0;
+}
+#endif
+
+void CactusOS::system::Print(const char* data, uint32_t length) {
+    if(System::screenMode == ScreenMode::TextMode)
+    {
+        for (uint32_t i = 0; i < length; i++)
+            BootConsole::Write(data[i]);
+    }
+    else if(Serialport::Initialized && (System::gdbEnabled == false))
+    {
+        for (uint32_t i = 0; i < length; i++)
+            Serialport::Write(data[i]);
+    }
+}
+
+void CactusOS::system::Log(LogLevel level, const char* __restrict__ format, ...)
+{
+    uint8_t prevColor = BootConsole::ForegroundColor;
+    if(System::screenMode == ScreenMode::TextMode)
+    {
+        #if LOG_SHOW_MS
+        BootConsole::Write("["); BootConsole::Write(Convert::IntToString(GetMSSinceBoot())); BootConsole::Write("] ");
+        #endif
+        switch (level)
+        {
+            case Info:
+                BootConsole::ForegroundColor = VGA_COLOR_BLACK;
+                break;
+            case Warning:
+                BootConsole::ForegroundColor = VGA_COLOR_BROWN;
+                break;
+            case Error:
+                BootConsole::ForegroundColor = VGA_COLOR_RED;
+                break;
+        }
+        BootConsole::Write(logLevelMessage[level]); BootConsole::Write(": ");
+    }
+    else if(Serialport::Initialized && (System::gdbEnabled == false))
+    {
+        #if LOG_SHOW_MS
+        Serialport::WriteStr("["); Serialport::WriteStr(Convert::IntToString(GetMSSinceBoot())); Serialport::WriteStr("] ");
+        #endif
+        Serialport::WriteStr(logLevelMessage[level]); Serialport::WriteStr(": ");
+    }
+
+    va_list parameters;
+	va_start(parameters, format);
+ 
+	while (*format != '\0') { 
+		if (format[0] != '%' || format[1] == '%') {
+			if (format[0] == '%')
+				format++;
+			uint32_t amount = 1;
+			while (format[amount] && format[amount] != '%')
+				amount++;
+			Print(format, amount);
+			format += amount;
+			continue;
+		}
+ 
+		const char* format_begun_at = format++;
+ 
+		if (*format == 'c') {
+			format++;
+			char c = (char) va_arg(parameters, int /* char promotes to int */);
+			Print(&c, sizeof(c));
+		} else if (*format == 's') {
+			format++;
+			const char* str = va_arg(parameters, const char*);
+			uint32_t len = String::strlen(str);
+			Print(str, len);
+         } else if(*format == 'd') {
+            format++;
+            int n = va_arg(parameters, int);
+            int numChars = 0;
+            if (n < 0) { n = -n; numChars++; Print("-", 1); }
+
+            int temp = n;
+            do
+            {
+                numChars++;
+                temp /= 10;
+            } while (temp);
+
+            Print(Convert::IntToString(n), numChars);
+        } else if(*format == 'b') {
+            format++;
+            uint8_t n = va_arg(parameters, int);
+            char* str = Convert::IntToHexString(n);
+            Print("0x", 2); Print(str, sizeof(uint8_t)<<1);
+            delete str;
+        } else if(*format == 'w') {
+            format++;
+            uint16_t n = va_arg(parameters, int);
+            char* str = Convert::IntToHexString(n);
+            Print("0x", 2); Print(str, sizeof(uint16_t)<<1);
+            delete str;
+        } else if(*format == 'x') {
+            format++;
+            uint32_t n = va_arg(parameters, int);
+            char* str = Convert::IntToHexString(n);
+            Print("0x", 2); Print(str, sizeof(uint32_t)<<1);
+            delete str;
+        } else {
+			format = format_begun_at;
+			uint32_t len = String::strlen(format);
+			Print(format, len);
+			format += len;
+		}
+	}
+ 
+	va_end(parameters);
+
+    Print("\n", 1);
+
+    if(System::screenMode == ScreenMode::TextMode)
+        BootConsole::ForegroundColor = prevColor;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/memory/deviceheap.cpp b/kernelz/src/system/memory/deviceheap.cpp
new file mode 100644
index 0000000..f6bd396
--- /dev/null
+++ b/kernelz/src/system/memory/deviceheap.cpp
@@ -0,0 +1,22 @@
+#include <system/memory/deviceheap.h>
+#include <system/memory/heap.h>
+#include <system/log.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+uint32_t DeviceHeap::currentAddress = DEVICE_HEAP_START;
+
+uint32_t DeviceHeap::AllocateChunk(uint32_t size)
+{
+    uint32_t ret = DeviceHeap::currentAddress;
+    DeviceHeap::currentAddress += pageRoundUp(size);
+
+    // Will propably never happen
+    if(DeviceHeap::currentAddress >= DEVICE_HEAP_END)
+        Log(Error, "Device heap is getting to big!");
+    
+    return ret;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/memory/fifostream.cpp b/kernelz/src/system/memory/fifostream.cpp
new file mode 100644
index 0000000..276d49e
--- /dev/null
+++ b/kernelz/src/system/memory/fifostream.cpp
@@ -0,0 +1,56 @@
+#include <system/memory/fifostream.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+FIFOStream::FIFOStream(int capacity)
+{
+    this->buffer = new char[capacity * sizeof(char)];
+    this->buffer_end = (char*)this->buffer + capacity * sizeof(char);
+    this->count = 0;
+    this->capacity = capacity;
+    this->head = this->buffer;
+    this->tail = this->buffer;
+}
+
+FIFOStream::~FIFOStream()
+{
+    delete this->buffer;
+}
+
+void FIFOStream::Write(char item)
+{
+    if(this->count == this->capacity) {
+        Log(Error, "Item count has reached capacity for this stream, data will be ignored. Capacity=%d", this->capacity);
+        return;
+    }
+
+    MemoryOperations::memcpy((void*)this->head, (void*)&item, sizeof(char));
+    this->head = (char*)(this->head + sizeof(char));
+    if(this->head == this->buffer_end)
+        this->head = this->buffer;
+    
+    this->count++;
+}
+
+char FIFOStream::Read()
+{
+    char result = 0;
+    if(this->count == 0)
+        return result;
+
+    MemoryOperations::memcpy((void*)&result, (void*)this->tail, sizeof(char));
+    this->tail = (char*)(this->tail + sizeof(char));
+    if(this->tail == this->buffer_end)
+        this->tail = this->buffer;
+
+    this->count--;
+    return result;
+}
+
+int FIFOStream::Available()
+{
+    return this->count;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/memory/heap.cpp b/kernelz/src/system/memory/heap.cpp
new file mode 100644
index 0000000..3cf2a3c
--- /dev/null
+++ b/kernelz/src/system/memory/heap.cpp
@@ -0,0 +1,231 @@
+#include <system/memory/heap.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+uint32_t KernelHeap::startAddress = 0;
+uint32_t KernelHeap::endAddress = 0;
+MemoryHeader* KernelHeap::firstHeader = 0;
+MutexLock KernelHeap::heapMutex = MutexLock();
+
+void KernelHeap::Initialize(uint32_t start, uint32_t end)
+{
+    Log(Info, "KernelHeap: Initializing (Size of MemoryHeader = %d)", sizeof(MemoryHeader));
+    if (start % PAGE_SIZE != 0 || end % PAGE_SIZE != 0) {
+        Log(Error, "KernelHeap: Start or End is not page aligned");
+        System::Panic();
+    }
+
+    // Update static variables
+    KernelHeap::startAddress = start;
+    KernelHeap::endAddress = end;
+
+    // Initialize first memoryheader with right variables
+    firstHeader = (MemoryHeader*)start;
+    firstHeader->allocated = false;
+    firstHeader->prev = 0;
+    firstHeader->next = 0;
+    firstHeader->size = end - start - sizeof(MemoryHeader); // Make this the size of the whole memory range   
+    firstHeader->magic = MEMORY_HEADER_MAGIC;
+}
+
+MemoryHeader* KernelHeap::FirstFree(uint32_t size)
+{
+    MemoryHeader* block = firstHeader;
+    while(block != 0 && block->magic == MEMORY_HEADER_MAGIC) {
+        if(block->allocated || block->size < size) {
+            block = block->next;
+            continue; // Continue search
+        }
+
+        return block; // This block seems fine
+    }
+    return 0;
+}
+
+void* KernelHeap::InternalAllocate(uint32_t size)
+{
+    // Set Mutex
+    heapMutex.Lock();
+
+    // First we align the size to a 4-byte boundary
+    // This makes accessing memory a bit faster
+    size = align_up(size, sizeof(uint32_t));
+
+    // Search for free block
+    MemoryHeader* freeBlock = FirstFree(size);
+    
+    // Check for error
+    if(freeBlock == 0) {
+        Log(Error, "KernelHeap: Out of Heap space!. This should never happen!");
+        System::Panic();
+        heapMutex.Unlock(); // Not really required but perhaps panic function will return in the future
+        return 0;
+    }
+
+    // Check if we have space for a extra memory block (and it is worth it)
+    if(freeBlock->size >= (size + sizeof(MemoryHeader) + MINIMAL_SPLIT_SIZE))
+    {
+        // Split current found block into 2 seperate ones
+        MemoryHeader* nextBlock = (MemoryHeader*)((uint32_t)freeBlock + size + sizeof(MemoryHeader));
+
+        // Setup new block
+        nextBlock->allocated = false;
+        nextBlock->size = freeBlock->size - size - sizeof(MemoryHeader);
+        nextBlock->prev = freeBlock;
+        nextBlock->next = freeBlock->next;
+        if(freeBlock->next != 0)
+            freeBlock->next->prev = nextBlock;
+
+        // Setup magic number for new block
+        nextBlock->magic = MEMORY_HEADER_MAGIC;
+
+        // And point new block to next memory block
+        freeBlock->next = nextBlock;
+    }
+
+    freeBlock->allocated = true;
+    freeBlock->size = size;
+    
+    // Free mutex
+    heapMutex.Unlock();
+
+    return (void*)((uint32_t)freeBlock + sizeof(MemoryHeader));
+}
+void KernelHeap::free(void* ptr)
+{
+    // Set mutex
+    heapMutex.Lock();
+
+    // Get pointer to memory block associated with pointer
+    MemoryHeader* block = (MemoryHeader*)((uint32_t)ptr - sizeof(MemoryHeader));
+
+    // Check if block is valid
+    if(block->magic != MEMORY_HEADER_MAGIC || !block->allocated) {
+        Log(Error, "KernelHeap: Block is not allocated or magic is not correct");
+        Log(Error, "Block = %x Alloc = %d Size = %d", (uint32_t)block, block->allocated, block->size);
+        System::Panic();
+    }
+    
+    // Block is not allocated anymore
+    block->allocated = false;
+
+    // Check if we can merge this block with the previous one
+    if(block->prev && !block->prev->allocated)
+    {
+        // Make previous block skip this block and point to the next one
+        block->prev->next = block->next;
+
+        // Increase size with this blocks size
+        block->prev->size += block->size + sizeof(MemoryHeader);
+        
+        // Update prev pointer for next block
+        if(block->next != 0)
+            block->next->prev = block->prev;
+        
+        // We are now the previous block
+        block = block->prev;
+    }
+    
+    // Check if we can merge this block with the next one
+    if(block->next && !block->next->allocated)
+    {
+        // Increase this blocks size
+        block->size += block->next->size + sizeof(MemoryHeader);
+
+        // Update next pointer
+        block->next = block->next->next;
+
+        // Update prev pointer for next block
+        if(block->next != 0)
+            block->next->prev = block;
+    }
+
+    // Unlock mutex
+    heapMutex.Unlock();
+}
+
+void* KernelHeap::malloc(uint32_t size, uint32_t* physReturn)
+{
+    void* addr = InternalAllocate(size);
+    if(physReturn != 0)
+    {
+        PageTableEntry* page = VirtualMemoryManager::GetPageForAddress((uint32_t)addr, 0);
+        *physReturn = (page->frame * PAGE_SIZE) + ((uint32_t)addr & 0xFFF);
+    }
+    return addr;
+}
+
+void* KernelHeap::alignedMalloc(uint32_t size, uint32_t align, uint32_t* physReturn)
+{
+    void* ptr = 0;
+    if(!(align & (align - 1)) == 0)
+        return 0;
+
+    if(align > 0 && size > 0)
+    {
+        uint32_t hdr_size = sizeof(uint16_t) + (align - 1);
+        uint32_t phys = 0;
+        void* block = malloc(size + hdr_size, &phys);
+        if(block)
+        {
+            ptr = (void*)align_up(((uintptr_t)block + sizeof(uint16_t)), align);
+            if(physReturn)
+                *physReturn = (uint32_t)VirtualMemoryManager::virtualToPhysical(ptr);
+
+            *((uint16_t*)ptr - 1) = (uint16_t)((uintptr_t)ptr - (uintptr_t)block);
+        }
+    }
+
+    return ptr;
+}
+void KernelHeap::allignedFree(void* ptr)
+{   
+    if(ptr == 0)
+        return;
+
+    uint16_t offset = *((uint16_t*)ptr - 1);
+    void* newPtr = (void*)((common::uint8_t*)ptr - offset);
+    free(newPtr);
+}
+
+bool KernelHeap::CheckForErrors()
+{
+    // Not sure if this is needed, but why not?
+    heapMutex.Lock();
+
+    MemoryHeader* block = firstHeader;
+    while(block != 0) {
+        if(((block->magic != MEMORY_HEADER_MAGIC) || (((uint32_t)block->next < startAddress) || ((uint32_t)block->next > endAddress))) && (block->next != 0)) {
+            heapMutex.Unlock();
+            
+            Log(Error, "Memory corrupted at: %x (magic = %d, next = %x, alloc = %d)", (uint32_t)block, block->magic, (uint32_t)block->next, block->allocated);
+            return true;
+        }
+        block = block->next;
+    }
+    heapMutex.Unlock();
+    return false;
+}
+
+uint32_t KernelHeap::UsedMemory()
+{
+    uint32_t result = 0;
+
+    MemoryHeader* block = firstHeader;
+    while(block != 0) {
+        if(((block->magic != MEMORY_HEADER_MAGIC) || (((uint32_t)block->next < startAddress) || ((uint32_t)block->next > endAddress))) && (block->next != 0)) {
+            Log(Error, "Memory corrupted at: %x (magic = %d, next = %x, alloc = %d)", (uint32_t)block, block->magic, (uint32_t)block->next, block->allocated);
+            return result;
+        }
+        if(block->allocated)
+            result += block->size;
+        
+        block = block->next;
+    }
+
+    return result;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/memory/sharedmem.cpp b/kernelz/src/system/memory/sharedmem.cpp
new file mode 100644
index 0000000..d7f67a1
--- /dev/null
+++ b/kernelz/src/system/memory/sharedmem.cpp
@@ -0,0 +1,113 @@
+#include <system/memory/sharedmem.h>
+#include <core/virtualmemory.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+bool SharedMemory::CreateSharedRegion(Process* proc1, Process* proc2, uint32_t virtStart, uint32_t len)
+{
+    return SharedMemory::CreateSharedRegion(proc1, proc2, virtStart, virtStart, len);
+}
+bool SharedMemory::CreateSharedRegion(Process* proc1, Process* proc2, uint32_t virtStart1, uint32_t virtStart2, uint32_t len)
+{
+    if(proc1 == 0 || proc2 == 0 || len <= 0)
+        return false;
+
+    //Since we are messing with pagetables we need to disable the scheduler
+    System::scheduler->Enabled = false;
+
+    //Allocate the required memory block
+    uint32_t physMemStart = (uint32_t)PhysicalMemoryManager::AllocateBlocks(len / PAGE_SIZE);
+    Log(Info, "Allocated shared memory block of %d bytes at %x", len, physMemStart);
+
+    uint32_t oldCR3 = VirtualMemoryManager::GetPageDirectoryAddress();
+    //Check if we are running proc1 already, so we don't have to switch the pagedir
+    if(oldCR3 != proc1->pageDirPhys) {
+        VirtualMemoryManager::SwitchPageDirectory(proc1->pageDirPhys);
+    }
+    
+    //Map the memory region for process 1
+    for(uint32_t memAddr = 0; memAddr < len; memAddr += PAGE_SIZE)
+    {
+        //Get or create page for address
+        PageTableEntry* page = VirtualMemoryManager::GetPageForAddress(memAddr + virtStart1, true, true, true);
+
+        page->frame = (physMemStart + memAddr) / PAGE_SIZE; //Assign the correct memory address
+        page->readWrite = 1;
+        page->isUser = 1;
+        page->present = 1;
+    }
+
+    //Switch to process 2 pagedir
+    VirtualMemoryManager::SwitchPageDirectory(proc2->pageDirPhys);
+
+    //Map the memory region for process 2
+    for(uint32_t memAddr = 0; memAddr < len; memAddr += PAGE_SIZE)
+    {
+        //Get or create page for address
+        PageTableEntry* page = VirtualMemoryManager::GetPageForAddress(memAddr + virtStart2, true, true, true);
+
+        page->frame = (physMemStart + memAddr) / PAGE_SIZE; //Assign the correct memory address
+        page->readWrite = 1;
+        page->isUser = 1;
+        page->present = 1;
+    }
+
+    //Restore page directory
+    VirtualMemoryManager::SwitchPageDirectory(oldCR3);
+
+    System::scheduler->Enabled = true;
+    
+    return true;
+}
+bool SharedMemory::RemoveSharedRegion(Process* proc1, Process* proc2, uint32_t virtStart, uint32_t len)
+{
+    return RemoveSharedRegion(proc1, proc2, virtStart, virtStart, len);
+}
+bool SharedMemory::RemoveSharedRegion(Process* proc1, Process* proc2, uint32_t virtStart1, uint32_t virtStart2, uint32_t len)
+{
+    if(proc1 == 0 || proc2 == 0 || len <= 0)
+        return false;
+
+    Log(Info, "Removing shared memory between %s and %s from %x and %x with length %d", proc1->fileName, proc2->fileName, virtStart1, virtStart2, len);
+
+    //Since we are messing with pagetables we need to disable the scheduler
+    System::scheduler->Enabled = false;
+
+    uint32_t oldCR3 = VirtualMemoryManager::GetPageDirectoryAddress();
+    //Check if we are running proc1 already, so we don't have to switch the pagedir
+    if(oldCR3 != proc1->pageDirPhys) {
+        VirtualMemoryManager::SwitchPageDirectory(proc1->pageDirPhys);
+    }
+    
+    //Map the memory region for process 1
+    for(uint32_t memAddr = 0; memAddr < len; memAddr += PAGE_SIZE)
+    {
+        //Get or create page for address
+        PageTableEntry* page = VirtualMemoryManager::GetPageForAddress(memAddr + virtStart1, false);
+        if(page != 0)
+            VirtualMemoryManager::FreePage(page);
+    }
+
+    //Switch to process 2 pagedir
+    VirtualMemoryManager::SwitchPageDirectory(proc2->pageDirPhys);
+
+    //Map the memory region for process 2
+    for(uint32_t memAddr = 0; memAddr < len; memAddr += PAGE_SIZE)
+    {
+        //Get or create page for address
+        PageTableEntry* page = VirtualMemoryManager::GetPageForAddress(memAddr + virtStart2, false);
+        if(page != 0)
+            VirtualMemoryManager::FreePage(page);
+    }
+
+    //Restore page directory
+    VirtualMemoryManager::SwitchPageDirectory(oldCR3);
+
+    System::scheduler->Enabled = true;
+    
+    return true;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/memory/stream.cpp b/kernelz/src/system/memory/stream.cpp
new file mode 100644
index 0000000..6f7ac5f
--- /dev/null
+++ b/kernelz/src/system/memory/stream.cpp
@@ -0,0 +1,26 @@
+#include <system/memory/stream.h>
+#include <system/log.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+Stream::Stream() {}
+Stream::~Stream() {}
+
+char Stream::Read()
+{
+    Log(Error, "Virtual stream function called");
+    return 0;
+}
+
+void Stream::Write(char byte)
+{
+    Log(Error, "Virtual stream function called");
+}
+
+int Stream::Available()
+{
+    Log(Error, "Virtual stream function called");
+    return 0;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/serialport.cpp b/kernelz/src/system/serialport.cpp
new file mode 100644
index 0000000..43f1630
--- /dev/null
+++ b/kernelz/src/system/serialport.cpp
@@ -0,0 +1,60 @@
+#include <system/serialport.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+/*/////////////////
+// Static variable initialisations
+/*/////////////////
+COMPort Serialport::PortAddress = COMPort::COM1;
+bool Serialport::Initialized = false;
+
+/*/////////////////
+// Private functions
+/*/////////////////
+int Serialport::SerialReceiveReady()
+{
+    return inportb(PortAddress + 5) & 1;
+}
+int Serialport::SerialSendReady()
+{
+    return inportb(PortAddress + 5) & 0x20;
+}
+
+/*/////////////////
+// Public functions
+/*/////////////////
+char Serialport::Read()
+{
+    while (SerialReceiveReady() == 0);
+
+    return inportb(PortAddress);
+}
+void Serialport::Write(char a)
+{
+    while (SerialSendReady() == 0);
+
+    outportb(PortAddress, a);
+}
+void Serialport::WriteStr(char* str)
+{
+    for(int i = 0; str[i] != '\0'; ++i)
+        Write(str[i]);
+}
+
+void Serialport::Init(COMPort port)
+{
+    Serialport::PortAddress = port;
+
+    outportb(PortAddress + 1, 0x00);    // Disable all interrupts
+    outportb(PortAddress + 3, 0x80);    // Enable DLAB (set baud rate divisor)
+    outportb(PortAddress + 0, 0x03);    // Set divisor to 3 (lo byte) 38400 baud
+    outportb(PortAddress + 1, 0x00);    //                  (hi byte)
+    outportb(PortAddress + 3, 0x03);    // 8 bits, no parity, one stop bit
+    outportb(PortAddress + 2, 0xC7);    // Enable FIFO, clear them, with 14-byte threshold
+    outportb(PortAddress + 4, 0x0B);    // IRQs enabled, RTS/DSR set
+
+    Serialport::Initialized = true;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/syscalls/implementations/cactusos.cpp b/kernelz/src/system/syscalls/implementations/cactusos.cpp
new file mode 100644
index 0000000..edfd816
--- /dev/null
+++ b/kernelz/src/system/syscalls/implementations/cactusos.cpp
@@ -0,0 +1,416 @@
+#include <system/syscalls/implementations/cactusos.h>
+
+#include <../../lib/include/syscall.h>
+#include <../../lib/include/datetime.h>
+
+#include <system/system.h>
+#include <system/tasking/ipcmanager.h>
+#include <system/tasking/lock.h>
+#include <core/power.h>
+#include <system/listings/listingcontroller.h>
+#include <system/listings/systeminfo.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+MutexLock stdOutStream;
+extern PowerRequest powerRequestState; //Defined in kernel.cpp
+
+CPUState* CactusOSSyscalls::HandleSyscall(CPUState* state)
+{
+    LIBCactusOS::Systemcalls sysCall = (LIBCactusOS::Systemcalls)state->EAX;
+    Process* proc = System::scheduler->CurrentProcess();
+
+    switch (sysCall)
+    {
+        case LIBCactusOS::SYSCALL_EXIT:
+            Log(Info, "Process %d %s exited with code %d", proc->id, proc->fileName, (int)state->EBX);
+            ProcessHelper::RemoveProcess(proc);
+            state->EAX = SYSCALL_RET_SUCCES;
+            break;
+        
+        /////////////
+        // Logging
+        /////////////
+
+        case LIBCactusOS::SYSCALL_LOG:
+            Log((LogLevel)state->EBX, (const char* __restrict__)state->ECX);
+            state->EAX = SYSCALL_RET_SUCCES;
+            break;
+        case LIBCactusOS::SYSCALL_PRINT:
+            Print((const char*)state->EBX, state->ECX);
+            break;
+        
+        /////////////
+        // VFS
+        /////////////
+        
+        case LIBCactusOS::SYSCALL_FILE_EXISTS:
+            state->EAX = System::vfs->FileExists((char*)state->EBX);
+            break;
+        case LIBCactusOS::SYSCALL_DIR_EXISTS:
+            state->EAX = System::vfs->DirectoryExists((char*)state->EBX);
+            break;
+        case LIBCactusOS::SYSCALL_GET_FILESIZE:
+            state->EAX = System::vfs->GetFileSize((char*)state->EBX);
+            break;
+        case LIBCactusOS::SYSCALL_READ_FILE:
+            state->EAX = System::vfs->ReadFile((char*)state->EBX, (uint8_t*)state->ECX);
+            break;
+        case LIBCactusOS::SYSCALL_WRITE_FILE:
+            state->EAX = System::vfs->WriteFile((char*)state->EBX, (uint8_t*)state->ECX, state->EDX, (bool)state->ESI);
+            break;
+        case LIBCactusOS::SYSCALL_CREATE_FILE:
+            state->EAX = System::vfs->CreateFile((char*)state->EBX);
+            break;
+        case LIBCactusOS::SYSCALL_CREATE_DIRECTORY:
+            state->EAX = System::vfs->CreateDirectory((char*)state->EBX);
+            break;
+        case LIBCactusOS::SYSCALL_EJECT_DISK:
+            state->EAX = System::vfs->EjectDrive((char*)state->EBX);
+            break;
+
+        //////////////
+        // GUI
+        //////////////
+        
+        case LIBCactusOS::SYSCALL_GUI_GETLFB:
+            VirtualMemoryManager::mapVirtualToPhysical((void*)System::gfxDevice->framebufferPhys, (void*)state->EBX, pageRoundUp(System::gfxDevice->GetBufferSize()), false, true);
+            state->EAX = SYSCALL_RET_SUCCES;
+            Log(Info, "Mapped LFB for process %d to virtual address %x", proc->id, state->EBX);
+            break;
+
+        case LIBCactusOS::SYSCALL_GET_SCREEN_PROPERTIES:
+            if(System::gfxDevice) {
+                *((int*)state->EBX) = System::gfxDevice->width;
+                *((int*)state->ECX) = System::gfxDevice->height;
+
+                state->EAX = SYSCALL_RET_SUCCES;
+            }
+            else
+                state->EAX = SYSCALL_RET_ERROR;
+    
+            break;
+        
+        //////////////
+        // Memory
+        //////////////
+
+        case LIBCactusOS::SYSCALL_GET_HEAP_START:
+            state->EAX = proc->heap.heapStart;
+            break;
+        case LIBCactusOS::SYSCALL_GET_HEAP_END:
+            state->EAX = proc->heap.heapEnd;
+            break;
+        case LIBCactusOS::SYSCALL_SET_HEAP_SIZE:
+            ProcessHelper::UpdateHeap(proc, state->EBX);
+            state->EAX = SYSCALL_RET_SUCCES;
+            break;
+        case LIBCactusOS::SYSCALL_CREATE_SHARED_MEM:
+            {
+                Process* proc2 = ProcessHelper::ProcessById(state->EBX);
+                if(proc2 == 0) {
+                    state->EAX = SYSCALL_RET_ERROR;
+                    break;
+                }
+                state->EAX = SharedMemory::CreateSharedRegion(proc, proc2, state->ECX, state->EDX, state->ESI);
+            }
+            break;
+        case LIBCactusOS::SYSCALL_REMOVE_SHARED_MEM:
+            {
+                Process* proc2 = ProcessHelper::ProcessById(state->EBX);
+                if(proc2 == 0) {
+                    state->EAX = SYSCALL_RET_ERROR;
+                    break;
+                }
+                state->EAX = SharedMemory::RemoveSharedRegion(proc, proc2, state->ECX, state->EDX, state->ESI);
+            }
+            break;
+        case LIBCactusOS::SYSCALL_MAP_SYSINFO:
+            {
+                //Put systeminfo into address space
+                uint32_t sysInfoPhys = (uint32_t)VirtualMemoryManager::virtualToPhysical((void*)System::systemInfo);
+                PageTableEntry* sysInfoPage = VirtualMemoryManager::GetPageForAddress(state->EBX, true, true, proc->isUserspace);
+                sysInfoPage->readWrite = 1;
+                sysInfoPage->isUser = proc->isUserspace;
+                sysInfoPage->frame = sysInfoPhys / PAGE_SIZE;
+                sysInfoPage->present = 1;
+
+                state->EAX = SYSCALL_RET_SUCCES;
+            }
+            break;
+        
+        //////////////
+        // Scheduler
+        //////////////
+        
+        case LIBCactusOS::SYSCALL_RUN_PROC:
+            {    
+                char* applicationPath = (char*)state->EBX;
+                bool block = (bool)state->ECX;
+                if(System::vfs->FileExists(applicationPath) == false) {
+                    state->EAX = SYSCALL_RET_ERROR;
+                    break;
+                }
+
+                Process* newProc = ProcessHelper::Create(applicationPath);
+                if(newProc != 0) {
+                    if(block) {
+                        newProc->Threads[0]->state = Blocked;
+                        newProc->Threads[0]->blockedState = Unkown;
+                    }
+                    else
+                        newProc->Threads[0]->state = Started;
+                    
+                    
+                    System::scheduler->AddThread(newProc->Threads[0], false);
+                    state->EAX = newProc->id;
+                }
+                else
+                    state->EAX = SYSCALL_RET_ERROR;
+            }
+            break;
+        case LIBCactusOS::SYSCALL_SLEEP_MS:
+            {
+                Thread* currentThread = System::scheduler->CurrentThread();
+                currentThread->timeDelta = state->EBX;
+                System::scheduler->Block(currentThread, BlockedState::SleepMS);
+            }
+            break;
+        case LIBCactusOS::SYSCALL_START_THREAD:
+            {     
+                Log(Info, "Creating new thread for proc %d %s, jumps to %x", proc->id, proc->fileName, state->EBX);
+                //Create new thread
+                Thread* newThread = ThreadHelper::CreateFromFunction((void (*)())state->EBX, false, 514, proc);
+                
+                //Create memory for stack
+                for(uint32_t i = (uint32_t)newThread->userStack; i < ((uint32_t)newThread->userStack + newThread->userStackSize); i+=PAGE_SIZE)
+                    VirtualMemoryManager::AllocatePage(VirtualMemoryManager::GetPageForAddress(i, true, true, true), false, true);
+
+                //Assign parent
+                newThread->parent = proc;
+                //Set it as started
+                newThread->state = Started;
+                //Add it to the parent process
+                proc->Threads.push_back(newThread);
+                //Add it to the scheduler
+                System::scheduler->AddThread(newThread);
+                //Force a task switch if the application requested it
+                if((bool)state->ECX)
+                    System::scheduler->ForceSwitch();
+            }
+            break;
+        case LIBCactusOS::SYSCALL_YIELD:
+            System::scheduler->ForceSwitch();
+            break;
+        case LIBCactusOS::SYSCALL_PROC_EXIST:
+            {
+                Process* proc = ProcessHelper::ProcessById(state->EBX);
+                if(proc != 0)
+                    state->EAX = true;
+                else
+                    state->EAX = false;
+            }
+            break;
+        case LIBCactusOS::SYSCALL_UNBLOCK:
+            {
+                Process* proc = ProcessHelper::ProcessById(state->EBX);
+                if(proc != 0 && (int)state->ECX < proc->Threads.size())
+                    proc->Threads[state->ECX]->state = Started;
+            }
+            break;
+        case LIBCactusOS::SYSCALL_SET_SCHEDULER:
+            {
+                bool active = (bool)state->EBX;
+                System::scheduler->Enabled = active;
+            }
+            break;
+        case LIBCactusOS::SYSCALL_GET_ARGUMENTS:
+            {
+                char* target = (char*)state->EBX;
+                char* src = proc->args;
+                if(!src)
+                    break;
+                
+                MemoryOperations::memcpy(target, src, String::strlen(src) <= PROC_ARG_LEN_MAX ? String::strlen(src) : PROC_ARG_LEN_MAX);
+            }
+            break;
+
+        //////////////
+        // IPC
+        //////////////
+        
+        case LIBCactusOS::SYSCALL_IPC_SEND:
+            IPCManager::HandleSend(state, proc);
+            break;
+        case LIBCactusOS::SYSCALL_IPC_RECEIVE:
+            IPCManager::HandleReceive(state, proc);
+            break;
+        case LIBCactusOS::SYSCALL_IPC_AVAILABLE:
+            state->EAX = proc->ipcMessages.size();
+            break;
+
+        //////////////
+        // Clock
+        //////////////
+
+        case LIBCactusOS::SYSCALL_GET_TICKS:
+            {
+                uint64_t* ticksPtr = (uint64_t*)state->EBX;
+                *ticksPtr = System::pit->Ticks();
+                state->EAX = SYSCALL_RET_SUCCES;
+            }
+            break;
+        case LIBCactusOS::SYSCALL_GET_DATETIME:
+            {
+                LIBCactusOS::DateTime* resultPtr = (LIBCactusOS::DateTime*)state->EBX;
+                resultPtr->Day = System::rtc->GetDay();
+                resultPtr->Hours = System::rtc->GetHour();
+                resultPtr->Minutes = System::rtc->GetMinute();
+                resultPtr->Month = System::rtc->GetMonth();
+                resultPtr->Seconds = System::rtc->GetSecond();
+                resultPtr->Year = System::rtc->GetYear();
+                state->EAX = SYSCALL_RET_SUCCES;
+            }
+            break;
+        
+        //////////////
+        // Power
+        //////////////
+
+        case LIBCactusOS::SYSCALL_SHUTDOWN:
+            Log(Info, "Process requested shutdown");
+            powerRequestState = Shutdown; //Tell kernel process to shutdown on next schedule
+            
+            state->EAX = SYSCALL_RET_SUCCES;
+            break;
+        case LIBCactusOS::SYSCALL_REBOOT:
+            Log(Info, "Process requested reboot");
+            powerRequestState = Reboot; //Tell kernel process to reboot on next schedule
+
+            state->EAX = SYSCALL_RET_SUCCES;
+            break;
+        
+        //////////////
+        // STDIO
+        //////////////        
+
+        case LIBCactusOS::SYSCALL_READ_STDIO:
+            if(proc->stdInput != 0)
+            {
+                while (proc->stdInput->Available() <= 0) //TODO: Use blocking here
+                    System::scheduler->ForceSwitch();
+                state->EAX = proc->stdInput->Read();
+            }
+            else
+                Log(Warning, "StdIn is zero for process %s", proc->fileName);
+
+            break;
+        case LIBCactusOS::SYSCALL_WRITE_STDIO:
+            if(proc->stdOutput != 0) {
+                char* data = (char*)state->EBX;
+                if(data == 0 || state->ECX <= 0)
+                    break;
+                
+                //This makes sure output text does not get mixed up when interrupted during writing.
+                if(proc->stdOutput == System::ProcStandardOut)
+                    stdOutStream.Lock();
+
+                for(uint32_t d = 0; d < state->ECX; d++)
+                    proc->stdOutput->Write(data[d]);
+
+                //Don't forget to unlock
+                if(proc->stdOutput == System::ProcStandardOut)
+                    stdOutStream.Unlock();
+            }
+            else
+                Log(Warning, "StdOut is zero for process %s", proc->fileName);
+            
+            break;
+        case LIBCactusOS::SYSCALL_REDIRECT_STDIO:
+            {
+                int fromID = state->EBX;
+                int toID = state->ECX;
+
+                if(fromID == -1) //Redirect to keyboard
+                {
+                    Process* toProc = ProcessHelper::ProcessById(toID);
+                    
+                    Log(Info, "Redirecting keyboard stream to StdIn of %s", toProc->fileName);
+                    toProc->stdInput = System::keyboardManager;
+                    break;
+                }
+
+                Process* fromProc = ProcessHelper::ProcessById(fromID);
+                Process* toProc = ProcessHelper::ProcessById(toID);
+                if(fromProc == 0 || toProc == 0)
+                    break;
+
+                Log(Info, "Redirecting StdOut from %s to StdIn of %s", fromProc->fileName, toProc->fileName);
+
+                if(toProc->stdInput == System::keyboardManager || toProc->stdInput == 0)
+                    toProc->stdInput = new FIFOStream();
+                
+                fromProc->stdOutput = toProc->stdInput;
+            }
+            break;
+        case LIBCactusOS::SYSCALL_STDIO_AVAILABLE:
+            if(proc->stdInput != 0)
+                state->EAX = proc->stdInput->Available();
+            else
+                state->EAX = 0;
+            
+            break;
+
+        //////////////
+        // Listings
+        //////////////        
+
+        case LIBCactusOS::SYSCALL_BEGIN_LISTING:
+            {
+                int type = state->EBX;
+                if(!(System::listings->size() > type)) {
+                    state->EAX = 0;
+                    break;
+                }
+                    
+                state->EAX = System::listings->GetAt(type)->BeginListing(System::scheduler->CurrentThread(), state->ECX);
+            }
+            break;
+        case LIBCactusOS::SYSCALL_LISTING_ENTRY:
+            {
+                int type = state->EBX;
+                if(!(System::listings->size() > type)) {
+                    state->EAX = 0;
+                    break;
+                }
+
+                state->EAX = System::listings->GetAt(type)->GetEntry(System::scheduler->CurrentThread(), (int)state->ECX, state->EDX);
+            }
+            break;
+        case LIBCactusOS::SYSCALL_END_LISTING:
+            {
+                int type = state->EBX;
+                if(!(System::listings->size() > type)) {
+                    state->EAX = 0;
+                    break;
+                }
+
+                System::listings->GetAt(type)->EndListing(System::scheduler->CurrentThread());
+            }
+            break;
+        case LIBCactusOS::SYSCALL_GET_SYSINFO_VALUE:
+            {
+                state->EAX = SystemInfoManager::HandleSysinfoRequest((void*)state->EBX, state->EDX, state->ECX, (bool)state->ESI);
+            }
+            break;
+        default:
+            Log(Warning, "Got unkown syscall %d from process %d", sysCall, proc->id);
+            state->EAX = SYSCALL_RET_ERROR;
+            break;
+    }
+
+    return state;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/syscalls/implementations/linux.cpp b/kernelz/src/system/syscalls/implementations/linux.cpp
new file mode 100644
index 0000000..ec273ec
--- /dev/null
+++ b/kernelz/src/system/syscalls/implementations/linux.cpp
@@ -0,0 +1,27 @@
+#include <system/syscalls/implementations/linux.h>
+
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+CPUState* LinuxSyscalls::HandleSyscall(CPUState* state)
+{
+    switch (state->EAX)
+    {
+        case 0xFFFF: //We use this systemcall for setting the CactusOS Syscall implementation for this process since linux is the default one
+            //From now on this uses CactusOS Systemcalls
+            System::scheduler->CurrentProcess()->syscallID = 1;
+            //Return a succes
+            state->EAX = System::scheduler->CurrentProcess()->id; //Return the pid
+            break;
+    
+        default:
+            state->EAX = 0;
+            break;
+    }
+
+    return state;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/syscalls/syscalls.cpp b/kernelz/src/system/syscalls/syscalls.cpp
new file mode 100644
index 0000000..0a90789
--- /dev/null
+++ b/kernelz/src/system/syscalls/syscalls.cpp
@@ -0,0 +1,41 @@
+#include <system/syscalls/syscalls.h>
+
+#include <system/system.h>
+#include <system/syscalls/implementations/cactusos.h>
+#include <system/syscalls/implementations/linux.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+using namespace CactusOS::core;
+
+SystemCallHandler::SystemCallHandler()
+: InterruptHandler(0x80) {
+
+}
+
+uint32_t SystemCallHandler::HandleInterrupt(uint32_t esp)
+{
+    //Interrupts need to be enabled for io system calls
+    InterruptDescriptorTable::EnableInterrupts();
+
+    int ID = System::scheduler->CurrentProcess()->syscallID;
+
+    switch (ID)
+    {
+        case 0: //Linux Systemcall
+            return (uint32_t)LinuxSyscalls::HandleSyscall((CPUState*)esp);
+            break;
+        case 1: //CactusOS Systemcall
+            return (uint32_t)CactusOSSyscalls::HandleSyscall((CPUState*)esp);
+            break;   
+        default:
+            Log(Error, "Process %d has unkown syscallID %d", System::scheduler->CurrentProcess()->syscallID, ID);
+            break;
+    }
+
+    //Restore previous state
+    InterruptDescriptorTable::DisableInterrupts();
+
+    return esp;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/system.cpp b/kernelz/src/system/system.cpp
new file mode 100644
index 0000000..344b17d
--- /dev/null
+++ b/kernelz/src/system/system.cpp
@@ -0,0 +1,162 @@
+#include <system/system.h>
+#include <system/listings/directorylisting.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+using namespace LIBCactusOS;
+
+multiboot_info_t* System::mbi = 0;
+PIT* System::pit = 0;
+RTC* System::rtc = 0;
+DMAController* System::dma = 0;
+SMBIOS* System::smbios = 0;
+Virtual8086Manager* System::vm86Manager = 0;
+Virtual8086Monitor* System::vm86Monitor = 0;
+GraphicsDevice* System::gfxDevice = 0;
+EDID* System::edid = 0;
+PCIController* System::pci = 0;
+DriverManager* System::driverManager = 0;
+DiskManager* System::diskManager = 0;
+VFSManager* System::vfs = 0;
+Scheduler* System::scheduler = 0;
+APMController* System::apm = 0;
+SystemCallHandler* System::syscalls = 0;
+SharedSystemInfo* System::systemInfo = 0;
+
+ScreenMode System::screenMode = ScreenMode::TextMode;
+bool System::gdbEnabled = false;
+bool System::setupMode = false;
+KeyboardManager* System::keyboardManager = 0;
+Stream* System::ProcStandardOut = 0;
+List<ListingController*>* System::listings = 0;
+USBManager* System::usbManager = 0;
+SymbolDebugger* System::kernelDebugger = 0;
+#if BOCHS_GFX_HACK
+bool System::isBochs = false; //are we running inside bochs
+#endif
+System::SYSTEM_STATS System::statistics = {};
+
+void System::Start()
+{
+    BootConsole::ForegroundColor = VGA_COLOR_BLACK;
+    Log(Info, "Adding system components");
+    
+    System::rtc = new RTC();
+    Log(Info, "- RTC [Done]     (%x)", (uint32_t)System::rtc);
+
+    InterruptDescriptorTable::DisableInterrupts();
+    System::pit = new PIT();
+    InterruptDescriptorTable::EnableInterrupts();
+    Log(Info, "- PIT [Done]     (%x)", (uint32_t)System::pit);
+
+    System::dma = new DMAController();
+    Log(Info, "- DMA [Done]     (%x)", (uint32_t)System::dma);
+
+    System::smbios = new SMBIOS();
+    Log(Info, "- SMBIOS [Done]     (%x)", (uint32_t)System::smbios);
+
+    Log(Info, "Adding Virtual 8086");
+    System::vm86Manager = new Virtual8086Manager();
+    System::vm86Monitor = new Virtual8086Monitor();
+
+    // The graphics component is added here but not used right away, we don't need to be in video mode so early.
+    System::gfxDevice = GraphicsDevice::GetBestDevice();
+    Log(Info, "- GFX [Done]     (%x)", (uint32_t)System::gfxDevice);
+
+    // Check for monitor EDID
+    System::edid = new EDID();
+    Log(Info, "- EDID [Done]     (%x)", (uint32_t)System::edid);
+    System::edid->AcquireEDID();
+
+    Log(Info, "Loading Initial Ramdisk");
+    InitialRamDisk::Initialize(System::mbi);
+
+    System::pci = new PCIController();
+    Log(Info, "- PCI [Done]     (%x)", (uint32_t)System::pci);
+
+    System::pci->PopulateDeviceList();
+
+    Log(Info, "Starting Driver Manager");
+    System::driverManager = new DriverManager();
+
+    Log(Info, "Starting Disk Manager");
+    System::diskManager = new DiskManager();
+
+    Log(Info, "Starting Keyboard Manager");
+    System::keyboardManager = new KeyboardManager();
+
+    Log(Info, "Starting Scheduler");
+    InterruptDescriptorTable::DisableInterrupts();
+    System::scheduler = new Scheduler();
+    InterruptDescriptorTable::EnableInterrupts();
+
+    Log(Info, "Starting USB Manager");
+    System::usbManager = new USBManager();
+    Log(Info, "Initializing Virtual File System");
+    System::vfs = new VFSManager();
+
+    Log(Info, "Setting up random...");
+    Random::SetSeed(pit->Ticks());
+
+    Log(Info, "Assigning PCI Drivers");
+    PCIDrivers::AssignDriversFromPCI(System::pci, System::driverManager);
+
+    Log(Info, "Creating shared region for system info");
+    System::systemInfo = (SharedSystemInfo*)KernelHeap::alignedMalloc(PAGE_SIZE, PAGE_SIZE);
+    MemoryOperations::memset(System::systemInfo, 0, PAGE_SIZE);
+
+    Log(Info, "Added drivers for integrated devices");
+    System::driverManager->AddDriver(new PS2MouseDriver());
+    System::driverManager->AddDriver(new PS2KeyboardDriver());
+    System::driverManager->AddDriver(new FloppyDriver());
+    
+    Log(Info, "Activating Drivers");
+    System::driverManager->ActivateAll();
+
+    Log(Info, "Setting up found USB controllers");
+    System::usbManager->SetupAll();
+    Log(Info, "Setting up found USB devices");
+    System::usbManager->AssignAllDrivers();
+    System::usbManager->USBPoll();
+
+    // Advanced Power Management
+    System::apm = new APMController();
+
+    Log(Info, "Found a total of: %d disks", System::diskManager->allDisks.size());
+    BootConsole::Write("Searching for boot partition");
+    if(System::vfs->SearchBootPartition()) {
+        BootConsole::Write(" [Found] ("); BootConsole::Write(Convert::IntToString(System::vfs->bootPartitionID)); BootConsole::WriteLine(")");
+    }
+    else
+        BootConsole::WriteLine(" [Not found]");
+
+    Log(Info, "Starting Debugger");
+    System::kernelDebugger = new SymbolDebugger("B:\\debug.sym", true);
+
+    Log(Info, "Starting Systemcalls");
+    System::syscalls = new SystemCallHandler();
+
+    Log(Info, "Preparing IPC");
+    IPCManager::Initialize();
+
+    Log(Info, "Adding default listing handlers");
+    System::listings = new List<ListingController*>();
+    System::listings->push_back(new DirectoryListing());
+
+    System::ProcStandardOut = new StandardOutSteam();
+    Log(Info, "System Initialized");
+}
+void System::Panic()
+{
+    Log(Error, "-------------------------------");
+    Log(Error, "--------- Kernel Halted -------");
+    Log(Error, "-------------------------------");
+
+    InterruptDescriptorTable::DisableInterrupts();
+    while(1) {
+        asm("hlt");
+    }
+}
\ No newline at end of file
diff --git a/kernelz/src/system/tasking/atomic.s b/kernelz/src/system/tasking/atomic.s
new file mode 100644
index 0000000..5fca47f
--- /dev/null
+++ b/kernelz/src/system/tasking/atomic.s
@@ -0,0 +1,9 @@
+.globl TestAndSet
+TestAndSet:
+    movl 4(%esp),%eax  # get new_value into %eax
+    movl 8(%esp),%edx  # get lock_pointer into %edx
+    lock               # next instruction is locked
+    xchgl %eax,(%edx)  # swap %eax with what is stored in (%edx)                       
+                       # ... and don't let any other cpu touch that
+                       # ... memory location while you're swapping
+    ret                # return the old value that's in %eax
\ No newline at end of file
diff --git a/kernelz/src/system/tasking/ipcmanager.cpp b/kernelz/src/system/tasking/ipcmanager.cpp
new file mode 100644
index 0000000..3622cd0
--- /dev/null
+++ b/kernelz/src/system/tasking/ipcmanager.cpp
@@ -0,0 +1,110 @@
+#include <../../lib/include/syscall.h>
+#include <system/tasking/ipcmanager.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+List<IPCReceiveDescriptor>* receivingBlockedList;
+void IPCManager::Initialize()
+{
+    receivingBlockedList = new List<IPCReceiveDescriptor>();
+}
+
+//Called from systemcalls when process tries to send a ipc message
+void IPCManager::HandleSend(core::CPUState* state, Process* proc)
+{
+    //Log(Info, "IPC Send from process %s", proc->fileName);
+    // Get message pointer from ebx register
+    LIBCactusOS::IPCMessage* msg = (LIBCactusOS::IPCMessage*)state->EBX;
+    
+    //Check if the source is valid
+    if (msg->source != proc->id) {
+        state->EAX = SYSCALL_RET_ERROR;
+        return;
+    }
+
+    // To which process is this message meant to be send to
+    Process* target = ProcessHelper::ProcessById(msg->dest);
+    if (target == 0) {
+        state->EAX = SYSCALL_RET_ERROR;
+        return;
+    }
+
+    //Add the message to the buffer of the target process
+    target->ipcMessages.push_back(*msg);
+
+    int i = 0;
+    for(IPCReceiveDescriptor desc : *receivingBlockedList) {
+        if(desc.receivingProcess == target && (desc.receiveFromPID == -1 ? true : desc.receiveFromPID == proc->id) && (desc.receiveType == -1 ? true : desc.receiveType == msg->type))
+        {    
+            Thread* receivingThread = desc.receivingThread;
+            if(receivingThread == 0)
+                continue;
+            
+            receivingBlockedList->Remove(i);
+            System::scheduler->Unblock(receivingThread);
+            break;
+        }
+        i++;
+    }
+
+    state->EAX = SYSCALL_RET_SUCCES;
+}
+
+//ebx = Message pointer
+//Called from systemcalls when process tries to receive a ipc message
+void IPCManager::HandleReceive(core::CPUState* state, Process* proc)
+{
+    //Log(Info, "IPC Receive from process %s", proc->fileName);
+    int recvFrom = state->ECX;
+    int* errRet = (int*)state->EDX;
+    int type = state->ESI;
+
+    //We need to block ourself if there are no messages at the moment
+    if (proc->ipcMessages.size() <= 0) {
+        //Generate IPC Receive Descriptor
+        IPCReceiveDescriptor desc;
+
+        //////////
+        // Fill in variables
+        //////////
+        desc.receivingProcess = proc;
+        desc.receivingThread = System::scheduler->CurrentThread();
+        desc.receiveFromPID = recvFrom;
+        desc.receiveType = type;
+
+        //Add this thread to the list of blocked processes
+        receivingBlockedList->push_back(desc);
+        System::scheduler->Block(desc.receivingThread, BlockedState::ReceiveIPC);
+    }
+
+    //If we get here we are either unblocked or there was already a message ready to receive
+    int messageIndex = 0;
+    LIBCactusOS::IPCMessage message = proc->ipcMessages.GetAt(messageIndex);
+    
+    //Loop throug all the messages until we find a correct one.
+    while ((message.dest != proc->id || (recvFrom == -1 ? false : recvFrom != message.source) || (type == -1 ? false : type != message.type)) && (messageIndex < proc->ipcMessages.size())) { //Is the message not for us or not from the correct source
+        proc->ipcMessages.GetAt(++messageIndex);
+    }
+
+    //We did not find a message that is for us or has the right parameters
+    if(messageIndex == proc->ipcMessages.size())
+    {
+        if (errRet != 0)
+            *errRet = SYSCALL_RET_ERROR;
+        return;
+    }
+
+    //Copy message
+    LIBCactusOS::IPCMessage* targetMessage = (LIBCactusOS::IPCMessage*)state->EBX;
+    MemoryOperations::memcpy(targetMessage, &message, sizeof(LIBCactusOS::IPCMessage));
+
+    //Remove it from the list
+    proc->ipcMessages.Remove(messageIndex);
+
+    if (errRet != 0)
+        *errRet = SYSCALL_RET_SUCCES;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/tasking/lock.cpp b/kernelz/src/system/tasking/lock.cpp
new file mode 100644
index 0000000..d995c1f
--- /dev/null
+++ b/kernelz/src/system/tasking/lock.cpp
@@ -0,0 +1,25 @@
+#include <system/tasking/lock.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::system;
+
+extern "C" int TestAndSet(int newValue, int* ptr);
+
+MutexLock::MutexLock()
+{
+    this->value = 0;
+}
+void MutexLock::Lock()
+{
+    while (TestAndSet(1, &this->value) == 1) {
+        if(System::scheduler && System::scheduler->Enabled)
+            System::scheduler->ForceSwitch();
+        else
+            asm ("pause");
+    }
+}
+void MutexLock::Unlock()
+{
+    this->value = 0;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/tasking/process.cpp b/kernelz/src/system/tasking/process.cpp
new file mode 100644
index 0000000..813b5da
--- /dev/null
+++ b/kernelz/src/system/tasking/process.cpp
@@ -0,0 +1,281 @@
+#include <system/tasking/process.h>
+
+#include <system/system.h>
+#include <system/memory/deviceheap.h>
+#include <system/tasking/elf.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+static int currentPID = 1;
+List<Process*> ProcessHelper::Processes;
+
+ProcessHelper::ProcessHelper()
+{   }
+
+Process* ProcessHelper::Create(char* fileName, char* arguments, bool isKernel)
+{
+    // Check if the file exists
+    if(!System::vfs->FileExists(fileName))
+        return 0;
+
+    // Get the filesize
+    int fileSize = System::vfs->GetFileSize(fileName);
+    if(fileSize == -1)
+        return 0;
+
+    // Allocate a buffer to read the bin
+    uint8_t* fileBuffer = new uint8_t[fileSize];
+
+    if(System::vfs->ReadFile(fileName, fileBuffer) != 0) //An error occurred
+    {
+        delete fileBuffer;
+        return 0;
+    }
+
+    InterruptDescriptorTable::DisableInterrupts();
+
+    /*////////////////////
+    Check for valid elf file
+    */////////////////////
+    ElfHeader* header = (ElfHeader*)fileBuffer;
+
+    if(!(header->e_ident[0] == ELFMAG0 && header->e_ident[1] == ELFMAG1 && header->e_ident[2] == ELFMAG2 && header->e_ident[3] == ELFMAG3) || header->e_type != 2)
+    {
+        delete fileBuffer;
+        return 0;
+    }
+
+    /*////////////////////
+    Create addres space
+    */////////////////////
+    uint32_t pageDirPhys = 0;
+    PageDirectory* pageDir = (PageDirectory*)KernelHeap::alignedMalloc(sizeof(PageDirectory), sizeof(PageDirectory), &pageDirPhys);
+    MemoryOperations::memset(pageDir, 0, sizeof(PageDirectory));
+
+    // Copy kernel pages
+    pageDir->entries[KERNEL_PTNUM] = ((PageDirectory*)&BootPageDirectory)->entries[KERNEL_PTNUM];
+    
+    // Copy kernel heap as well
+    for(uint32_t i = 0; i < KERNEL_HEAP_SIZE / 4_MB; i++)
+        pageDir->entries[KERNEL_PTNUM + i + 1] = ((PageDirectory*)&BootPageDirectory)->entries[KERNEL_PTNUM + i + 1];
+
+    // We also need to copy memory used by devices to this process
+    // We assume all memory is initialized when the first process is started
+    for(uint32_t i = DEVICE_HEAP_START; i < (DEVICE_HEAP_START + DEVICE_HEAP_SIZE); i += 4_MB)
+        pageDir->entries[PAGEDIR_INDEX(i)] = ((PageDirectory*)&BootPageDirectory)->entries[PAGEDIR_INDEX(i)];
+
+    // Set the last pde to the page directory itself
+    // With this we can use recursive page tables
+    PageDirectoryEntry lastPDE;
+    MemoryOperations::memset(&lastPDE, 0, sizeof(PageDirectoryEntry));
+    lastPDE.frame = pageDirPhys / PAGE_SIZE;
+    lastPDE.readWrite = 1;
+    lastPDE.pageSize = FOUR_KB;
+    lastPDE.present = 1;
+    pageDir->entries[1023] = lastPDE;
+
+    uint32_t oldCR3 = VirtualMemoryManager::GetPageDirectoryAddress();
+    VirtualMemoryManager::SwitchPageDirectory(pageDirPhys);
+
+    /*////////////////////
+    Create PCB
+    */////////////////////
+    Process* proc = new Process();
+    MemoryOperations::memset(proc, 0, sizeof(Process));
+
+    /*////////////////////
+    Load process into memory
+    */////////////////////
+    ElfProgramHeader* prgmHeader = (ElfProgramHeader*)(fileBuffer + header->e_phoff);
+
+    for(int i = 0; i < header->e_phnum; i++, prgmHeader++)
+        if(prgmHeader->p_type == 1)
+        {
+            // Should the pages for section be read only or write as well?
+            // This way we can prevent that usercode modifies itself
+            bool rw = prgmHeader->p_flags & (1<<1);
+
+            // Allocate pages for section
+            for(uint32_t x = 0; x < prgmHeader->p_memsz; x+=PAGE_SIZE)
+                VirtualMemoryManager::AllocatePage(VirtualMemoryManager::GetPageForAddress(prgmHeader->p_vaddr + x, true, true, !isKernel), isKernel, rw);
+
+            // Store memory information about excecutable
+			if (prgmHeader->p_vaddr < proc->excecutable.memBase || proc->excecutable.memBase == 0) {
+				proc->excecutable.memBase = prgmHeader->p_vaddr;
+			}
+			if (prgmHeader->p_vaddr + prgmHeader->p_memsz - proc->excecutable.memBase > proc->excecutable.memSize) {
+				proc->excecutable.memSize = prgmHeader->p_vaddr + prgmHeader->p_memsz - proc->excecutable.memBase;
+            }
+        }
+    
+    VirtualMemoryManager::ReloadCR3();
+
+    // Reset it otherwise the code will not be copied
+    prgmHeader = (ElfProgramHeader*)(fileBuffer + header->e_phoff);
+
+    // Load application by copying all loadable sections into memory
+    for(int i = 0; i < header->e_phnum; i++, prgmHeader++) {
+        //Log(Info, "[Process.Create] Program header type %d", prgmHeader->p_type);
+        if(prgmHeader->p_type == 1) {
+            //Log(Info, "[Process.Create] p_memsz = %d, p_filesz = %d", prgmHeader->p_memsz, prgmHeader->p_filesz);
+            
+            // First copy part that is actually present in file
+            MemoryOperations::memcpy((void*)prgmHeader->p_vaddr, fileBuffer + prgmHeader->p_offset, prgmHeader->p_filesz);
+
+            // Calculate remaning space (if there is some)
+            uint32_t rem = prgmHeader->p_memsz - prgmHeader->p_filesz;
+            uint32_t off = prgmHeader->p_filesz;
+
+            // And clear remaning memory if necessary
+            if(rem) MemoryOperations::memset((void*)(prgmHeader->p_vaddr + off), 0, rem);
+        }
+    }
+
+    // Put information in PCB
+    proc->id = currentPID++;
+    proc->pageDirPhys = pageDirPhys;
+    proc->state = ProcessState::Active;
+    proc->isUserspace = !isKernel;
+    proc->args = arguments;
+    proc->Threads.push_back(ThreadHelper::CreateFromFunction((void (*)())header->e_entry, isKernel));
+
+    Thread* mainThread = proc->Threads[0];
+
+    // Create userstack for process
+    for(uint32_t i = (uint32_t)mainThread->userStack; i < ((uint32_t)mainThread->userStack + mainThread->userStackSize); i+=PAGE_SIZE)
+        VirtualMemoryManager::AllocatePage(VirtualMemoryManager::GetPageForAddress(i, true, true, !isKernel), isKernel, true);
+
+    //Create heap for user process
+    for(uint32_t i = 0; i < PROC_USER_HEAP_SIZE; i+=PAGE_SIZE)
+    {
+        uint32_t addr = pageRoundUp(proc->excecutable.memBase + proc->excecutable.memSize) + i;
+        VirtualMemoryManager::AllocatePage(VirtualMemoryManager::GetPageForAddress(addr, true, true, !isKernel), isKernel, true);
+    }
+
+    proc->heap.heapStart = pageRoundUp(proc->excecutable.memBase + proc->excecutable.memSize);
+    proc->heap.heapEnd = proc->heap.heapStart + PROC_USER_HEAP_SIZE;
+
+    //Create stream for input
+    proc->stdInput = new FIFOStream(10_KB);
+    //Redirect output to system console
+    proc->stdOutput = System::ProcStandardOut;
+   
+    mainThread->parent = proc;
+
+    delete fileBuffer;
+
+    VirtualMemoryManager::SwitchPageDirectory(oldCR3);
+
+    //We can only copy the filename when we are in the same virtual space as the application that requested the exec
+    int fileNameLen = String::strlen(fileName);
+    MemoryOperations::memcpy(proc->fileName, fileName, fileNameLen <= 32 ? fileNameLen : 32);
+
+    InterruptDescriptorTable::EnableInterrupts();
+
+    // Assign debugger if demanded
+#if ENABLE_ADV_DEBUG
+    char* symbolFile = new char[fileNameLen+1];
+    MemoryOperations::memset(symbolFile, 0, fileNameLen);
+    MemoryOperations::memcpy(symbolFile, fileName, fileNameLen - 3);
+    MemoryOperations::memcpy(symbolFile + fileNameLen - 3, "sym", 4);
+    proc->symDebugger = new SymbolDebugger(symbolFile);
+    delete symbolFile;
+#endif
+
+    Processes.push_back(proc); //Finally add it to all known processes
+
+    return proc;
+}   
+
+Process* ProcessHelper::CreateKernelProcess()
+{
+    /*////////////////////
+    Create PCB
+    */////////////////////
+    Process* proc = new Process();
+    MemoryOperations::memset(proc, 0, sizeof(Process));
+
+    MemoryOperations::memcpy(proc->fileName, "Kernel Process", 15);
+    proc->id = currentPID++;
+    proc->pageDirPhys = virt2phys((uint32_t)&BootPageDirectory);
+    proc->state = ProcessState::Active;
+    proc->syscallID = 1;
+    proc->heap.heapStart = KERNEL_HEAP_START;
+    proc->heap.heapEnd = KERNEL_HEAP_SIZE;
+    
+    //Finally add it to all known processes
+    Processes.push_back(proc);
+
+    return proc;
+}
+
+void ProcessHelper::RemoveProcess(Process* proc)
+{
+    Log(Info, "Removing process %d from system", proc->id);
+    InterruptDescriptorTable::DisableInterrupts(); //We do not want to be interrupted during the switch
+    Processes.Remove(proc); //Remove the process from the list
+
+    for(int i = 0; i < proc->Threads.size(); i++)
+        ThreadHelper::RemoveThread(proc->Threads[i]);
+
+    //Free pages used by excecutable code
+    for(uint32_t p = proc->excecutable.memBase; p < proc->excecutable.memBase + proc->excecutable.memSize; p+=PAGE_SIZE)
+        VirtualMemoryManager::FreePage(VirtualMemoryManager::GetPageForAddress(p, false));
+
+    //Free pages used by the heap
+    for(uint32_t p = proc->heap.heapStart; p < proc->heap.heapEnd; p+=PAGE_SIZE)
+        VirtualMemoryManager::FreePage(VirtualMemoryManager::GetPageForAddress(p, false));
+
+    //Delete ipc messages
+    proc->ipcMessages.Clear();
+    
+    //Remove processes output that point to this process input
+    for(int i = 0; i < Processes.size(); i++)
+        if(Processes[i]->stdOutput == proc->stdInput)
+            Processes[i]->stdOutput = 0;
+    
+    //Free memory used by stdinput if possible
+    if(proc->stdInput != 0 && proc->stdInput != System::keyboardManager)
+        delete proc->stdInput;
+
+    delete proc;
+
+    InterruptDescriptorTable::EnableInterrupts();
+
+    //Finally force a contex switch so that we never return to this process again.
+    System::scheduler->ForceSwitch();
+}
+
+void ProcessHelper::UpdateHeap(Process* proc, uint32_t newEndAddr)
+{
+    if(proc->heap.heapEnd < newEndAddr) //Expand
+    {
+        Log(Info, "Expanding heap (PID: %d) from %x to %x", proc->id, proc->heap.heapEnd, newEndAddr);
+        
+        for(uint32_t i = proc->heap.heapEnd; i < pageRoundUp(newEndAddr); i+=PAGE_SIZE)
+            VirtualMemoryManager::AllocatePage(VirtualMemoryManager::GetPageForAddress(i, true, true, proc->isUserspace), !proc->isUserspace, true);
+        
+        proc->heap.heapEnd = pageRoundUp(newEndAddr);
+    }
+    else if(proc->heap.heapEnd > newEndAddr) //shrink
+    {
+        Log(Info, "shrinking heap (PID: %d) from %x to %x", proc->id, proc->heap.heapEnd, newEndAddr);
+
+        for(uint32_t i = pageRoundUp(newEndAddr); i < proc->heap.heapEnd; i+=PAGE_SIZE)
+            VirtualMemoryManager::FreePage(VirtualMemoryManager::GetPageForAddress(i, false, true, proc->isUserspace));
+        
+        proc->heap.heapEnd = pageRoundUp(newEndAddr);
+    }
+}
+
+Process* ProcessHelper::ProcessById(int id)
+{
+    for(Process* p : Processes)
+        if(p->id == id)
+            return p;
+            
+    return 0;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/tasking/scheduler.cpp b/kernelz/src/system/tasking/scheduler.cpp
new file mode 100644
index 0000000..436b4c8
--- /dev/null
+++ b/kernelz/src/system/tasking/scheduler.cpp
@@ -0,0 +1,204 @@
+#include <system/tasking/scheduler.h>
+
+#include <system/system.h>
+#include <core/tss.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+using namespace CactusOS::core;
+
+extern "C" void enter_usermode(uint32_t location, uint32_t stackAddress, uint32_t flags);
+
+Scheduler::Scheduler()
+: InterruptHandler(0x20)
+{
+    this->tickCount = 0;
+    this->frequency = SCHEDULER_FREQUENCY;
+    this->currentThread = 0;
+    this->threadsList.Clear();
+    this->Enabled = false;
+    this->switchForced = false;
+}
+
+uint32_t Scheduler::HandleInterrupt(uint32_t esp)
+{
+    tickCount++;
+    if(this->switchForced == false)
+        ProcessSleepingThreads();
+    else
+        this->switchForced = false; //Reset it back
+
+    if(tickCount == frequency)
+    {
+        //Log(Info, "Performing Task Switch");
+        
+        //Reset tick count first
+        tickCount = 0;
+
+        if(threadsList.size() > 0 && this->Enabled)
+        {
+            //Get a new thread to switch to
+            Thread* nextThread = GetNextReadyThread();
+
+            //Remove all the threads that are stopped from the system
+            while(nextThread->state == Stopped)
+            {
+                Log(Info, "Removing thread %x from system", (uint32_t)nextThread);
+                threadsList.Remove(nextThread);
+                delete nextThread;
+
+                //Ask for a new thread
+                nextThread = GetNextReadyThread();
+            }
+      
+            //Check if the current thread is stopped
+            if(currentThread != 0 && currentThread->state == Stopped)
+            {
+                Log(Info, "Removing thread %x from system", (uint32_t)currentThread);
+                threadsList.Remove(currentThread);
+                delete currentThread;
+            }
+
+            //At the first context switch the esp is pointing at the stack pointer used by the kernel,
+            //we do not want to save this info otherwise we will be running the kernel instead of the task
+            //Since all the stack pointers are allocated by the kernel we can check if it is kernel or not
+            //TODO: Is there no better way for this?
+            else if(esp >= KERNEL_HEAP_START)
+            {
+                //Save old registers
+                currentThread->regsPtr = (CPUState*)esp;
+
+                //Save current fpu status
+                asm volatile ("fxsave (%%eax)" : : "a" (currentThread->FPUBuffer));
+            }
+
+            //Load fpu status
+            asm volatile ("fxrstor (%%eax)" : : "a" (nextThread->FPUBuffer));
+            
+            //Since we are switching now
+            currentThread = nextThread;
+
+            //Check if the next thread has not been called before
+            if(nextThread->state == Started && nextThread->parent && nextThread->parent->isUserspace)
+            {
+                nextThread->state = ThreadState::Ready;
+
+                Log(Info, "Jumping to new created thread");
+                InitialThreadUserJump(nextThread);
+            }
+
+            //Load new registers
+            esp = (uint32_t)nextThread->regsPtr;
+
+            //Load page directory
+            if(nextThread->parent && nextThread->parent->pageDirPhys != 0)
+                VirtualMemoryManager::SwitchPageDirectory(nextThread->parent->pageDirPhys);
+
+            TSS::SetStack(0x10, (uint32_t)nextThread->stack + THREAD_STACK_SIZE);
+        }
+    }
+
+    return esp;
+}
+
+
+Thread* Scheduler::GetNextReadyThread()
+{
+    int currentThreadIndex = (currentThread != 0 ? threadsList.IndexOf(currentThread) : 0);
+    currentThreadIndex += 1;
+    if(currentThreadIndex >= threadsList.size())
+        currentThreadIndex = 0;
+
+    while(threadsList[currentThreadIndex]->state == Blocked){
+        currentThreadIndex += 1;
+        if(currentThreadIndex >= threadsList.size())
+            currentThreadIndex = 0;
+    }
+
+    return threadsList[currentThreadIndex]; 
+}
+
+void Scheduler::AddThread(Thread* thread, bool forceSwitch)
+{
+    threadsList.push_back(thread);
+
+    if(forceSwitch)
+    {
+        if(thread->parent && thread->parent->isUserspace)
+            InitialThreadUserJump(thread);
+
+        this->ForceSwitch();
+    }
+}
+
+void Scheduler::InitialThreadUserJump(Thread* thread)
+{
+    InterruptDescriptorTable::DisableInterrupts();
+
+    TSS::SetStack(0x10, (uint32_t)thread->stack + THREAD_STACK_SIZE);
+
+    //Dont forget to load the page directory
+    VirtualMemoryManager::SwitchPageDirectory(thread->parent->pageDirPhys);
+
+    //We are becoming the current thread
+    currentThread = thread;
+
+    //We need to be enabled on the next timer interrupt
+    this->Enabled = true;
+
+    //Ack Timer interrupt
+    outportb(0x20, 0x20);
+
+    enter_usermode(thread->regsPtr->EIP, (uint32_t)thread->userStack + thread->userStackSize, thread->regsPtr->EFLAGS);
+}
+
+void Scheduler::ForceSwitch()
+{
+    this->switchForced = true;
+    this->Enabled = true;
+    this->tickCount = frequency - 1;
+    asm volatile ("int $0x20"); //Call timer interrupt
+}
+
+Thread* Scheduler::CurrentThread()
+{
+    return currentThread; 
+}
+Process* Scheduler::CurrentProcess()
+{
+    if(currentThread)
+        return currentThread->parent;
+    return 0;
+}
+
+void Scheduler::Block(Thread* thread, BlockedState reason)
+{
+    //Log(Info, "Blocking thread %x", (uint32_t)thread);
+    thread->blockedState = reason;
+    thread->state = ThreadState::Blocked;
+
+    if(thread == CurrentThread())
+        ForceSwitch();
+}
+void Scheduler::Unblock(Thread* thread, bool forceSwitch)
+{
+    //Log(Info, "Unblocking thread %x", (uint32_t)thread);
+    thread->state = ThreadState::Ready;
+
+    if(forceSwitch)
+        ForceSwitch();
+}
+void Scheduler::ProcessSleepingThreads()
+{
+    for(int i = 0; i < threadsList.size(); i++)
+    {
+        Thread* thread = threadsList[i];
+        if(thread->state == Blocked && thread->blockedState == SleepMS && thread->timeDelta > 0)
+        {
+            thread->timeDelta--;
+            if(thread->timeDelta <= 0)
+                Unblock(thread); //Perhaps call thread directly when time has passed, this will be more acurate but harder to implement
+        }
+    }
+}
\ No newline at end of file
diff --git a/kernelz/src/system/tasking/thread.cpp b/kernelz/src/system/tasking/thread.cpp
new file mode 100644
index 0000000..eeb8ffa
--- /dev/null
+++ b/kernelz/src/system/tasking/thread.cpp
@@ -0,0 +1,70 @@
+#include <system/tasking/thread.h>
+
+#include <system/memory/heap.h> 
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+ThreadHelper::ThreadHelper()
+{   }
+
+Thread* ThreadHelper::CreateFromFunction(void (*entryPoint)(), bool isKernel, uint32_t flags, Process* parent)
+{
+    //Create new thread instance
+    Thread* result = new Thread();
+
+    //Create stack for process
+    result->stack = (uint8_t*)KernelHeap::alignedMalloc(THREAD_STACK_SIZE, THREAD_STACK_SIZE);
+    MemoryOperations::memset(result->stack, 0, THREAD_STACK_SIZE);
+
+    //Assign user stack, needs to be mapped into address space by elf loader if we are loading a .bin
+    //When a process requests a new thread the stack for the new thread needs to be moved down, otherwise the stacks will be equal.
+    //The memory required is mapped by the elfloader or by the syscall handler.
+    result->userStack = (parent == 0 ? (uint8_t*)USER_STACK : (uint8_t*)(USER_STACK - USER_STACK_SIZE*parent->Threads.size()));
+    result->userStackSize = USER_STACK_SIZE;
+
+    //Create cpu registers for thread
+    result->regsPtr = (CPUState*)((uint32_t)result->stack + THREAD_STACK_SIZE - sizeof(CPUState));
+
+    //Set the stack pointer
+    result->regsPtr->ESP = (uint32_t)result->stack + THREAD_STACK_SIZE;
+
+    //And set the instruction pointer
+    result->regsPtr->EIP = (uint32_t)entryPoint;
+
+    //Also update the segment registers for a kernel of userspace thread
+    result->regsPtr->CS = isKernel ? SEG_KERNEL_CODE : SEG_USER_CODE;
+	result->regsPtr->DS = isKernel ? SEG_KERNEL_DATA : SEG_USER_DATA;
+	result->regsPtr->ES = isKernel ? SEG_KERNEL_DATA : SEG_USER_DATA;
+	result->regsPtr->FS = isKernel ? SEG_KERNEL_DATA : SEG_USER_DATA;
+	result->regsPtr->GS = isKernel ? SEG_KERNEL_DATA : SEG_USER_DATA;
+
+    //Set the flags for this thread
+	result->regsPtr->EFLAGS = flags;
+
+    //Default state is wait here
+    result->state = ThreadState::Ready;
+
+    //Assign thread parent
+    result->parent = parent;
+
+    //Create a buffer for the fpu
+    result->FPUBuffer = (uint8_t*)KernelHeap::alignedMalloc(512, 16);
+    MemoryOperations::memset(result->FPUBuffer, 0, 512);
+
+    //Return the result
+    return result;
+}
+
+void ThreadHelper::RemoveThread(Thread* thread)
+{
+    KernelHeap::allignedFree(thread->stack);
+    KernelHeap::allignedFree(thread->FPUBuffer);
+    for(uint32_t i = (uint32_t)thread->userStack; i < (uint32_t)thread->userStack + thread->userStackSize; i+=PAGE_SIZE)
+        VirtualMemoryManager::FreePage(VirtualMemoryManager::GetPageForAddress(i, false));
+
+    thread->state = ThreadState::Stopped;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/tasking/userspace.asm b/kernelz/src/system/tasking/userspace.asm
new file mode 100644
index 0000000..48607c1
--- /dev/null
+++ b/kernelz/src/system/tasking/userspace.asm
@@ -0,0 +1,28 @@
+GLOBAL enter_usermode
+enter_usermode:
+   ;push ebp
+   mov ebp, esp
+   cli
+
+   mov ax, 0x20 | 3
+   mov ds, ax
+   mov es, ax
+   mov fs, ax
+   mov gs, ax
+
+   push 0x20 | 3   ; push ss3
+
+   mov ecx, [ebp+8]
+   push ecx ; push esp3
+
+   pushf  ; push flags onto stack
+   pop eax ; pop into eax
+   or eax, [ebp+12] ; Copy EFLAGS from arg 3
+   push eax ; push eflags
+   push 0x18 | 3 ; push CS, requested priv. level = 3
+
+   xor eax, eax  ; Clear eax
+   mov eax, [ebp+4] ; Load new IP into eax
+   push eax ; Push EIP onto stack
+
+   iret
\ No newline at end of file
diff --git a/kernelz/src/system/usb/hidparser.cpp b/kernelz/src/system/usb/hidparser.cpp
new file mode 100644
index 0000000..8b87881
--- /dev/null
+++ b/kernelz/src/system/usb/hidparser.cpp
@@ -0,0 +1,417 @@
+#include <system/usb/hidparser.h>
+#include <common/memoryoperations.h>
+#include <system/log.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+#define HID_SHOW_INFO 0
+
+char spaces_buff[33];
+char* spaces(unsigned cnt) {
+    if (cnt > 32)
+        return "**";
+
+    MemoryOperations::memset(spaces_buff, ' ', 32);
+    spaces_buff[cnt] = 0;
+    return spaces_buff;
+}
+char usage_type_str[][64] = {
+    "Undefined", "Generic Desktop", "Simulation", "VR", "Sport", "Game",
+    "Generic Device", "Keyboard/Keypad", "LEDs", "Button", "Ordinal", "Telephony", "Consumer", "Digitizer",
+    "Reserved", "PID Page", "Unicode", "Reserved", "Reserved", "Reserved", "Alphanumeric Display",
+
+    // offset 0x15
+    "Medical Insturments", "Monitor Pages", "Power Pages",
+
+    "Bar Code Scanner page", "Scale page", "Magnetic Stripe Reading (MSR) Devices", "Reserved Point of Sale pages",
+    "Camera Control Page" , "Arcade Page"
+};
+
+const char* hid_print_usage_type(unsigned type) {
+    if (type <= 0x14)
+        return usage_type_str[type];
+    else if (type <= 0x3F)
+        return usage_type_str[0x13];
+    else if (type <= 0x40)
+        return usage_type_str[0x15];
+    else if (type <= 0x7F)
+        return usage_type_str[0x13];
+    else if (type <= 0x83)
+        return usage_type_str[0x16];
+    else if (type <= 0x87)
+        return usage_type_str[0x17];
+    else if (type <= 0x8B)
+        return usage_type_str[0x13];
+    else if (type <= 0x91)
+        return usage_type_str[type - 24];
+    else if (type <= 0xFEFF)
+        return usage_type_str[0x13];
+    else
+        return "Error: type > 0xFFFF";
+}
+
+char usage_str_page_1[][64] = {
+    "Undefined", "Pointer", "Mouse", "Reserved", "Joystick", "Game Pad", "Keyboard", "Keypad", "Multi-axis Controller"
+    "Tablet PC System Controls", 
+
+    "X", "Y", "Z", "Rx", "Ry", "Rz", "Slider", "Dial", "Wheel", "Hat switch", "Counted Buffer", "Byte Count", "Motion Wakeup",
+    "Start", "Select", "Reserved", "Vx", "Vy", "Vz", "Vbrx", "Vbry", "Vbrz", "Vno", "Feature Notification",
+    "Resolution Multiplier",
+
+    "System Control", "System Power Down", "System Sleep", "System Wake Up", "System Context Menu", "System Main Menu",
+    "System App Menu", "System Menu Help", "System Menu Exit", "System Menu Select", "System Menu Right", "System Menu Left",
+    "System Menu Up", "System Menu Down", "System Cold Restart", "System Warm Restart", "D-pad Up", "D-pad Down",
+    "D-pad Right", "D-pad Left", "Reserved", "Reserved", "Reserved", "Reserved", "Reserved", "Reserved", "System Dock",
+    "System Undock", "System Setup", "System Break", "System Debugger Break", "Application Break", "Application Debugger Break",
+    "System Speaker Mute", "System Hibernate", "Reserved", "Reserved", "Reserved", "Reserved", "Reserved", "Reserved", "Reserved",
+    "System Display Invert", "System Display Internal", "System Display External", "System Display Both", "System Display Dual",
+    "System Display Toggle Int/Ext", "System Display Swap", "Primary/Secondary", "System Display LCD Autoscale"
+};
+
+const char* hid_print_usage(unsigned page, unsigned type) {
+    switch (page) {
+        case 1:
+        if (type <= 0x09)
+            return usage_str_page_1[type];
+        else if (type <= 0x2F)
+            return usage_str_page_1[0x03];
+        else if (type <= 0x48)
+            return usage_str_page_1[type - 39];
+        else if (type <= 0x7F)
+            return usage_type_str[0x03];
+        else if (type <= 0xB7)
+            return usage_type_str[type - 39 - 55]; /// may be off by a few
+        else if (type <= 0xFFFF)
+            return usage_type_str[0x03];
+        else
+            return " Error: type > 0xFFFF";
+        break;
+        
+        default:
+        return "Unsupported Usage Page";
+    }
+}
+
+char collection_str[][64] = {
+    "Physical", "Application", "Logical", "Report", "Named Array", "Usage Switch", "Usage Modifier"
+};
+
+const char* hid_print_collection(unsigned val) {
+    if (val <= 0x06)
+        return collection_str[val];
+    else if (val <= 0x7F)
+        return "Reserved";
+    else if (val <= 0xFF)
+        return "Vendor-defined";
+    else
+        return "Error: val > 0xFF";
+}
+uint32_t format_value(uint32_t value, uint8_t size) {
+    if (size == 1) 
+        value = (uint32_t) (uint8_t) value;
+    else if (size == 2) 
+        value = (uint32_t) (uint16_t) value;
+    return value;
+}
+
+
+bool HIDParser::Parse(struct HID_DATA* data)
+{
+    bool found = false;
+    static unsigned space_cnt = 0;
+    static bool did_collection = false;
+    static int item_size[4] = { 0, 1, 2, 4 };
+    
+    while (!found && (this->pos < this->report_desc_size)) {
+        // Get new this->item if current this->count is empty 
+        if (this->count == 0) {
+            if (HID_SHOW_INFO) Log(Info, "\n %02X ", this->report_desc[this->pos]);
+            this->item = this->report_desc[this->pos++];
+            this->value = 0;
+            MemoryOperations::memcpy(&this->value, &this->report_desc[this->pos], item_size[this->item & SIZE_MASK]);
+            if (HID_SHOW_INFO) {
+                for (int t=0; t<4; t++) {
+                    if (t < item_size[this->item & SIZE_MASK])
+                        Log(Info, "%02X ", this->report_desc[this->pos + t]);
+                    else
+                        Log(Info, "   ");
+                }
+            }
+            
+            // Pos on next item
+            this->pos += item_size[this->item & SIZE_MASK];
+        }
+
+        if((this->item & ITEM_MASK) == 0)
+            continue;
+        
+        //Log(Info, "\n (this->item & ITEM_MASK) = 0x%04X", (this->item & ITEM_MASK));
+        switch (this->item & ITEM_MASK) {
+            case ITEM_UPAGE:
+                // Copy upage in usage stack
+                this->u_page = (uint16_t) this->value;
+                if (HID_SHOW_INFO) Log(Info, "%sUsage Page (%s)", spaces(space_cnt), hid_print_usage_type(this->u_page));
+                
+                // copy to the usage table, but do not increment the counter incase there is a USAGE entry
+                this->usage_table[this->usage_size].u_page = this->u_page;
+                this->usage_table[this->usage_size].usage = 0xFF;
+                break;
+                
+            case ITEM_USAGE:
+                // Copy global or local u_page if any, in usage stack
+                if ((this->item & SIZE_MASK) > 2)
+                this->usage_table[this->usage_size].u_page = (uint16_t) (this->value >> 16);
+                else
+                this->usage_table[this->usage_size].u_page = this->u_page;
+                
+                // Copy Usage in Usage stack
+                this->usage_table[this->usage_size].usage = (uint16_t) (this->value & 0xFFFF);
+                if (HID_SHOW_INFO) Log(Info, "%sUsage (%s)", spaces(space_cnt), hid_print_usage(this->u_page, (uint16_t) (this->value & 0xFFFF)));
+                
+                // Increment Usage stack size
+                this->usage_size++;
+                
+                break;
+                
+            case ITEM_USAGE_MIN:
+                // TODO: is usage_min and max does this way, and are they bit32s or smaller?
+                this->usage_min = format_value(this->value, item_size[this->item & SIZE_MASK]);
+                if (HID_SHOW_INFO) Log(Info, "%sUsage min (%d)", spaces(space_cnt), this->usage_min);
+                break;
+                
+            case ITEM_USAGE_MAX:
+                this->usage_max = format_value(this->value, item_size[this->item & SIZE_MASK]);
+                if (HID_SHOW_INFO) Log(Info, "%sUsage max (%d)", spaces(space_cnt), this->usage_max);
+                break;
+                
+            case ITEM_COLLECTION:
+                // Get UPage/Usage from usage_table and store them in this->Data.Path
+                this->data.path.node[this->data.path.size].u_page = this->usage_table[0].u_page;
+                this->data.path.node[this->data.path.size].usage = this->usage_table[0].usage;
+                this->data.path.size++;
+                
+                // Unstack u_page/Usage from usage_table (never remove the last)
+                if (this->usage_size > 0) {
+                    uint8_t ii=0;
+                    while (ii < this->usage_size) {
+                        this->usage_table[ii].usage = this->usage_table[ii+1].usage;
+                        this->usage_table[ii].u_page = this->usage_table[ii+1].u_page;
+                        ii++;
+                    }
+                    // Remove Usage
+                    this->usage_size--;
+                }
+                
+                // Get Index if any
+                if (this->value >= 0x80) {
+                    this->data.path.node[this->data.path.size].u_page = 0xFF;
+                    this->data.path.node[this->data.path.size].usage = (uint16_t) (this->value & 0x7F);
+                    this->data.path.size++;
+                }
+                
+                if (HID_SHOW_INFO) {
+                    Log(Info, "%sCollection (%s)", spaces(space_cnt), hid_print_collection(this->value));
+                    space_cnt += 2;
+                }
+                break;
+                
+            case ITEM_END_COLLECTION:
+                this->data.path.size--;
+                // Remove Index if any
+                if (this->data.path.node[this->data.path.size].u_page == 0xFF)
+                    this->data.path.size--;
+
+                if (HID_SHOW_INFO) {
+                    if (space_cnt >= 2) space_cnt -= 2;
+                    Log(Info, "%sEnd Collection", spaces(space_cnt));
+                }
+                break;
+                
+            case ITEM_FEATURE:
+            case ITEM_INPUT:
+            case ITEM_OUTPUT:
+                // An object was found
+                found = true;
+                
+                // Increment object count
+                this->cnt_object++;
+                
+                // Get new this->Count from global value
+                if (this->count == 0)
+                    this->count = this->report_count;
+                
+                // Get u_page/Usage from usage_table and store them in this->Data.Path
+                this->data.path.node[this->data.path.size].u_page = this->usage_table[0].u_page;
+                this->data.path.node[this->data.path.size].usage = this->usage_table[0].usage;
+                this->data.path.size++;
+                
+                // Unstack u_page/Usage from usage_table (never remove the last)
+                if (this->usage_size > 0) {
+                    uint8_t ii = 0;
+                    while (ii < this->usage_size) {
+                        this->usage_table[ii].u_page = this->usage_table[ii+1].u_page;
+                        this->usage_table[ii].usage = this->usage_table[ii+1].usage;
+                        ii++;
+                    }
+                    // Remove Usage
+                    this->usage_size--;
+                }
+                
+                // Copy data type
+                this->data.type = (uint8_t) (this->item & ITEM_MASK);
+                //Log(Info, "\n this->data.type = %d", this->data.type);
+                
+                // Copy data attribute
+                this->data.attribute = (uint8_t) this->value;
+                //Log(Info, "\n this->data.attribute = %d", this->data.attribute);
+                
+                // Store offset
+                this->data.offset = *this->GetReportOffset(this->data.report_id, (uint8_t) (this->item & ITEM_MASK));
+                //Log(Info, "\n this->data.offset = %d", this->data.offset);
+                
+                // Get Object in pData
+                MemoryOperations::memcpy(data, &this->data, sizeof(struct HID_DATA));
+                
+                // Increment Report Offset
+                *this->GetReportOffset(this->data.report_id, (uint8_t) (this->item & ITEM_MASK)) += this->data.size;
+                
+                // Remove path last node
+                this->data.path.size--;
+                
+                // Decrement count
+                this->count--;
+                
+                if (!did_collection) {
+                    if (HID_SHOW_INFO) {
+                        if ((this->item & ITEM_MASK) == ITEM_FEATURE)
+                        Log(Info, "%sFeature ", spaces(space_cnt));
+                        if ((this->item & ITEM_MASK) == ITEM_INPUT)
+                        Log(Info, "%sInput ", spaces(space_cnt));
+                        if ((this->item & ITEM_MASK) == ITEM_OUTPUT)
+                        Log(Info, "%sOutput ", spaces(space_cnt));
+                        Log(Info, "(%s,%s,%s)", !(this->value & (1<<0)) ? "Data"     : "Constant",
+                                            !(this->value & (1<<1)) ? "Array"    : "Variable",
+                                            !(this->value & (1<<2)) ? "Absolute" : "Relative");
+                                            //!(this->value & (1<<3)) ? "No Wrap"  : "Wrap",
+                                            //!(this->value & (1<<4)) ? "Linear"   : "Non Linear",
+                                            //!(this->value & (1<<5)) ? "Preferred State" : "No Preferred",
+                                            //!(this->value & (1<<6)) ? "No Null"  : "Null State",
+                                            //!(this->value & (1<<8)) ? "Bit Fueld" : "Buffered Bytes");
+                    }
+                    did_collection = true;
+                }
+                
+                break;
+                
+            case ITEM_REP_ID:
+                this->data.report_id = (uint8_t) this->value;
+                break;
+                
+            case ITEM_REP_SIZE:
+                this->data.size = (uint8_t) this->value;
+                if (HID_SHOW_INFO) Log(Info, "%sreport size (%d)", spaces(space_cnt), this->data.size);
+                break;
+                
+            case ITEM_REP_COUNT:
+                this->report_count = (uint8_t) this->value;
+                if (HID_SHOW_INFO) Log(Info, "%sreport count (%d)", spaces(space_cnt), this->report_count);
+                did_collection = false;
+                break;
+                
+            case ITEM_UNIT_EXP:
+                this->data.unit_exp = (uint8_t) this->value;
+                // convert 4 bits signed value to 8 bits signed value
+                if (this->data.unit_exp > 7)
+                this->data.unit_exp |= 0xF0;
+                break;
+                
+            case ITEM_UNIT:
+                this->data.unit=this->value;
+                break;
+                
+            case ITEM_LOG_MIN:
+                this->data.log_min = format_value(this->value, item_size[this->item & SIZE_MASK]);
+                if (HID_SHOW_INFO) Log(Info, "%sLogical Min (%d)", spaces(space_cnt), this->data.log_min);
+                break;
+                
+            case ITEM_LOG_MAX:
+                this->data.log_max = format_value(this->value, item_size[this->item & SIZE_MASK]);
+                if (HID_SHOW_INFO) Log(Info, "%sLogical Max (%d)", spaces(space_cnt), this->data.log_max);
+                break;
+                
+            case ITEM_PHY_MIN:
+                this->data.phy_min = format_value(this->value, item_size[this->item & SIZE_MASK]);
+                if (HID_SHOW_INFO) Log(Info, "%sPhysical Min (%d)", spaces(space_cnt), this->data.phy_min);
+                break;
+                
+            case ITEM_PHY_MAX:
+                this->data.phy_max = format_value(this->value, item_size[this->item & SIZE_MASK]);
+                if (HID_SHOW_INFO) Log(Info, "%sPhysical Max (%d)", spaces(space_cnt), this->data.phy_max);
+                break;
+                
+            default:
+                Log(Info, "\n Found unknown item %x", (this->item & ITEM_MASK));
+        }
+    }
+    
+    return found;
+}
+
+void HIDParser::Reset()
+{
+    this->pos = 0;
+    this->count = 0;
+    this->cnt_object = 0;
+    this->cnt_report = 0;
+    
+    this->usage_size = 0;
+    this->usage_min = -1;
+    this->usage_max = -1;
+    MemoryOperations::memset(this->usage_table, 0, sizeof(struct HID_NODE) * USAGE_TAB_SIZE);
+    
+    MemoryOperations::memset(this->offset_table, 0, MAX_REPORT * 3 * sizeof(int));
+    MemoryOperations::memset(&this->data, 0, sizeof(struct HID_DATA));
+    
+    this->data.report_id = 1; // we must give it a non-zero value or the parser doesn't work
+}
+
+bool HIDParser::FindObject(struct HID_DATA* data)
+{
+    struct HID_DATA found_data;
+    this->Reset();
+    while (this->Parse(&found_data)) {
+        if ((data->path.size > 0) && (found_data.type == data->type) && MemoryOperations::memcmp(found_data.path.node, data->path.node, data->path.size * sizeof(struct HID_NODE)) == 0) 
+        {
+            MemoryOperations::memcpy(data, &found_data, sizeof(struct HID_DATA));
+            data->report_count = this->report_count;
+            return true;
+        }
+        // Found by ReportID/Offset
+        else if ((found_data.report_id == data->report_id) && (found_data.type == data->type) && (found_data.offset == data->offset)) {
+            MemoryOperations::memcpy(data, &found_data, sizeof(struct HID_DATA));
+            data->report_count = this->report_count;
+            return true;
+        }
+    }
+    return false;
+}
+int* HIDParser::GetReportOffset(const common::uint8_t report_id, const common::uint8_t report_type)
+{
+    int pos = 0;
+    while ((pos < MAX_REPORT) && (this->offset_table[pos][0] != 0)) {
+        if ((this->offset_table[pos][0] == report_id) && (this->offset_table[pos][1] == report_type))
+            return &this->offset_table[pos][2];
+        pos++;
+    }
+    if (pos < MAX_REPORT) {
+        // Increment Report count
+        this->cnt_report++;
+        this->offset_table[pos][0] = report_id;
+        this->offset_table[pos][1] = report_type;
+        this->offset_table[pos][2] = 0;
+        return &this->offset_table[pos][2];
+    }
+    return 0;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/usb/usbcontroller.cpp b/kernelz/src/system/usb/usbcontroller.cpp
new file mode 100644
index 0000000..a799401
--- /dev/null
+++ b/kernelz/src/system/usb/usbcontroller.cpp
@@ -0,0 +1,118 @@
+#include <system/usb/usbcontroller.h>
+#include <system/drivers/usb/usbdefs.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+USBController::USBController(USBControllerType usbType)
+{
+    this->type = usbType;
+    this->interrupTransfers.Clear();
+}
+
+void USBController::Setup()
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+}
+void USBController::ControllerChecksThread()
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+}
+
+//////////////
+// Controller specific transfer functions
+//////////////
+
+bool USBController::BulkIn(USBDevice* device, void* retBuffer, int len, int endP)
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+    return false;
+}
+bool USBController::BulkOut(USBDevice* device, void* sendBuffer, int len, int endP)
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+    return false;
+}
+bool USBController::ControlIn(USBDevice* device, void* target, const int len, const uint8_t requestType, const uint8_t request, const uint16_t valueHigh, const uint16_t valueLow, const uint16_t index)
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+    return false;
+}
+bool USBController::ControlOut(USBDevice* device, const int len, const uint8_t requestType, const uint8_t request, const uint16_t valueHigh, const uint16_t valueLow, const uint16_t index)
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+    return false;
+}
+void USBController::InterruptIn(USBDevice* device, int len, int endP)
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+}
+
+
+/////////////
+// Specific Functions independent of controller
+/////////////
+
+
+bool USBController::GetDeviceDescriptor(struct DEVICE_DESC* dev_desc, USBDevice* device)
+{
+    return ControlIn(device, dev_desc, sizeof(struct DEVICE_DESC), STDRD_GET_REQUEST, DeviceRequest::GET_DESCRIPTOR, DescriptorTypes::DEVICE);
+}
+
+bool USBController::GetStringDescriptor(struct STRING_DESC* stringDesc, USBDevice* device, uint16_t index, uint16_t lang)
+{
+    if(!ControlIn(device, stringDesc, 2, STDRD_GET_REQUEST, DeviceRequest::GET_DESCRIPTOR, DescriptorTypes::STRING, index, lang))
+        return false;
+        
+    int totalSize = stringDesc->len;
+    return ControlIn(device, stringDesc, totalSize, STDRD_GET_REQUEST, DeviceRequest::GET_DESCRIPTOR, DescriptorTypes::STRING, index, lang);
+}
+
+uint8_t* USBController::GetConfigDescriptor(USBDevice* device)
+{
+    struct CONFIG_DESC confDesc;
+    MemoryOperations::memset(&confDesc, 0, sizeof(struct CONFIG_DESC));
+
+    if(!ControlIn(device, &confDesc, sizeof(struct CONFIG_DESC), STDRD_GET_REQUEST, GET_DESCRIPTOR, CONFIG))
+        return 0;
+    
+    int totalSize = confDesc.tot_len;
+    uint8_t* buffer = new uint8_t[totalSize];
+    MemoryOperations::memset(buffer, 0, totalSize);
+
+    if(!ControlIn(device, buffer, totalSize, STDRD_GET_REQUEST, GET_DESCRIPTOR, CONFIG))
+        return 0;
+    
+    return buffer;
+}
+
+bool USBController::SetConfiguration(USBDevice* device, uint8_t config)
+{
+    return ControlOut(device, 0, STDRD_SET_REQUEST, SET_CONFIGURATION, 0, config);
+}
+
+int USBController::GetConfiguration(USBDevice* device)
+{
+    uint8_t ret = 0;
+    if(!ControlIn(device, &ret, 1, STDRD_GET_REQUEST, GET_CONFIGURATION))
+        return 0;
+    
+    return ret;
+}
+
+int USBController::GetMaxLuns(USBDevice* device)
+{
+    uint8_t ret = 0;
+    for(int i = 0; i < 3; i++) {
+        if(ControlIn(device, &ret, 1, DEV_TO_HOST | REQ_TYPE_CLASS | RECPT_INTERFACE, GET_MAX_LUNS))
+            return ret;
+        
+        // If request failed send Clear feature (HALT) to control endpoint
+        device->controller->ControlOut(device, 0, HOST_TO_DEV | REQ_TYPE_STNDRD | RECPT_ENDPOINT, CLEAR_FEATURE);
+    }
+    return 0;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/usb/usbdevice.cpp b/kernelz/src/system/usb/usbdevice.cpp
new file mode 100644
index 0000000..9bcfe69
--- /dev/null
+++ b/kernelz/src/system/usb/usbdevice.cpp
@@ -0,0 +1,279 @@
+#include <system/log.h>
+#include <system/drivers/usb/usbdefs.h>
+#include <system/usb/usbdevice.h>
+#include <system/drivers/usb/usbdriver.h>
+
+#include <system/drivers/usb/mass_storage.h>
+#include <system/drivers/usb/usbmouse.h>
+#include <system/drivers/usb/usbkeyboard.h>
+#include <system/drivers/usb/usbcomborecv.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+char* USBControllerStrings[] =
+{
+    "UHCI",
+    "OHCI",
+    "EHCI",
+    "xHCI"
+};
+
+char* USBClassCodeStrings[] = 
+{
+    "00 Unspecified",
+    "01 Audio",
+    "02 Communications and CDC Control",
+    "03 Human interface device (HID)",
+    "05 Physical Interface Device (PID)",
+    "06 Image (PTP/MTP)",
+    "07 Printer",
+    "08 Mass storage (MSC or UMS)",
+    "09 USB hub",
+    "0A CDC-Data",
+    "0B Smart Card",
+    "0D Content security",
+    "0E Video",
+    "0F Personal healthcare device class (PHDC)",
+    "10 Audio/Video (AV)",
+    "11 Billboard",
+    "DC Diagnostic Device",
+    "E0 Wireless Controller",
+    "EF Miscellaneous",
+    "FE Application-specific",
+    "FF Vendor-specific"
+};
+const int numClassCodeStrings = sizeof(USBClassCodeStrings) / sizeof(char*);
+
+//Create new USBDevice, only called by controllers
+USBDevice::USBDevice()
+: endpoints()
+{ }
+
+//Automaticly test this device for its specs and assign a driver if found
+bool USBDevice::AssignDriver()
+{
+    if(this->controller == 0 || this->devAddress == 0) {
+        Log(Error, "USB Device not properly initialized by controller");
+        return false;
+    }
+    Log(Info, "Assigning driver for USBDevice %d on %s Controller", this->portNum, USBControllerStrings[this->controller->type]);
+    
+    struct DEVICE_DESC dev_desc;
+    MemoryOperations::memset(&dev_desc, 0, sizeof(struct DEVICE_DESC));
+    if(!this->controller->GetDeviceDescriptor(&dev_desc, this))
+        return false;
+
+    if(dev_desc.len == 0) {
+        Log(Error, "No device is connected even though controller says it is");
+        return false;
+    }
+    
+    Log(Info, "USBDevice Descriptor:"
+        "\n                 len: %d"
+        "\n                type: %d"
+        "\n             version: %b.%b"
+        "\n               class: %d"
+        "\n            subclass: %d"
+        "\n            protocol: %d"
+        "\n     max packet size: %d"
+        "\n           vendor id: %w"
+        "\n          product id: %w"
+        "\n         release ver: %d%d.%d%d"
+        "\n   manufacture index: %d (index to a string)"
+        "\n       product index: %d"
+        "\n        serial index: %d"
+        "\n   number of configs: %d",
+        dev_desc.len, dev_desc.type, dev_desc.usb_ver >> 8, dev_desc.usb_ver & 0xFF, dev_desc._class, dev_desc.subclass, 
+        dev_desc.protocol, dev_desc.max_packet_size, dev_desc.vendorid, dev_desc.productid, 
+        (dev_desc.device_rel & 0xF000) >> 12, (dev_desc.device_rel & 0x0F00) >> 8,
+        (dev_desc.device_rel & 0x00F0) >> 4,  (dev_desc.device_rel & 0x000F) >> 0,
+        dev_desc.manuf_indx, dev_desc.prod_indx, dev_desc.serial_indx, dev_desc.configs);
+    
+    this->classID = dev_desc._class;
+    this->subclassID = dev_desc.subclass;
+    this->protocol = dev_desc.protocol;
+    this->vendorID = dev_desc.vendorid;
+    this->productID = dev_desc.productid;
+    
+    struct STRING_DESC stringLangDesc;
+    MemoryOperations::memset(&stringLangDesc, 0, sizeof(struct STRING_DESC));
+    if(!this->controller->GetStringDescriptor(&stringLangDesc, this, 0))
+        return false;
+    
+    //Check if device supports some languages
+    if(stringLangDesc.len > 2)
+    {
+        int englishIndex = -1; //Index of english LANGID
+        Log(Info, "Supported Languages by USB Device = %d", (stringLangDesc.len - 2) / 2);
+        for(int i = 0; i < (stringLangDesc.len - 2) / 2; i++) {
+            Log(Info, "Language: %w", stringLangDesc.string[i]);
+            if(stringLangDesc.string[i] == 0x0409)
+                englishIndex = i;
+        }
+        if(englishIndex != -1) //We have found a english LANGID
+        {
+            //Request device strings in english language
+            if(dev_desc.prod_indx != 0) //We have a product string
+            {
+                struct STRING_DESC stringDesc;
+                MemoryOperations::memset(&stringDesc, 0, sizeof(struct STRING_DESC));
+                if(this->controller->GetStringDescriptor(&stringDesc, this, dev_desc.prod_indx, 0x0409))
+                {
+                    int strLen = (stringDesc.len-2)/2;
+                    if(strLen > 0) {
+                        //Convert Unicode string to ASCII
+                        this->deviceName = new char[strLen + 1];
+                        this->deviceName[strLen] = '\0';
+                        for(int i = 0; i < strLen; i++)
+                            this->deviceName[i] = stringDesc.string[i];
+                    }
+                }
+            }
+        }
+    }
+    else
+        Log(Warning, "USBDevice does not have any language supported");
+    
+    //Get Config Descriptor
+    uint8_t* configBuffer = this->controller->GetConfigDescriptor(this);
+    if(configBuffer)
+    {
+        int confLen = *(uint16_t*)(configBuffer + 2);
+
+        uint8_t* startByte = configBuffer;
+        uint8_t* endByte = configBuffer + confLen;
+
+        //Loop through all data
+        while ((uint32_t)startByte < (uint32_t)endByte)
+        {
+            uint8_t length = startByte[0];
+            uint8_t type = startByte[1];
+
+            if (length == 9 && type == CONFIG) // CONFIGURATION descriptor
+            {
+                struct CONFIG_DESC* c = (struct CONFIG_DESC*)startByte;
+                Log(Info, "USBDevice Config Desc: NumInterfaces=%d ConfigVal=%d ConfigString=%d Attr=%b MaxPower=%d mA", c->num_interfaces, c->config_val, c->config_indx, c->bm_attrbs, c->max_power);
+                
+                if(c->config_indx) {
+                    struct STRING_DESC configString;
+                    MemoryOperations::memset(&configString, 0, sizeof(struct STRING_DESC));
+                    if(this->controller->GetStringDescriptor(&configString, this, c->config_indx, 0x0409))
+                    {
+                        int strLen = (configString.len-2)/2;
+                        if(strLen > 0) {
+                            //Convert Unicode string to ASCII
+                            char* tmp = new char[strLen + 1];
+                            tmp[strLen] = '\0';
+                            for(int i = 0; i < strLen; i++)
+                                tmp[i] = configString.string[i];
+                            
+                            Log(Info, "     Config String -> %s", tmp);
+                            delete tmp;
+                        }
+                    }
+                }
+            }
+            else if (length == 9 && type == INTERFACE) // INTERFACE descriptor
+            {
+                struct INTERFACE_DESC* c = (struct INTERFACE_DESC*)startByte;
+                Log(Info, "USBDevice Interface Desc: Num=%d Alt=%d NumEP=%d Class=%w Subclass=%w Protocol=%w StrIndx=%d", c->interface_num, c->alt_setting, c->num_endpoints, c->interface_class, c->interface_sub_class, c->interface_protocol, c->interface_indx);
+                if(c->interface_num == 0) //First Interface
+                {
+                    if(this->classID == 0) this->classID = c->interface_class;
+                    if(this->subclassID == 0) this->subclassID = c->interface_sub_class;
+                    if(this->protocol == 0) this->protocol = c->interface_protocol;
+                }
+            }
+            else if (length == 7 && type == ENDPOINT) // ENDPOINT descriptor
+            {
+                struct ENDPOINT_DESC* c = (struct ENDPOINT_DESC*)startByte;
+                Log(Info, "USBDevice Endpoint Desc: Num=%d %s TransferType=%d MaxPacket=%d Interval=%d", c->end_point & 0xF, (c->end_point & (1<<7)) ? "In" : "Out", c->bm_attrbs & 0b11, c->max_packet_size, c->interval);
+
+                this->endpoints.push_back(new USBEndpoint(c));
+            }
+            else if (type == HID) // HID descriptor
+            {
+                struct IF_HID_DESC* c = (struct IF_HID_DESC*)startByte;
+                Log(Info, "USBDevice HID Desc: Release = %w CountryCode = %d NumDescriptors = %d", c->release, c->countryCode, c->numDescriptors);
+
+                this->hidDescriptor = new uint8_t[c->len];
+                MemoryOperations::memcpy(this->hidDescriptor, c, c->len);
+            }
+            else if (length == 0) // Unvallid entry
+            {
+                Log(Warning, "Found descriptor entry of size 0, assuming remaining data is invalid");
+                break;
+            }
+            else
+                Log(Warning, "Unknown part of ConfigDescriptor: length: %d type: %d", length, type);
+
+
+            startByte += length;
+        }
+        delete configBuffer;
+    }
+
+    //Set Default Configuration
+    if(!this->controller->SetConfiguration(this, 1)) {
+        Log(Error, "Error Setting Device config to 1");
+        return false;
+    }
+
+    //Print Class Info
+    char* hexClass = Convert::IntToHexString((uint8_t)this->classID);
+    for(int i = 0; i < numClassCodeStrings; i++)
+        if(String::strncmp(hexClass, USBClassCodeStrings[i], 2) == true) {
+            Log(Info, "USB Class: %s", USBClassCodeStrings[i] + 3);
+            break;
+        }
+
+    ////////////
+    // Driver Selection
+    ////////////
+    if(this->productID == 0xc52e && this->vendorID == 0x046d)
+        this->driver = new USBComboReceiver(this);
+    else if(this->classID == 0x08 && this->subclassID == 0x06 && this->protocol == 0x50) {
+        this->driver = new USBMassStorageDriver(this);
+    }
+    else if(this->classID == 0x03 && this->protocol == 0x02) {
+        this->driver = new USBMouse(this);
+    }
+    else if(this->classID == 0x03 && this->protocol == 0x01) {
+        this->driver = new USBKeyboard(this);
+    }
+
+    ////////////
+    // Initialize Driver
+    ////////////
+    if(this->driver != 0)
+    {
+        if(this->driver->Initialize())
+            return true;
+        else 
+        {
+            delete this->driver;
+            this->driver = 0;
+            return false;
+        }
+    }
+
+    return false;
+}
+USBDevice::~USBDevice()
+{
+    for(USBEndpoint* endP : this->endpoints)
+        delete endP;
+}
+void USBDevice::OnUnplugged()
+{
+    if(this->driver != 0) {
+        Log(Info, "Unloading driver %s", this->driver->GetDriverName());
+        this->driver->DeInitialize();
+    }
+    else
+        Log(Info, "No driver found for this device");
+}
\ No newline at end of file
diff --git a/kernelz/src/system/usb/usbendpoint.cpp b/kernelz/src/system/usb/usbendpoint.cpp
new file mode 100644
index 0000000..dd2ba50
--- /dev/null
+++ b/kernelz/src/system/usb/usbendpoint.cpp
@@ -0,0 +1,25 @@
+#include <system/usb/usbendpoint.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+
+USBEndpoint::USBEndpoint(struct ENDPOINT_DESC* src)
+{
+    this->endpointNumber = src->end_point & 0xF;
+    this->dir = (src->end_point & (1<<7)) ? EndpointDirection::In : EndpointDirection::Out;
+    this->type = (EndpointType)(src->bm_attrbs & 0b11);
+    this->maxPacketSize = src->max_packet_size;
+    this->interval = src->interval;
+}
+
+bool USBEndpoint::Toggle()
+{
+    this->toggleState = !this->toggleState;
+    return !this->toggleState; // Return original value
+}
+
+void USBEndpoint::SetToggle(bool v)
+{
+    this->toggleState = v;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/usb/usbmanager.cpp b/kernelz/src/system/usb/usbmanager.cpp
new file mode 100644
index 0000000..65318b9
--- /dev/null
+++ b/kernelz/src/system/usb/usbmanager.cpp
@@ -0,0 +1,79 @@
+#include <system/usb/usbmanager.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+using namespace CactusOS::system::drivers;
+
+extern char* USBControllerStrings[];
+
+USBManager::USBManager()
+: controllerList(), deviceList()
+{
+    this->initDone = false;
+}
+
+void USBManager::USBPoll()
+{
+    for(USBController* c : controllerList)
+        c->ControllerChecksThread();
+}
+
+void USBManager::AddController(USBController* c)
+{
+    controllerList.push_front(c);
+}
+void USBManager::RemoveController(USBController* c)
+{
+    controllerList.Remove(c);
+}
+void USBManager::AddDevice(USBDevice* c)
+{
+    deviceList.push_back(c);
+
+    if(this->initDone) {
+        if(c->AssignDriver())
+            Log(Info, "USBDevice %s driver assignment succes!", c->deviceName != 0 ? c->deviceName : "Unnamed");
+        else
+            Log(Warning, "USBDevice %s driver assignment failed!", c->deviceName != 0 ? c->deviceName : "Unnamed");
+    }
+}
+void USBManager::RemoveDevice(USBController* controller, uint8_t port)
+{
+    USBDevice* dev = 0;
+    for(USBDevice* c : deviceList)
+        if(c->controller == controller && c->portNum == port) {
+            dev = c;
+            break;
+        }
+    
+    if(dev == 0 || !initDone)
+        Log(Error, "Device was removed from port but no USBDevice was found!");
+    else
+    {
+        Log(Info, "Device %s Removed at port %d from %s controller", dev->deviceName != 0 ? dev->deviceName : "Unnamed", port, USBControllerStrings[dev->controller->type]);
+        deviceList.Remove(dev);
+        dev->OnUnplugged();
+        delete dev;
+    }
+}
+
+void USBManager::SetupAll()
+{
+    for(USBController* c : controllerList)
+        c->Setup();
+}
+
+void USBManager::AssignAllDrivers()
+{
+    for(USBDevice* c : deviceList) {
+        if(c->AssignDriver())
+            Log(Info, "USBDevice %s driver assignment succes!", c->deviceName != 0 ? c->deviceName : "Unnamed");
+        else
+            Log(Warning, "USBDevice %s driver assignment failed!", c->deviceName != 0 ? c->deviceName : "Unnamed");
+    }
+    this->initDone = true;
+}
+
diff --git a/kernelz/src/system/vfs/fat.cpp b/kernelz/src/system/vfs/fat.cpp
new file mode 100644
index 0000000..7e80b84
--- /dev/null
+++ b/kernelz/src/system/vfs/fat.cpp
@@ -0,0 +1,1179 @@
+#include <system/vfs/fat.h>
+
+#include <system/log.h>
+#include <system/system.h>
+
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+FAT::FAT(Disk* disk, uint32_t start, uint32_t size)
+: VirtualFileSystem(disk, start, size) 
+{
+    this->Name = "FAT Filesystem";
+    MemoryOperations::memset(&this->fsInfo, 0, sizeof(FAT32_FSInfo));
+}
+
+FAT::~FAT()
+{
+    delete this->readBuffer;
+}
+
+bool FAT::Initialize()
+{
+    Log(Info, "Initializing FAT Filesystem");
+
+    FAT32_BPB bpb;
+    if(this->disk->ReadSector(this->StartLBA, (uint8_t*)&bpb) != 0)
+        return false;
+
+    this->bytesPerSector = bpb.bytesPerSector;
+    this->rootDirSectors = ((bpb.NumDirEntries * 32) + (this->bytesPerSector - 1)) / this->bytesPerSector;
+    this->sectorsPerCluster = bpb.SectorsPerCluster;
+    this->firstFatSector = bpb.ReservedSectors;
+    this->clusterSize = this->bytesPerSector * this->sectorsPerCluster;
+
+    // Allocate Read Buffer
+    this->readBuffer = new uint8_t[this->bytesPerSector];
+
+    // Size of one FAT in clusters
+    uint32_t FatSize = bpb.SectorsPerFat12_16 != 0 ? bpb.SectorsPerFat12_16 : bpb.SectorsPerFat32;
+    
+    // Calculate first data sector
+    this->firstDataSector = bpb.ReservedSectors + (bpb.NumOfFats * FatSize) + this->rootDirSectors;
+    
+    // Total count of sectors used for the entire filesystem
+    uint32_t TotalSectors = bpb.TotalSectorsSmall != 0 ? bpb.TotalSectorsSmall : bpb.TotalSectorsBig;
+
+    // How much sectors does the complete data region have in use?
+    uint32_t DataSectors = TotalSectors - (bpb.ReservedSectors + (bpb.NumOfFats * FatSize) + this->rootDirSectors);
+
+    // Total amount of clusters, clusters are only used in the data area
+    this->totalClusters = DataSectors / this->sectorsPerCluster;
+
+    // Now we can determine the type of filesystem we are dealing with
+    if(this->totalClusters < 4085) {
+        this->FatType = FAT12;
+        this->FatTypeString = "FAT12";
+    } else if(this->totalClusters < 65525) {
+        this->FatType = FAT16;
+        this->FatTypeString = "FAT16";
+    } else {
+        this->FatType = FAT32;
+        this->FatTypeString = "FAT32";
+    }
+
+    if(this->FatType == FAT12 || this->FatType == FAT16)
+        this->rootDirCluster = bpb.ReservedSectors + (bpb.NumOfFats * FatSize);
+    else
+        this->rootDirCluster = bpb.RootDirCluster;
+
+    // Check for FSInfo structure and read it into this->fsInfo
+    if(this->FatType == FAT32 && bpb.FSInfoSector > 0) {
+        if(this->disk->ReadSector(this->StartLBA + bpb.FSInfoSector, (uint8_t*)&this->fsInfo) != 0)
+            return false;
+    }
+
+#if 1
+    Log(Info, "%s Filesystem Summary: ", this->FatTypeString);
+    Log(Info, "      Bytes Per Sector: %d", this->bytesPerSector);
+    Log(Info, "          Root Sectors: %d", this->rootDirSectors);
+    Log(Info, "       Sectors/Cluster: %d", this->sectorsPerCluster);
+    Log(Info, "     First Data Sector: %d", this->firstDataSector);
+    Log(Info, "      Reserved Sectors: %d", bpb.ReservedSectors);
+    if(this->FatType == FAT32) {
+        Log(Info, "  FSInfo Free Clusters: %x", this->fsInfo.lastFreeCluster);
+        Log(Info, "   FSInfo Start Search: %x", this->fsInfo.startSearchCluster);
+    }
+#endif
+
+    if(this->fsInfo.startSearchCluster == 0xFFFFFFFF)   // Unkown
+            this->fsInfo.startSearchCluster = 2;        // Then we use the default value
+
+    else if(this->FatType == FAT12 || this->FatType == FAT16)
+        this->fsInfo.startSearchCluster = 2; // Might as well still use this variable for FAT12/FAT16
+
+    return true;
+}
+
+inline uint32_t FAT::ClusterToSector(uint32_t cluster) {
+    return ((cluster - 2) * this->sectorsPerCluster) + this->firstDataSector;
+}
+
+
+uint32_t FAT::ReadTable(uint32_t cluster)
+{
+    if(cluster < 2 || cluster > this->totalClusters) {
+        Log(Error, "%s invallid cluster number %d", this->FatTypeString, cluster);
+        return 0;
+    }
+    
+    if(this->FatType == FAT32)
+    {
+        uint32_t fatOffset = cluster * 4;
+        uint32_t fatSector = this->firstFatSector + (fatOffset / this->bytesPerSector);
+        uint32_t entOffset = fatOffset % this->bytesPerSector;
+        
+        if(this->disk->ReadSector(this->StartLBA + fatSector, this->readBuffer) != 0)
+            return 0;
+        
+        //remember to ignore the high 4 bits.
+        return *(uint32_t*)&this->readBuffer[entOffset] & 0x0FFFFFFF;
+    }
+    else if(this->FatType == FAT16)
+    {
+        uint32_t fatOffset = cluster * 2;
+        uint32_t fatSector = this->firstFatSector + (fatOffset / this->bytesPerSector);
+        uint32_t entOffset = fatOffset % this->bytesPerSector;
+        
+        if(this->disk->ReadSector(this->StartLBA + fatSector, this->readBuffer) != 0)
+            return 0;
+        
+        return *(uint16_t*)&this->readBuffer[entOffset];
+    }
+    else // FAT12
+    {
+        uint32_t fatOffset = cluster + (cluster / 2); // multiply by 1.5
+        uint32_t fatSector = this->firstFatSector + (fatOffset / this->bytesPerSector);
+        uint32_t entOffset = fatOffset % this->bytesPerSector;
+        
+        if(this->disk->ReadSector(this->StartLBA + fatSector, this->readBuffer) != 0)
+            return 0;
+        
+        uint16_t tableValue = *(uint16_t*)&this->readBuffer[entOffset];
+        
+        if(cluster & 0x0001)
+            tableValue = tableValue >> 4;
+        else
+            tableValue = tableValue & 0x0FFF;
+
+        return tableValue;
+    }
+}
+
+void FAT::WriteTable(uint32_t cluster, uint32_t value)
+{
+    if(cluster < 2 || cluster > this->totalClusters) {
+        Log(Error, "%s invallid cluster number %d", this->FatTypeString, cluster);
+        return;
+    }
+
+    if(this->FatType == FAT32)
+    {
+        uint32_t fatOffset = cluster * 4;
+        uint32_t fatSector = this->firstFatSector + (fatOffset / this->bytesPerSector);
+        uint32_t entOffset = fatOffset % this->bytesPerSector;
+        
+        if(this->disk->ReadSector(this->StartLBA + fatSector, this->readBuffer) != 0)
+            return;
+        
+        *(uint32_t*)&this->readBuffer[entOffset] = value;
+
+        if(this->disk->WriteSector(this->StartLBA + fatSector, this->readBuffer) != 0)
+            Log(Error, "Could not write new FAT value for cluster %d", cluster);
+    }
+    else if(this->FatType == FAT16)
+    {
+        uint32_t fatOffset = cluster * 2;
+        uint32_t fatSector = this->firstFatSector + (fatOffset / this->bytesPerSector);
+        uint32_t entOffset = fatOffset % this->bytesPerSector;
+        
+        if(this->disk->ReadSector(this->StartLBA + fatSector, this->readBuffer) != 0)
+            return;
+        
+        *(uint16_t*)&this->readBuffer[entOffset] = (uint16_t)value;
+
+        if(this->disk->WriteSector(this->StartLBA + fatSector, this->readBuffer) != 0)
+            Log(Error, "Could not write new FAT value for cluster %d", cluster);       
+    }
+    else // FAT12
+    {
+        uint32_t fatOffset = cluster + (cluster / 2); // multiply by 1.5
+        uint32_t fatSector = this->firstFatSector + (fatOffset / this->bytesPerSector);
+        uint32_t entOffset = fatOffset % this->bytesPerSector;
+        
+        if(this->disk->ReadSector(this->StartLBA + fatSector, this->readBuffer) != 0)
+            return;
+        
+        if(cluster & 0x0001) {
+            value = value << 4;	/* Cluster number is ODD */
+            *((uint16_t*)(&this->readBuffer[entOffset])) = (*((uint16_t*)(&this->readBuffer[entOffset]))) & 0x000F;
+        } else {
+            value = value & 0x0FFF;	/* Cluster number is EVEN */
+            *((uint16_t*)(&this->readBuffer[entOffset])) = (*((uint16_t*)(&this->readBuffer[entOffset]))) & 0xF000;
+        }
+        *((uint16_t*)(&this->readBuffer[entOffset])) = (*((uint16_t*)(&this->readBuffer[entOffset]))) | value;
+
+
+        if(this->disk->WriteSector(this->StartLBA + fatSector, this->readBuffer) != 0)
+            Log(Error, "Could not write new FAT value for cluster %d", cluster);  
+    }
+}
+
+uint32_t FAT::AllocateCluster()
+{
+    // Use start cluster from fsInfo, this is also valid for FAT12/FAT16 thanks to some magic.
+	uint32_t cluster = this->fsInfo.startSearchCluster;
+
+	//Iterate through the clusters, looking for a free cluster
+	while (cluster < this->totalClusters)
+	{
+	    uint32_t value = ReadTable(cluster);
+
+		if (value == CLUSTER_FREE) {                    // Cluster found, allocate it.
+            this->fsInfo.startSearchCluster = cluster;  // Update fsInfo structure
+			WriteTable(cluster, CLUSTER_END);           // Write EOC to the cluster
+			return cluster;
+        }
+
+		cluster++; //cluster is taken, check the next one
+	}
+	return 0;
+}
+
+void FAT::ClearCluster(uint32_t cluster)
+{
+    uint32_t sector = ClusterToSector(cluster);
+    MemoryOperations::memset(this->readBuffer, 0, this->bytesPerSector);
+
+    // Clear each sector of cluster
+    for(uint8_t i = 0; i < this->sectorsPerCluster; i++)
+        if(this->disk->WriteSector(this->StartLBA + sector + i, this->readBuffer) != 0) {
+            Log(Error, "Could not clear sector %d of cluster %d", sector, cluster);
+            return;
+        }
+}
+
+// Parse a directory and return its entries
+List<FATEntryInfo> FAT::GetDirectoryEntries(uint32_t dirCluster, bool rootDirectory)
+{
+    List<FATEntryInfo> results;
+    List<LFNEntry> lfnEntries;
+
+    uint32_t sector = 0;    
+    uint32_t cluster = dirCluster;
+
+    while ((cluster != CLUSTER_FREE) && (cluster < CLUSTER_END))
+    {
+        /*
+        With FAT12 and FAT16 the root directory is positioned after the File Allocation Table
+        This is calculated below
+        FAT32 does not use this technique
+        */
+
+        if(rootDirectory && this->FatType != FAT32 && sector == 0)
+            sector = this->firstDataSector - this->rootDirSectors;
+        
+        else if(this->FatType == FAT32 || !rootDirectory)
+            sector = ClusterToSector(cluster);
+
+        for(uint16_t i = 0; i < this->sectorsPerCluster; i++) // Loop through sectors in this cluster
+        {
+            if(this->disk->ReadSector(this->StartLBA + sector + i, this->readBuffer) != 0) {
+                Log(Error, "Error reading disk at lba %d", this->StartLBA + sector + i);
+                return results;
+            }
+
+            for(uint8_t entryIndex = 0; entryIndex < (this->bytesPerSector / sizeof(DirectoryEntry)); entryIndex++) // Loop through entries in this sector
+            {
+                DirectoryEntry* entry = (DirectoryEntry*)(this->readBuffer + entryIndex * sizeof(DirectoryEntry));
+
+                if(entry->FileName[0] == ENTRY_END) // End of entries
+                    return results;
+                
+                if(entry->FileName[0] == ENTRY_UNUSED) // Unused entry, probably deleted or something
+                    continue; // Just skip this entry
+
+                if(entry->FileName[0] == 0x2E) // . or .. entry
+                    continue;
+
+                if(entry->FileName[0] == 0x05) // Pending file to delete apparently
+                    continue;
+
+                if(entry->Attributes == ATTR_VOLUME_ID) // Volume ID of filesystem
+                    continue;
+                
+                if(entry->Attributes == ATTR_LONG_NAME) {   // Long file name entry
+                    LFNEntry* lfn = (LFNEntry*)entry;       // Turn the directory entry into a LFNEntry using the magic of pointers
+                    lfnEntries.push_back(*lfn);             // Add it to our buffer
+                    continue;
+                }
+
+                // This is a valid entry, so add it to our list
+                FATEntryInfo item;
+                item.entry = *entry;
+                item.sector = sector + i;
+                item.offsetInSector = entryIndex * sizeof(DirectoryEntry);
+                if(lfnEntries.size() > 0) { // We have some LFN entries in our list that belong to this entry
+                    item.filename = ParseLFNEntries(&lfnEntries, *entry);
+                    lfnEntries.Clear();
+                }
+                else
+                    item.filename = ParseShortFilename((char*)entry->FileName);
+                
+                results.push_back(item);
+            }
+        }
+
+        if(rootDirectory && this->FatType != FAT32) {
+            //FAT_DEBUG("FAT Root directory has more than 16 entries, reading next sector", 0);
+            sector++;
+            continue; // No need to calculate the next cluster
+        }
+
+        cluster = ReadTable(cluster);
+        //Log(Info, "Next cluster is %x", cluster);
+    }
+    Log(Error, "This should not be reached %s %d", __FILE__, __LINE__);
+    return results;
+}
+
+FATEntryInfo* FAT::SeachInDirectory(char* name, uint32_t dirCluster, bool rootDirectory)
+{
+    List<FATEntryInfo> childs = GetDirectoryEntries(dirCluster, rootDirectory);
+    FATEntryInfo* ret = 0;
+
+    for(FATEntryInfo item : childs) {
+        bool match = String::strcmp(name, item.filename);
+        if(!ret && match) {
+            ret = new FATEntryInfo();
+            MemoryOperations::memcpy(ret, &item, sizeof(FATEntryInfo));
+        }
+        if(!match) // We can not delete the string that is returned as result
+            delete item.filename;
+    }
+
+    childs.Clear();
+    return ret;
+}
+
+FATEntryInfo* FAT::GetEntryByPath(char* path)
+{
+    uint32_t searchCluster = this->rootDirCluster;
+    List<char*> pathList = String::Split(path, PATH_SEPERATOR_C);
+    FATEntryInfo* ret = 0;
+
+    // The path represents a entry in the root directory, for example just: "test.txt"
+    if(pathList.size() == 0)
+        return SeachInDirectory(path, searchCluster, true);
+    
+    // Loop through each part in the filename
+    for(int i = 0; i < pathList.size(); i++)
+    {
+        FATEntryInfo* entry = SeachInDirectory(pathList[i], searchCluster, i == 0);
+        if(entry == 0) { // Error while getting entry in directory
+            ret = 0;
+            goto end;
+        }
+        
+        if(i == pathList.size() - 1) {
+            ret = entry; // This is the last entry in the list, so this is the correct one
+            goto end;
+        }
+
+        bool isDirectory = (entry->entry.Attributes & ATTR_DIRECTORY);
+        if(isDirectory)
+            searchCluster = GET_CLUSTER(entry->entry); // Search next sub-directory
+
+        delete entry->filename;
+        delete entry;
+        
+        if(!isDirectory) { // Item found is not a directory 
+            ret = 0;
+            goto end;
+        }
+    }
+    // Entry not found
+    ret = 0;
+
+end:
+    for(char* str : pathList)
+        delete str;
+    
+    return ret;
+}
+
+#pragma region Filename Conversion
+
+// Calculate checksum for 8.3 filename
+uint8_t FAT::Checksum(char* filename)
+{
+	uint8_t Sum = 0;
+	for (uint8_t len = 11; len != 0; len--) {
+		// NOTE: The operation is an unsigned char rotate right
+		Sum = ((Sum & 1) ? 0x80 : 0) + (Sum >> 1) + *filename++;
+	}
+	return Sum;
+}
+
+// Parse a list of long file name entries, also pass the 8.3 entry for the checksum
+char* FAT::ParseLFNEntries(List<LFNEntry>* entries, DirectoryEntry sfnEntry)
+{
+    // Calculate checksum of short file name
+    uint8_t shortChecksum = Checksum((char*)sfnEntry.FileName);
+
+    // Allocate space for complete name
+    char* longName = new char[entries->size() * 13 + 1]; // Each LFN holds 13 characters + one for termination
+    MemoryOperations::memset(longName, 0, entries->size() * 13 + 1);
+
+    for(LFNEntry item : *entries)
+    {
+        if(item.checksum != shortChecksum) {
+            Log(Error, "Checksum of LFN entry is incorrect");
+            return longName;
+        }
+
+        uint8_t index = item.entryIndex & 0x0F;
+        char* namePtr = longName + ((index - 1) * 13);
+
+        // First part of filename
+        for(int i = 0; i < 9; i+=2) {
+            if(item.namePart1[i] >= 32 && item.namePart1[i] <= 127) // Valid character
+                *namePtr = item.namePart1[i];
+            else
+                *namePtr = 0;
+            namePtr++;
+        }
+
+        // Second part of filename
+        for(int i = 0; i < 11; i+=2) {
+            if(item.namePart2[i] >= 32 && item.namePart2[i] <= 127) // Valid character
+                *namePtr = item.namePart2[i];
+            else
+                *namePtr = 0;
+            namePtr++;
+        }
+
+        // Third part of filename
+        for(int i = 0; i < 3; i+=2) {
+            if(item.namePart3[i] >= 32 && item.namePart3[i] <= 127) // Valid character
+                *namePtr = item.namePart3[i];
+            else
+                *namePtr = 0;
+            namePtr++;
+        }
+    }
+    return longName;
+}
+
+// Turn a FAT filename into a readable one
+char* FAT::ParseShortFilename(char* str)
+{
+    char* outFileName = new char[12];
+    MemoryOperations::memset(outFileName, 0, 12);
+
+    int mainEnd, extEnd;
+	for(mainEnd = 8; mainEnd > 0 && str[mainEnd - 1] == ' '; mainEnd--);
+
+	MemoryOperations::memcpy(outFileName, str, mainEnd);
+
+	for(extEnd = 3; extEnd > 0 && str[extEnd - 1 + 8] == ' '; extEnd--);
+
+	if(extEnd == 0)
+		return String::Lowercase(outFileName);
+
+	outFileName[mainEnd] = '.';
+	MemoryOperations::memcpy(outFileName + mainEnd + 1, (const char*)str + 8, extEnd);
+    
+    return String::Lowercase(outFileName);
+}
+
+#pragma endregion
+
+#pragma region Write Support
+
+bool FAT::FindEntryStartpoint(uint32_t cluster, uint32_t entryCount, bool rootDirectory, uint32_t* targetCluster, uint32_t* targetSector, uint32_t* sectorOffset)
+{
+    uint32_t sector = 0;
+    uint32_t freeCount = 0;
+    while ((cluster != CLUSTER_FREE) && (cluster < CLUSTER_END))
+    {
+        // For explanation check FAT::GetDirectoryEntries()
+        if(rootDirectory && this->FatType != FAT32 && sector == 0)
+            sector = this->firstDataSector - this->rootDirSectors;
+        
+        else if(this->FatType == FAT32 || !rootDirectory)
+            sector = ClusterToSector(cluster);
+
+        for(uint16_t i = 0; i < this->sectorsPerCluster; i++) // Loop through sectors in this cluster
+        {
+            if(this->disk->ReadSector(this->StartLBA + sector + i, this->readBuffer) != 0) {
+                Log(Error, "Error reading disk at lba %d", this->StartLBA + sector + i);
+                return false;
+            }
+
+            for(uint8_t entryIndex = 0; entryIndex < (this->bytesPerSector / sizeof(DirectoryEntry)); entryIndex++) // Loop through entries in this sector
+            {
+                DirectoryEntry* entry = (DirectoryEntry*)(this->readBuffer + entryIndex * sizeof(DirectoryEntry));
+
+                if(entry->FileName[0] == ENTRY_END || entry->FileName[0] == ENTRY_UNUSED) // Unused or free entry
+                {
+                    if(freeCount == 0) { // First free entry
+                        // Store start variables
+                        *targetCluster = cluster;
+                        *targetSector = i;
+                        *sectorOffset = entryIndex * sizeof(DirectoryEntry);
+                    }
+
+                    freeCount++; // Increase the count of free entries
+                    if(freeCount == entryCount) {   // We need exaclty this amount of free entries
+                        return true;                // Variables should be filled in already
+                    }
+                }
+                else {
+                    freeCount = 0;        // Reset Counter
+                    *targetCluster = 0;   // And Variables
+                    *targetSector = 0;
+                    *sectorOffset = 0;
+                }
+            }
+        }
+
+        if(rootDirectory && this->FatType != FAT32) {
+            //FAT_DEBUG("FAT Root directory has more than 16 entries, reading next sector", 0);
+            sector++;
+
+            uint32_t rootDirLastSector = this->firstDataSector - this->rootDirSectors + (224 * sizeof(DirectoryEntry) / this->bytesPerSector);
+            if(sector >= rootDirLastSector) {
+                Log(Warning, "FAT Root directory has no more space for new entries");
+                return false; // Let's hope this never happens
+            }
+
+            continue; // No need to calculate the next cluster
+        }
+
+        uint32_t next = ReadTable(cluster);             // Read next cluster in list
+        if(next >= CLUSTER_END) {                       // No more clusters in this row
+            uint32_t newCluster = AllocateCluster();    // Just allocate a new one for this directory
+            ClearCluster(newCluster);                   // Empty cluster
+            WriteTable(cluster, newCluster);            // Add to the clusterchain
+            cluster = newCluster;
+        }
+        else
+            cluster = next;
+    }
+    return false;
+}
+
+char* FAT::CreateShortFilename(char* name)
+{
+    char* result = new char[12];
+    MemoryOperations::memset(result, ' ', 11);
+    result[11] = '\0';
+
+    int len = String::strlen(name);
+    int dotIndex = String::IndexOf(name, '.');
+
+    // Write the extension
+    if(dotIndex >= 0) {
+        for(int i = 0; i < 3; i++) {
+            int charIndex = dotIndex + 1 + i;
+            uint8_t c = charIndex >= len ? ' ' : String::Uppercase(name[charIndex]);
+            result[8 + i] = c;
+        }
+    }
+    // No extension in name
+    else {
+        for(int i = 0; i < 3; i++) {
+            result[8 + i] = ' ';
+        }
+    }
+
+    // Write the filename.
+    int flen = len;
+    if(dotIndex >= 0)
+        flen = dotIndex;
+    
+    if(flen > 8) {
+        // Write the name with the thingy
+        for(int i = 0; i < 6; i++)
+            result[i] = String::Uppercase(name[i]);
+
+        result[6] = '~';
+        result[7] = '1'; // Just assume there is only one version of this file
+    }
+    else {
+        // Just write the file name.
+        for(int i = 0; i < flen; i++) {
+            result[i] = String::Uppercase(name[i]);
+        }
+    }
+
+    return result;
+}
+
+List<LFNEntry> FAT::CreateLFNEntriesFromName(char* name, int num, uint8_t checksum)
+{
+    List<LFNEntry> entries;
+
+    int charsWritten = 0;
+    int nameLen = String::strlen(name);
+    char* namePtr = name;
+
+    for(int n = 0; n < num; n++)
+    {
+        LFNEntry entry;
+        MemoryOperations::memset(&entry, 0, sizeof(LFNEntry));
+
+        entry.entryIndex = n + 1;
+        entry.checksum = checksum;
+        entry.Attributes = ATTR_LONG_NAME;
+
+        // First part of filename
+        for(int i = 0; i < 9; i+=2) {
+            if(charsWritten < nameLen)
+                entry.namePart1[i] = *namePtr;
+            else
+                entry.namePart1[i] = 0;
+            namePtr++;
+            charsWritten++;
+        }
+
+        // Second part of filename
+        for(int i = 0; i < 11; i+=2) {
+            if(charsWritten < nameLen)
+                entry.namePart2[i] = *namePtr;
+            else
+                entry.namePart2[i] = 0;
+            namePtr++;
+            charsWritten++;
+        }
+
+        // Third part of filename
+        for(int i = 0; i < 3; i+=2) {
+            if(charsWritten < nameLen)
+                entry.namePart3[i] = *namePtr;
+            else
+                entry.namePart3[i] = 0;
+            namePtr++;
+            charsWritten++;
+        }
+
+        // Last entry in row
+        if(n == num-1)
+            entry.entryIndex |= LFN_ENTRY_END;
+        
+        entries.push_front(entry);
+    }
+    
+    return entries;
+}
+
+bool FAT::WriteLongFilenameEntries(List<LFNEntry>* entries, uint32_t targetCluster, uint32_t targetSector, uint32_t sectorOffset, bool rootDirectory)
+{
+    uint32_t sector = 0;
+    for(int i = 0; i < entries->size(); i++)
+    {
+        uint32_t entryOffset = sectorOffset + i * sizeof(DirectoryEntry);
+
+        if(rootDirectory && this->FatType != FAT32 && sector == 0)
+            sector = this->firstDataSector - this->rootDirSectors;
+        
+        else if(this->FatType == FAT32 || !rootDirectory)
+            sector = ClusterToSector(targetCluster);
+        
+        if(this->disk->ReadSector(this->StartLBA + sector + targetSector, this->readBuffer) != 0)
+            return false;
+
+        // Copy entry to free spot
+        LFNEntry target = entries->GetAt(i);
+        MemoryOperations::memcpy(this->readBuffer + entryOffset, &target, sizeof(LFNEntry));
+
+        // And copy back to the disk
+        if(this->disk->WriteSector(this->StartLBA + sector + targetSector, this->readBuffer) != 0)
+            return false;
+
+        if(entryOffset + sizeof(DirectoryEntry) >= this->bytesPerSector) { // Check if we get outside of sector border for next write
+            if(rootDirectory && this->FatType != FAT32) {
+                sector++;           // Move onto next sector
+                sectorOffset = 0;   // And reset offset
+            }
+            else if((this->FatType == FAT32) || (!rootDirectory)) {
+                if(sector + 1 > this->sectorsPerCluster) // Outside cluster boundary
+                    targetCluster = ReadTable(targetCluster);
+                else
+                    sector++;
+            }
+        }
+    }
+    return true;
+}
+
+bool FAT::WriteDirectoryEntry(DirectoryEntry entry, uint32_t targetSector, uint32_t sectorOffset, bool rootDirectory)
+{
+    // Read disk at sector
+    if(this->disk->ReadSector(this->StartLBA + targetSector, this->readBuffer) != 0)
+        return false;
+
+    // Copy entry to free spot
+    MemoryOperations::memcpy(this->readBuffer + sectorOffset, &entry, sizeof(DirectoryEntry));
+
+    // And copy back to the disk
+    if(this->disk->WriteSector(this->StartLBA + targetSector, this->readBuffer) != 0)
+        return false;
+    
+    return true;
+}
+
+DirectoryEntry* FAT::CreateEntry(uint32_t parentCluster, char* name, uint8_t attr, bool rootDirectory, uint32_t targetCluster, uint32_t* sectorPlaced)
+{
+    // Length of complete name
+    uint8_t nameLength = String::strlen(name);
+    if(nameLength == 0)
+        return 0;
+
+    // How many LFN entries do we need?
+    uint32_t requiredLFNEntries = nameLength / 13;
+    if(nameLength % 13 > 0)
+        requiredLFNEntries++;
+
+    // How many Directory entries do we need in total? (Including LFN)
+    uint32_t requiredEntries = requiredLFNEntries + 1;
+
+    uint32_t entryCluster, entrySector, sectorOffset;
+    if(FindEntryStartpoint(parentCluster, requiredEntries, rootDirectory, &entryCluster, &entrySector, &sectorOffset) == false)
+        return 0;
+    
+    //FAT_DEBUG("Placing new chain of entries at %d:%d:%d", entryCluster, entrySector, sectorOffset);
+
+    char* shortName = CreateShortFilename(name);
+    List<LFNEntry> lfnEntries = CreateLFNEntriesFromName(name, requiredLFNEntries, Checksum(shortName));
+
+    //FAT_DEBUG"Writing %d LFN Entries to disk", lfnEntries.size());
+    if(WriteLongFilenameEntries(&lfnEntries, entryCluster, entrySector, sectorOffset, rootDirectory) == false) {
+        delete shortName;
+        return 0;
+    }
+
+    if(rootDirectory && this->FatType != FAT32)
+    {
+        entrySector = this->firstDataSector - this->rootDirSectors;
+        sectorOffset += lfnEntries.size() * sizeof(LFNEntry);
+        if(sectorOffset >= this->bytesPerSector) {
+            entrySector++;
+            sectorOffset = sectorOffset % this->bytesPerSector;
+        }
+    }
+    else
+    {
+        sectorOffset += lfnEntries.size() * sizeof(LFNEntry);
+        if(sectorOffset >= this->bytesPerSector) {
+            entrySector++;
+            sectorOffset = sectorOffset % this->bytesPerSector;
+
+            if(entrySector >= this->sectorsPerCluster) {
+                entryCluster = ReadTable(entryCluster);
+                entrySector = 0;
+                //sectorOffset = sectorOffset % this->bytesPerSector;
+
+                if(entryCluster >= CLUSTER_END) {
+                    uint32_t tmp = AllocateCluster();
+                    ClearCluster(tmp);
+                    WriteTable(entryCluster, tmp);
+                    entryCluster = tmp;
+                }
+            }
+        }
+
+        entrySector = ClusterToSector(entryCluster) + entrySector;
+    }
+
+    // Create entry to write to the disk
+    DirectoryEntry entry;
+    MemoryOperations::memset(&entry, 0, sizeof(DirectoryEntry));
+
+    // Copy name
+    MemoryOperations::memcpy(entry.FileName, shortName, 11);
+
+    // Set cluster
+    entry.LowFirstCluster = targetCluster & 0xFFFF;
+    entry.HighFirstCluster = (targetCluster >> 16) & 0xFFFF;
+
+    // Set Attributes
+    entry.Attributes = attr;
+
+    // Set Date and Time
+    entry.CreationDate = FatDate();
+    entry.CreationTime = FatTime();
+    entry.CreationTimeTenth = 100;
+    entry.AccessDate = entry.CreationDate;
+    entry.ModifyDate = entry.CreationDate;
+    entry.ModifyTime = entry.CreationTime;
+
+    // Finaly write it to the disk
+    if(WriteDirectoryEntry(entry, entrySector, sectorOffset, rootDirectory) == false) {
+        delete shortName;
+        return 0;
+    }
+    
+    // Free memory used by name creation
+    delete shortName;
+
+    // Set return variables and return
+    if(sectorPlaced)
+        *sectorPlaced = entrySector;
+    
+    return (DirectoryEntry*)(this->readBuffer + sectorOffset);
+}
+
+int FAT::CreateNewDirFileEntry(const char* path, uint8_t attributes)
+{
+    List<char*> pathParts = String::Split(path, PATH_SEPERATOR_C);
+    DirectoryEntry* ret = 0;
+    uint32_t entryRootCluster = 0; 
+    if(pathParts.size() == 0)
+    {
+        uint32_t newCluster = AllocateCluster();        
+        ret = CreateEntry(this->rootDirCluster, (char*)path, attributes, true, newCluster, 0);
+    }
+    else
+    {
+        char* parentDirectory = (char*)path;
+        int i = String::IndexOf(path, PATH_SEPERATOR_C, pathParts.size() - 2);
+
+        // Kinda stupid way to split filename and filepath, but it works!
+        char tmp = parentDirectory[i];
+        parentDirectory[i] = '\0';
+        
+        char* name = (char*)(path + i + 1);
+        FATEntryInfo* parentEntry = GetEntryByPath(parentDirectory);
+
+        // Place seperator back into filepath
+        parentDirectory[i] = tmp;
+
+        if(parentEntry != 0) 
+        {
+            uint32_t newCluster = AllocateCluster();
+            ret = CreateEntry(GET_CLUSTER(parentEntry->entry), name, attributes, false, newCluster, 0);
+
+            // Extract cluster of root directory for the .. entry
+            entryRootCluster = GET_CLUSTER(parentEntry->entry);
+
+            // Free memory
+            delete parentEntry->filename;
+            delete parentEntry;
+        }
+    }
+
+    for(char* str : pathParts)
+        delete str;
+
+    if(ret != 0)
+    {
+        // Readbuffer gets trashed by ClearCluster so we need to make a copy.
+        DirectoryEntry createdEntry = *ret;
+
+        // Extract cluster from created entry, should be newCluster
+        uint32_t directoryCluster = GET_CLUSTER((*ret));
+
+        // Fat Documentation says that we should clear the cluster for a new directory/file
+        ClearCluster(directoryCluster);
+
+        // Also . and .. entries need to be created for a directory
+        if(attributes & ATTR_DIRECTORY) {
+            uint32_t sector = ClusterToSector(directoryCluster);
+            
+            // Create . entry
+            DirectoryEntry dotEntry;
+            MemoryOperations::memset(&dotEntry, 0, sizeof(DirectoryEntry));
+            MemoryOperations::memcpy(dotEntry.FileName, ".          ", 11);
+            dotEntry.Attributes = ATTR_DIRECTORY;
+
+            // Use same date/time as new entry
+            dotEntry.AccessDate = createdEntry.AccessDate;
+            dotEntry.CreationDate = createdEntry.CreationDate;
+            dotEntry.CreationTime = createdEntry.CreationTime;
+            dotEntry.CreationTimeTenth = createdEntry.CreationTimeTenth;
+            dotEntry.ModifyDate = createdEntry.ModifyDate;
+            dotEntry.ModifyTime = createdEntry.ModifyTime;
+
+            // Point entry to the main directory
+            dotEntry.LowFirstCluster = directoryCluster & 0xFFFF;
+            dotEntry.HighFirstCluster = (directoryCluster >> 16) & 0xFFFF;
+
+            // Read first sector of new cluster, should be all zero's since we cleared it
+            if(this->disk->ReadSector(this->StartLBA + sector, this->readBuffer) != 0)
+                return -1;
+
+            // Copy first . entry
+            MemoryOperations::memcpy(this->readBuffer, &dotEntry, sizeof(DirectoryEntry));
+
+            // Modify entry to point to parent
+            dotEntry.LowFirstCluster = entryRootCluster & 0xFFFF;
+            dotEntry.HighFirstCluster = (entryRootCluster >> 16) & 0xFFFF;
+            MemoryOperations::memcpy(dotEntry.FileName, "..         ", 11); // And change name to the ..
+
+            // Copy second .. entry
+            MemoryOperations::memcpy(this->readBuffer + sizeof(DirectoryEntry), &dotEntry, sizeof(DirectoryEntry));
+
+            // Finaly write it back to the disk
+            if(this->disk->WriteSector(this->StartLBA + sector, this->readBuffer) != 0)
+                return -1;
+        }
+        
+        return 0;
+    }
+    
+    return -1;
+}
+
+bool FAT::ModifyEntry(FATEntryInfo* entry, DirectoryEntry newVersion)
+{
+    if(entry == 0)
+        return false;
+
+    if(this->disk->ReadSector(this->StartLBA + entry->sector, this->readBuffer) != 0)
+        return false;
+    
+    // Create pointer to entry for easy access
+    DirectoryEntry* entryPtr = (DirectoryEntry*)(this->readBuffer + entry->offsetInSector);
+
+    // Check if this is indeed the correct item, just to be sure
+    if(MemoryOperations::memcmp(&entry->entry, entryPtr, sizeof(DirectoryEntry)) != 0)
+        return false;
+    
+    // Overwrite old entry
+    MemoryOperations::memcpy(entryPtr, &newVersion, sizeof(DirectoryEntry));
+
+    // And finally write sector back to disk
+    if(this->disk->WriteSector(this->StartLBA + entry->sector, this->readBuffer) != 0)
+        return false;
+
+    return true;
+}
+#pragma endregion
+
+
+#pragma region DateTime
+uint16_t FAT::FatTime()
+{
+    return (uint16_t)System::rtc->GetHour() << 11 | (uint16_t)System::rtc->GetMinute() << 5 | (uint16_t)System::rtc->GetSecond() >> 1;
+}
+uint16_t FAT::FatDate()
+{
+    return (uint16_t)(System::rtc->GetYear()-1980) << 9 | (uint16_t)System::rtc->GetMonth() << 5 | (uint16_t)System::rtc->GetDay();
+}
+#pragma endregion
+
+
+
+
+
+
+List<LIBCactusOS::VFSEntry>* FAT::DirectoryList(const char* path)
+{ 
+    List<LIBCactusOS::VFSEntry>* ret = new List<LIBCactusOS::VFSEntry>();
+    uint32_t parentCluster = this->rootDirCluster;
+    bool rootdir = String::strlen(path) == 0;
+
+    if(!rootdir) // Not the Root directory
+    {
+        FATEntryInfo* parent = GetEntryByPath((char*)path);
+        parentCluster = GET_CLUSTER(parent->entry);
+        
+        delete parent->filename;
+        delete parent;
+    }
+
+    List<FATEntryInfo> childs = GetDirectoryEntries(parentCluster, rootdir);
+    for(FATEntryInfo item : childs) {
+        // Create new entry and clear it to 0's
+        LIBCactusOS::VFSEntry entry;
+        MemoryOperations::memset(&entry, 0, sizeof(LIBCactusOS::VFSEntry));
+        
+        // Fill in the info
+        entry.size = item.entry.FileSize;
+        entry.isDir = item.entry.Attributes & ATTR_DIRECTORY;
+        entry.creationDate.day = item.entry.CreationDate & 0b11111;
+        entry.creationDate.month = (item.entry.CreationDate >> 5) & 0b1111;
+        entry.creationDate.year = ((item.entry.CreationDate >> 9) & 0b1111111) + 1980;
+
+        entry.creationTime.sec = (item.entry.CreationTime & 0b11111) * 2;
+        entry.creationTime.min = (item.entry.CreationTime >> 5) & 0b111111;
+        entry.creationTime.hour = (item.entry.CreationTime >> 11) & 0b11111;
+
+        int len = String::strlen(item.filename);
+        MemoryOperations::memcpy(entry.name, item.filename, len < VFS_NAME_LENGTH ? len : VFS_NAME_LENGTH);
+        
+        ret->push_back(entry);
+    }
+
+    return ret;
+}
+
+uint32_t FAT::GetFileSize(const char* path)
+{
+    FATEntryInfo* entry = GetEntryByPath((char*)path);
+    uint32_t fileSize = 0;
+    if(entry == 0)
+        return 0;
+    
+    if(entry->entry.Attributes & ATTR_DIRECTORY)
+       fileSize = -1; 
+    else
+        fileSize = entry->entry.FileSize;
+
+    delete entry->filename;
+    delete entry;
+
+    return fileSize;
+}
+int FAT::ReadFile(const char* path, uint8_t* buffer, uint32_t offset, uint32_t len)
+{ 
+    if((int)len == -1)
+        len = GetFileSize(path);
+
+    FATEntryInfo* entry = GetEntryByPath((char*)path);
+    if(entry == 0)
+        return -1;
+    
+    if(entry->entry.Attributes & ATTR_DIRECTORY) {
+        delete entry->filename;
+        delete entry;
+        return -1;
+    }
+
+    uint32_t cluster = GET_CLUSTER(entry->entry);
+    uint8_t* bufferPointer = buffer;
+    uint32_t bytesRead = 0;
+
+    // Not needed anymore
+    delete entry->filename;
+    delete entry;
+    
+    while ((cluster != CLUSTER_FREE) && (cluster < CLUSTER_END))
+    {
+        uint32_t sector = ClusterToSector(cluster);
+
+        for(uint16_t i = 0; i < this->sectorsPerCluster; i++) // Loop through sectors in this cluster
+        {
+            if(this->disk->ReadSector(this->StartLBA + sector + i, this->readBuffer) != 0) {
+                Log(Error, "Error reading disk at lba %d", this->StartLBA + sector + i);
+                return -1;
+            }
+
+            uint32_t remaingBytes = len - bytesRead;
+
+            //Copy the required part of the buffer
+            MemoryOperations::memcpy(bufferPointer, this->readBuffer, remaingBytes <= this->bytesPerSector ? remaingBytes : this->bytesPerSector);
+
+            bytesRead += this->bytesPerSector;
+            bufferPointer += this->bytesPerSector;
+        }
+        cluster = ReadTable(cluster);
+    }
+
+    return 0;
+}
+
+int FAT::WriteFile(const char* path, uint8_t* buffer, uint32_t len, bool create)
+{
+    if(FileExists(path) == false && create)
+        if(CreateFile(path) != 0)
+            return -1;
+
+    // Get entry
+    FATEntryInfo* entry = GetEntryByPath((char*)path);
+    if(entry == 0)
+        return -1;
+
+    uint32_t reqClusters = len / this->clusterSize;
+    if(len % this->clusterSize != 0)
+        reqClusters++;
+
+    uint32_t bytesWritten = 0;
+
+    // File should have first cluster allocated already
+    uint32_t cluster = GET_CLUSTER(entry->entry);
+    for(uint32_t i = 0; i < reqClusters; i++) {
+        uint32_t sector = ClusterToSector(cluster);
+        for(uint32_t s = 0; s < this->sectorsPerCluster; s++) {
+            uint32_t bytesLeft = len - bytesWritten;
+
+            // Use readbuffer for partial writing when there is not a complete sector left
+            if(bytesLeft < this->bytesPerSector) {
+                MemoryOperations::memset(this->readBuffer, 0, this->bytesPerSector);        
+                MemoryOperations::memcpy(this->readBuffer, buffer + i*this->clusterSize + s*this->bytesPerSector, bytesLeft > this->bytesPerSector ? this->bytesPerSector : bytesLeft);
+
+                // Write sector with data to the disk
+                if(this->disk->WriteSector(this->StartLBA + sector + s, this->readBuffer) != 0) {
+                    delete entry->filename;
+                    delete entry;
+                    return -1;
+                }
+            }
+            else // Much faster routine for complete sectors (Much might be a overstatement, specialy for floppies)
+            {
+                if(this->disk->WriteSector(this->StartLBA + sector + s, buffer + i*this->clusterSize + s*this->bytesPerSector) != 0) {
+                    delete entry->filename;
+                    delete entry;
+                    return -1;
+                }
+            }
+
+            // And update variables
+            bytesWritten += this->bytesPerSector;
+        }
+        
+        // No need to clear cluster, will get overwritten
+        uint32_t newCluster = AllocateCluster();
+        WriteTable(cluster, newCluster);
+        cluster = newCluster;
+    }
+
+    // Now we need to modify some variables in the entry
+    DirectoryEntry newEntry = entry->entry;
+    newEntry.FileSize = len;
+    newEntry.ModifyDate = FatDate();
+    newEntry.ModifyTime = FatTime();
+    
+    // Modify entry
+    if(ModifyEntry(entry, newEntry) == false) {
+        delete entry->filename;
+        delete entry;
+        return -1;
+    }
+
+    delete entry->filename;
+    delete entry;
+    return 0;
+}
+
+int FAT::CreateFile(const char* path)
+{
+    return CreateNewDirFileEntry(path, 0);
+}
+
+int FAT::CreateDirectory(const char* path)
+{
+    return CreateNewDirFileEntry(path, ATTR_DIRECTORY);
+}
+
+bool FAT::FileExists(const char* path)
+{
+    FATEntryInfo* entry = GetEntryByPath((char*)path);
+    bool exists = false;
+    if(entry == 0)
+        return false;
+    
+    exists = !(entry->entry.Attributes & ATTR_DIRECTORY);
+
+    delete entry->filename;
+    delete entry;
+
+    return exists;
+}
+bool FAT::DirectoryExists(const char* path)
+{
+    FATEntryInfo* entry = GetEntryByPath((char*)path);
+    bool exists = false;
+    if(entry == 0)
+        return false;
+    
+    exists = (entry->entry.Attributes & ATTR_DIRECTORY);
+
+    delete entry->filename;
+    delete entry;
+
+    return exists;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/vfs/iso9660.cpp b/kernelz/src/system/vfs/iso9660.cpp
new file mode 100644
index 0000000..d376dec
--- /dev/null
+++ b/kernelz/src/system/vfs/iso9660.cpp
@@ -0,0 +1,356 @@
+//TODO: There is probably a bit of a memory leak here, fix this in the future
+
+#include <system/vfs/iso9660.h>
+
+#include <system/memory/heap.h>
+
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+//with this we don't need to allocate and free buffers all the time
+uint8_t readBuffer[CDROM_SECTOR_SIZE];
+
+ISO9660::ISO9660(Disk* disk, uint32_t start, uint32_t size)
+: VirtualFileSystem(disk, start, size) 
+{
+    this->Name = "ISO9660 Filesystem";
+}
+
+bool ISO9660::Initialize()
+{
+    BootConsole::WriteLine();
+    BootConsole::WriteLine("Starting ISO9660 fileystem");
+    BootConsole::WriteLine("Reading Volume Descriptors");
+    bool FoundPVD = false;
+    int Offset = ISO_START_SECTOR;
+
+    while (FoundPVD == false)
+    {
+        if(this->disk->ReadSector(Offset, readBuffer) != 0)
+        {
+            BootConsole::WriteLine("Error Reading disk");
+            return false;
+        }
+
+        VolumeDescriptor* descriptor = (VolumeDescriptor*)readBuffer;
+        BootConsole::Write("Found, type = "); BootConsole::Write(Convert::IntToString(descriptor->Type)); BootConsole::WriteLine();
+
+        if(descriptor->Type == VolumeDescriptorType::PVDescriptor)
+        {
+            FoundPVD = true;
+            BootConsole::Write("Found Primary Volume Descriptor at offset: "); BootConsole::Write(Convert::IntToString(Offset)); BootConsole::WriteLine();
+
+            //Print PrimaryVolumeDescriptor information
+            PrimaryVolumeDescriptor* pvd = (PrimaryVolumeDescriptor*)readBuffer;
+            BootConsole::Write("Identifier: "); BootConsole::Write(pvd->id); BootConsole::WriteLine();
+            BootConsole::Write("Volume Identifier: "); BootConsole::Write(pvd->volume_id); BootConsole::WriteLine();
+            BootConsole::Write("Version: "); BootConsole::Write(Convert::IntToString(pvd->version)); BootConsole::WriteLine();
+            BootConsole::Write("Root directory sector: "); BootConsole::Write(Convert::IntToString(pvd->root_directory_record.extent_location)); BootConsole::WriteLine();
+        
+            BootConsole::WriteLine("Saving root directory to memory");
+            if(this->disk->ReadSector(pvd->root_directory_record.extent_location, readBuffer) != 0)
+            {
+                BootConsole::WriteLine("Error Reading disk");
+                return false;
+            }
+            this->rootDirectory = (DirectoryRecord*)KernelHeap::malloc(sizeof(DirectoryRecord));
+            MemoryOperations::memcpy(this->rootDirectory, readBuffer, sizeof(DirectoryRecord));
+        }
+        else if (descriptor->Type == VolumeDescriptorType::VolumeDescriptorSetTerminator)
+        {
+            BootConsole::WriteLine("Found end of descriptors");
+            return false;
+        }
+
+        if(Offset < (int)(this->SizeInSectors - (uint32_t)ISO_START_SECTOR))
+            Offset++; //Read the next sector
+        else
+        {
+            BootConsole::WriteLine("Could not find valid Primary Volume Descriptor");
+            return false;
+        }
+    }
+
+    uint8_t oldColor = BootConsole::ForegroundColor;
+    BootConsole::ForegroundColor = VGA_COLOR_GREEN;
+    BootConsole::WriteLine("ISO9660 Filesystem Intialized");
+    BootConsole::ForegroundColor = oldColor;
+    return true;
+}
+
+char* ISO9660::GetRecordName(DirectoryRecord* record)
+{
+    if(record->name[0] == '\0' || record->name[0] == '\1') // . and .. entries
+        return 0;
+
+    // Search for Rockridge extension first
+    if(record->name[record->name_length + 1] != 0) {
+        int offset = record->name_length + 1;
+        if(offset % 2 == 0) // Even number
+            offset -= 1;
+        
+        while (1)
+        {
+            int len = record->name[offset + 2];
+            if(String::strncmp(record->name + offset, "NM", 2)) // Name field
+            {
+                int strLen = len - 5;
+                char* entry = new char[strLen + 1];
+                MemoryOperations::memcpy(entry, record->name + offset + 5, strLen);
+                entry[strLen] = '\0';
+                
+                return entry;
+            }
+            else
+                if(record->name[offset] == 0)
+                    break;
+                else
+                    offset += len;
+        }
+    }
+    
+    // Return short name, could be enough
+    if(GetEntryType(record) == Iso_File)
+    {
+        char* entry = new char[record->name_length];
+        MemoryOperations::memcpy(entry, record->name, record->name_length - 2);
+        entry[record->name_length - 2] = '\0';
+        
+        return entry;
+    }
+    else //Directories do not have version numbers
+    {
+        char* entry = new char[record->name_length + 1];
+        MemoryOperations::memcpy(entry, record->name, record->name_length);
+        entry[record->name_length] = '\0';
+        
+        return entry;
+    }
+}
+
+Iso_EntryType ISO9660::GetEntryType(DirectoryRecord* entry)
+{
+    return ((entry->flags >> 1) & 1) ? Iso_Directory : Iso_File;
+}
+
+DirectoryRecord* ISO9660::SearchInDirectory(DirectoryRecord* searchIn, const char* name)
+{
+    int Offset = ((searchIn == rootDirectory) ? searchIn->length : 0);
+    int SectorOffset = 1;
+
+    if(this->disk->ReadSector(searchIn->extent_location, readBuffer) != 0)
+        return 0;
+
+    while(true)
+    {
+        // TODO: there has to be a better way
+        if(CDROM_SECTOR_SIZE - Offset < (sizeof(DirectoryRecord) - sizeof(DirectoryRecord::name))) //We reached the end of the sector, so we need to read the next one
+        {
+            Offset = 0; // Reset the offset in the sector
+            if(this->disk->ReadSector(searchIn->extent_location + SectorOffset, readBuffer) != 0)
+                return 0;
+            SectorOffset++;
+        }
+
+        DirectoryRecord* record = (DirectoryRecord*)(readBuffer + Offset);
+        if(record->length == 0) // We reached the end of the entry's
+        {
+            break;
+        }
+        else
+        {
+            char* entryName = GetRecordName(record);
+
+            if(entryName != 0 && String::strcmp(entryName, name))
+            {
+                DirectoryRecord* result = new DirectoryRecord();
+                MemoryOperations::memcpy(result, record, sizeof(DirectoryRecord));
+
+                //Terminate string
+                result->name[record->name_length] = '\0';
+
+                //Free memory
+                delete entryName;
+                
+                return result;
+            }
+            if(entryName != 0)
+                delete entryName;
+        }
+
+        Offset += record->length;
+    }
+
+    return 0;
+}
+
+DirectoryRecord* ISO9660::GetEntry(const char* path)
+{
+    DirectoryRecord* searchIn = this->rootDirectory;
+
+    List<char*> pathList = String::Split(path, PATH_SEPERATOR_C);
+
+    if(pathList.size() == 0) //The path represents a entry in the root directory
+        return this->SearchInDirectory(searchIn, path);
+
+    for(int i = 0; i < pathList.size(); i++)
+    {
+        DirectoryRecord* entry = this->SearchInDirectory(searchIn, pathList[i]);
+        if(entry == 0)
+            return 0;
+        else if(i == pathList.size() - 1)
+        {
+            return entry;
+        }
+
+        searchIn = entry;
+    }
+
+    return 0;
+}
+
+List<LIBCactusOS::VFSEntry>* ISO9660::DirectoryList(const char* path)
+{
+    List<LIBCactusOS::VFSEntry>* result = new List<LIBCactusOS::VFSEntry>();
+    DirectoryRecord* parent = String::strlen(path) > 0 ? GetEntry(path) : rootDirectory;
+    if(parent == 0 || GetEntryType(parent) == Iso_File)
+        return result;
+
+    int Offset = ((parent == rootDirectory) ? parent->length : 0);
+    int SectorOffset = 1;
+    if(this->disk->ReadSector(parent->extent_location, readBuffer) != 0)
+        return result;
+
+    while(true)
+    {
+        if(Offset + sizeof(DirectoryRecord) > CDROM_SECTOR_SIZE) //We reached the end of the sector, so we want to read the next one, TODO: fix this
+        {
+            Offset = 0; //Reset the offset in the sector
+            if(this->disk->ReadSector(parent->extent_location + SectorOffset, readBuffer) != 0)
+                return result;
+            SectorOffset++;
+        }
+
+        DirectoryRecord* record = (DirectoryRecord*)(readBuffer + Offset);
+        if(record->length == 0) //We reached the end of the entry's
+            break;
+        else
+            if(record->name[0] != '\0' && record->name[0] != '\1') //We ignore the . and .. directories
+            {
+                char* entryName = GetRecordName(record);
+                if(entryName != 0) {
+                    LIBCactusOS::VFSEntry entry;
+                    MemoryOperations::memset(&entry, 0, sizeof(LIBCactusOS::VFSEntry));
+
+                    // Fill in the info
+                    entry.size = record->data_length;
+                    entry.isDir = (GetEntryType(record) == Iso_EntryType::Iso_Directory);
+                    entry.creationDate.day = record->datetime[2];
+                    entry.creationDate.month = record->datetime[1];
+                    entry.creationDate.year = record->datetime[0] + 1900;
+
+                    entry.creationTime.sec = record->datetime[5];
+                    entry.creationTime.min = record->datetime[5];
+                    entry.creationTime.hour = record->datetime[3];
+
+                    int len = String::strlen(entryName);
+                    MemoryOperations::memcpy(entry.name, entryName, len < VFS_NAME_LENGTH ? len : VFS_NAME_LENGTH);
+
+                    result->push_back(entry);
+                }
+            }
+
+        Offset += record->length;
+    }
+
+    if(parent != 0 && parent != this->rootDirectory)
+        delete parent;
+        
+    return result;
+}
+uint32_t ISO9660::GetFileSize(const char* path)
+{
+    DirectoryRecord* entry = GetEntry(path);
+    if(entry == 0 || GetEntryType(entry) == Iso_Directory)
+    {
+        if(entry != 0) delete entry;
+        return -1;
+    }
+    uint32_t len = entry->data_length;
+
+    delete entry;
+    return len;
+}
+int ISO9660::ReadFile(const char* path, uint8_t* buffer, uint32_t offset, uint32_t len)
+{
+    DirectoryRecord* entry = GetEntry(path);
+
+    if(entry == 0 || GetEntryType(entry) == Iso_Directory) {
+        if(entry != 0) delete entry;
+        return -1;
+    }
+
+    if(len == (uint32_t)-1)
+        len = entry->data_length;
+
+    //TODO: Actually implement partial file reading, for now we read the whole file
+    int sectorCount = entry->data_length / CDROM_SECTOR_SIZE;
+    int dataRemainder = entry->data_length % CDROM_SECTOR_SIZE;
+
+    for(int i = 0; i < sectorCount; i++)
+        if(this->disk->ReadSector(entry->extent_location + i, buffer + (CDROM_SECTOR_SIZE * i)) != 0) {
+            delete entry;
+            return -1;
+        }
+    
+    if(dataRemainder > 0) //We have a remainder
+    {
+        if(this->disk->ReadSector(entry->extent_location + sectorCount, readBuffer) != 0) {
+            delete entry;
+            return -1;
+        }
+        MemoryOperations::memcpy(buffer + (sectorCount*CDROM_SECTOR_SIZE), readBuffer, dataRemainder);
+    }
+    
+    delete entry;
+    return 0;
+}
+int ISO9660::WriteFile(const char* path, uint8_t* buffer, uint32_t len, bool create)
+{
+    return -1; // ISO9660 is readonly
+}
+int ISO9660::CreateFile(const char* path)
+{
+    return -1;
+}
+int ISO9660::CreateDirectory(const char* path)
+{
+    return -1;
+}
+
+bool ISO9660::FileExists(const char* path)
+{
+    DirectoryRecord* entry = GetEntry(path);
+    if(entry == 0 || GetEntryType(entry) == Iso_Directory)
+    {
+        if(entry != 0) delete entry;
+        return false;
+    }
+
+    delete entry;
+    return true;
+}
+
+bool ISO9660::DirectoryExists(const char* path)
+{
+    DirectoryRecord* entry = GetEntry(path);
+    if(entry == 0 || GetEntryType(entry) == Iso_File)
+    {
+        if(entry != 0) delete entry;
+        return false;
+    }
+
+    delete entry;
+    return true;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/vfs/vfsmanager.cpp b/kernelz/src/system/vfs/vfsmanager.cpp
new file mode 100644
index 0000000..72fb389
--- /dev/null
+++ b/kernelz/src/system/vfs/vfsmanager.cpp
@@ -0,0 +1,231 @@
+#include <system/vfs/vfsmanager.h>
+#include <system/system.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+VFSManager::VFSManager()
+{
+    this->Filesystems = new List<VirtualFileSystem*>();
+}
+
+int VFSManager::ExtractDiskNumber(const char* path, uint8_t* idSizeReturn)
+{
+    if(String::Contains(path, ':') && String::Contains(path, PATH_SEPERATOR_C))
+    {
+        int idLength = String::IndexOf(path, ':');
+
+        char* idStr = new char[idLength];
+        MemoryOperations::memcpy(idStr, path, idLength);
+
+        int idValue = 0;
+
+        if(isalpha(idStr[0])) //Are we using a character instead of a integer
+        {
+            switch (idStr[0])
+            {
+                case 'b':
+                case 'B': //Boot partition
+                    idValue = this->bootPartitionID;
+                    break;      
+                default:
+                    delete idStr;
+                    return -1;
+                    break;
+            }
+        }
+        else
+            idValue = Convert::StringToInt(idStr);
+
+        delete idStr;
+
+        if(idSizeReturn != 0)
+            *idSizeReturn = idLength;   
+           
+        return idValue;  
+    }
+    return -1;
+}
+
+void VFSManager::Mount(VirtualFileSystem* vfs)
+{
+    this->Filesystems->push_back(vfs); //Just add it to the list of known filesystems, easy.
+}
+void VFSManager::Unmount(VirtualFileSystem* vfs)
+{
+    this->Filesystems->Remove(vfs);
+}
+void VFSManager::UnmountByDisk(Disk* disk)
+{
+    for(VirtualFileSystem* vfs : *Filesystems)
+        if(vfs->disk == disk)
+            Unmount(vfs);
+}
+
+bool VFSManager::SearchBootPartition()
+{
+    List<Disk*> posibleDisks;
+    char* pathString = "####:\\boot\\CactusOS.bin";
+
+    // First we create a collection of disks which may be the boot disk
+    // Could be more then one when there are more than 1 cd drives installed
+
+    uint8_t bootDevice = (System::mbi->boot_device & 0xFF000000) >> 24;
+    BiosDriveParameters* diskInfo = System::diskManager->GetDriveInfoBios(bootDevice);
+    if(diskInfo->bufLen > 0 && diskInfo->interfaceName[0] != '\0') // Valid structure
+    {
+        DiskType bootDiskType = HardDisk;
+        if(diskInfo->bytesPerSector == 2048) // Probably a cdrom
+            bootDiskType = CDROM;
+        if(String::strncmp("USB", diskInfo->interfaceName, 3)) // Is a usb-device
+            bootDiskType = USBDisk;
+        
+        for(Disk* disk : System::diskManager->allDisks)
+            if(disk->type == bootDiskType) 
+            {
+                if(bootDiskType == HardDisk) { // Do a sector count check
+                    if(divide64(disk->size, diskInfo->bytesPerSector) == diskInfo->totalSectors)
+                        posibleDisks.push_back(disk);
+                }
+                else
+                    posibleDisks.push_back(disk);
+            }
+    }
+    else { // Include all disks in the search
+        for(Disk* disk : System::diskManager->allDisks)
+            posibleDisks.push_back(disk);
+    }
+
+    // Now loop though all the filesystems mounted and check if the disk can be the booted one
+    // If that is the case check for the kernel file
+    // At this point we can assume this is the boot disk
+    for(int i = 0; i < Filesystems->size(); i++)
+    {
+        if(posibleDisks.IndexOf(Filesystems->GetAt(i)->disk) == -1)
+            continue; // This partition is not present on the posible disks we booted from
+        
+        char* idStr = Convert::IntToString(i);
+        int idStrLen = String::strlen(idStr);
+
+        MemoryOperations::memcpy(pathString + (4-idStrLen), idStr, idStrLen);
+
+        if(Filesystems->GetAt(i)->FileExists(pathString + (4-idStrLen) + 3))
+        {
+            this->bootPartitionID = i;
+            return true;
+        }
+    }
+    return false;
+}
+
+List<LIBCactusOS::VFSEntry>* VFSManager::DirectoryList(const char* path)
+{
+    uint8_t idSize = 0;
+    int disk = ExtractDiskNumber(path, &idSize);
+    if(disk != -1 && Filesystems->size() > disk)
+        return Filesystems->GetAt(disk)->DirectoryList(path + idSize + 2); // skips the 0:\ part
+    else
+        return 0;
+}
+
+uint32_t VFSManager::GetFileSize(const char* path)
+{
+    uint8_t idSize = 0;
+    int disk = ExtractDiskNumber(path, &idSize);
+    if(disk != -1 && Filesystems->size() > disk)
+        return Filesystems->GetAt(disk)->GetFileSize(path + idSize + 2); // skips the 0:\ part
+    else
+        return -1;
+}
+
+int VFSManager::ReadFile(const char* path, uint8_t* buffer, uint32_t offset, uint32_t len)
+{
+    uint8_t idSize = 0;
+    int disk = ExtractDiskNumber(path, &idSize);
+
+    if(disk != -1 && Filesystems->size() > disk)
+        return Filesystems->GetAt(disk)->ReadFile(path + idSize + 2, buffer, offset, len);
+    else
+        return -1;
+}
+
+int VFSManager::WriteFile(const char* path, uint8_t* buffer, uint32_t len, bool create)
+{
+    uint8_t idSize = 0;
+    int disk = ExtractDiskNumber(path, &idSize);
+
+    if(disk != -1 && Filesystems->size() > disk)
+        return Filesystems->GetAt(disk)->WriteFile(path + idSize + 2, buffer, len, create);
+    else
+        return -1;
+}
+
+bool VFSManager::FileExists(const char* path)
+{
+    uint8_t idSize = 0;
+    int disk = ExtractDiskNumber(path, &idSize);
+
+    if(disk != -1 && Filesystems->size() > disk)
+        return Filesystems->GetAt(disk)->FileExists(path + idSize + 2);
+    else
+        return false;
+}
+
+bool VFSManager::DirectoryExists(const char* path)
+{
+    uint8_t idSize = 0;
+    int disk = ExtractDiskNumber(path, &idSize);
+
+    if(disk != -1 && Filesystems->size() > disk) {
+        if(String::strlen(path) == idSize + 2) //Only disk part, like 0:\ ofcourse this is a directory as well
+            return true;
+        else
+            return Filesystems->GetAt(disk)->DirectoryExists(path + idSize + 2);
+    }
+    else
+        return false;
+}
+
+int VFSManager::CreateFile(const char* path)
+{
+    uint8_t idSize = 0;
+    int disk = ExtractDiskNumber(path, &idSize);
+
+    if(disk != -1 && Filesystems->size() > disk) {
+        if(String::strlen(path) == idSize + 2) //Only disk part, like 0:\ ofcourse this is a directory as well
+            return true;
+        else
+            return Filesystems->GetAt(disk)->CreateFile(path + idSize + 2);
+    }
+    else
+        return -1;
+}
+int VFSManager::CreateDirectory(const char* path)
+{
+    uint8_t idSize = 0;
+    int disk = ExtractDiskNumber(path, &idSize);
+
+    if(disk != -1 && Filesystems->size() > disk) {
+        if(String::strlen(path) == idSize + 2) //Only disk part, like 0:\ ofcourse this is a directory as well
+            return true;
+        else
+            return Filesystems->GetAt(disk)->CreateDirectory(path + idSize + 2);
+    }
+    else
+        return -1;
+}
+
+bool VFSManager::EjectDrive(const char* path)
+{
+    uint8_t idSize = 0;
+    int disk = ExtractDiskNumber(path, &idSize);
+
+    if(disk != -1 && Filesystems->size() > disk) {
+        VirtualFileSystem* fs = Filesystems->GetAt(disk);
+        return fs->disk->controller->EjectDrive(fs->disk->controllerIndex);
+    }
+    else
+        return false;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/vfs/virtualfilesystem.cpp b/kernelz/src/system/vfs/virtualfilesystem.cpp
new file mode 100644
index 0000000..05dd5e2
--- /dev/null
+++ b/kernelz/src/system/vfs/virtualfilesystem.cpp
@@ -0,0 +1,65 @@
+#include <system/vfs/virtualfilesystem.h>
+#include <system/log.h>
+
+using namespace CactusOS::common;
+using namespace CactusOS::core;
+using namespace CactusOS::system;
+
+VirtualFileSystem::VirtualFileSystem(Disk* disk, common::uint32_t start, common::uint32_t size, char* name)
+{
+    this->disk = disk;
+    this->SizeInSectors = size;
+    this->StartLBA = start;
+    this->Name = name;
+}
+
+VirtualFileSystem::~VirtualFileSystem()
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+}
+
+bool VirtualFileSystem::Initialize()
+{
+    return false;
+}
+
+int VirtualFileSystem::ReadFile(const char* filename, uint8_t* buffer, uint32_t offset, uint32_t len)
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+    return -1;
+}
+int VirtualFileSystem::WriteFile(const char* filename, uint8_t* buffer, uint32_t len, bool create)
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+    return -1;
+}
+bool VirtualFileSystem::FileExists(const char* filename)
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+    return false;
+}
+bool VirtualFileSystem::DirectoryExists(const char* filename)
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+    return false;
+}
+int VirtualFileSystem::CreateFile(const char* path)
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+    return -1;
+}
+int VirtualFileSystem::CreateDirectory(const char* path)
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+    return -1;
+}
+uint32_t VirtualFileSystem::GetFileSize(const char* filename)
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+    return -1;
+}
+List<LIBCactusOS::VFSEntry>* VirtualFileSystem::DirectoryList(const char* path)
+{
+    Log(Error, "Virtual function called directly %s:%d", __FILE__, __LINE__);
+    return 0;
+}
\ No newline at end of file
diff --git a/kernelz/src/system/virtual8086/VM8086Code.asm b/kernelz/src/system/virtual8086/VM8086Code.asm
new file mode 100644
index 0000000..0096a77
--- /dev/null
+++ b/kernelz/src/system/virtual8086/VM8086Code.asm
@@ -0,0 +1,62 @@
+[bits 16]
+
+global VM86CodeStart
+VM86CodeStart:
+
+; FIXME: uses self modifying code
+global Int86
+Int86:
+    push cs
+    pop ds
+
+    ; modify the int n instruction
+    mov byte [Int86.doInt - VM86CodeStart + 1], al
+
+    ; load registers
+    mov ax, word [0x8000]
+    mov bx, word [0x8002]
+    mov cx, word [0x8004]
+    mov dx, word [0x8006]
+
+    mov di, word [0x8008]
+    ; do the int n instruction
+.doInt:
+    int 0x0	; dummy int instruction
+    		; will be overwritten
+    ; store registers
+    push ds
+    push cs
+    pop ds
+    
+    mov word [0x8000], ax
+    mov word [0x8002], bx
+    mov word [0x8004], cx
+    mov word [0x8006], dx
+
+    mov word [0x8008], di
+
+    ; return to kernel
+    int 0xFE
+
+global diskInfo
+diskInfo:
+    mov dl, al      ; Drive
+    mov ax, 0x4800  ; Function 0x48
+
+    ; Setup buffer
+    mov word [0x7000], 0x42
+    mov si, 0x7000
+
+    int 0x13        ; Call Interupt
+    jc diskInfoError
+
+    ; return to kernel
+    int 0xFE
+
+diskInfoError:
+    mov word [0x7000], 0 ; Indicate error in buffer
+    ; return to kernel
+    int 0xFE
+
+global VM86CodeEnd
+VM86CodeEnd:
diff --git a/kernelz/src/system/virtual8086/VM8086Helper.asm b/kernelz/src/system/virtual8086/VM8086Helper.asm
new file mode 100644
index 0000000..f9f61a2
--- /dev/null
+++ b/kernelz/src/system/virtual8086/VM8086Helper.asm
@@ -0,0 +1,49 @@
+global cpuGetEIP
+cpuGetEIP:
+  pop eax
+  jmp eax
+
+global cpuGetESP
+cpuGetESP:
+  mov eax, esp
+  add eax, 4
+  ret
+
+# VM86 Code
+global cpuEnterV86Int
+cpuEnterV86Int:
+  push ebp
+  mov ebp, esp
+  push ebx
+  push esi
+  push edi
+  mov eax, [ebp + 8]
+  mov ebx, [ebp + 12]
+  mov ecx, [ebp + 16]
+  mov edx, [ebp + 20]
+  mov esi, [ebp + 24]
+  mov edi, [ebp + 28]
+  int 0xFD ; MUST match interrupt number registered in vm86.c
+  pop edi
+  pop esi
+  pop ebx
+  mov esp, ebp
+  pop ebp
+  ret
+
+global cpuEnterV86
+cpuEnterV86:
+  mov ebp, esp
+  push 0                ; GS
+  push 0                ; FS
+  push 0                ; DS
+  push 0                ; ES
+  push dword [ebp + 4]  ; SS
+  push dword [ebp + 8]  ; ESP
+  pushfd                ; EFLAGS
+  or dword [esp], (1 << 17)
+  push dword [ebp + 12] ; CS
+  push dword [ebp + 16] ; EIP
+  mov eax, dword [ebp + 20]
+;  hlt
+  iretd
\ No newline at end of file
diff --git a/kernelz/src/system/virtual8086/VM8086Manager.cpp b/kernelz/src/system/virtual8086/VM8086Manager.cpp
new file mode 100644
index 0000000..0d7e570
--- /dev/null
+++ b/kernelz/src/system/virtual8086/VM8086Manager.cpp
@@ -0,0 +1,89 @@
+#include <system/virtual8086/VM86Manager.h>
+#include <system/system.h>
+#include <system/memory/deviceheap.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+using namespace CactusOS::core;
+
+static const uint16_t codeSegment = 0x2000;
+static const uint16_t stackSegment = 0x8000;
+
+CPUState vm86CPUState;
+
+extern "C" uint8_t VM86CodeStart;
+extern "C" uint8_t VM86CodeEnd;
+extern "C" uint8_t Int86;
+
+extern "C" uintptr_t cpuGetEIP();
+extern "C" uintptr_t cpuGetESP();
+// vm86
+extern "C" void cpuEnterV86Int(int ignored, int arg1, int arg2, int arg3, int arg4, int arg6);
+extern "C" void cpuEnterV86(uint32_t ss, uint32_t esp, uint32_t cs, uint32_t eip, uint32_t eax);
+
+Virtual8086Manager::Virtual8086Manager()
+: InterruptHandler(0xFD)
+{ 
+    // Install int86 trampoline code in conventional memory
+    uint32_t codeSize = &VM86CodeEnd - &VM86CodeStart;
+    MemoryOperations::memcpy((uint8_t*)(codeSegment << 4), &VM86CodeStart, codeSize);
+}
+
+uint32_t Virtual8086Manager::HandleInterrupt(common::uint32_t esp)
+{
+    CPUState* state = (CPUState*)esp;
+    uintptr_t args[] = { state->EAX, state->EBX, state->ECX, state->EDX, state->ESI, state->EDI, state->EBP };
+    
+    InterruptDescriptorTable::DisableInterrupts();
+
+    MemoryOperations::memcpy(&vm86CPUState, state, sizeof(CPUState));
+
+    TSS::GetCurrent()->esp0 = cpuGetESP();
+    TSS::GetCurrent()->eip = cpuGetEIP();
+
+    //BootConsole::WriteLine("[CPU] Entering VM8086 Mode");
+    cpuEnterV86(args[1], args[2], args[3], args[4], args[5]);
+
+    return esp;
+}
+
+void Virtual8086Manager::vm86Enter(uint16_t ss, uint16_t sp, uint16_t cs, uint16_t ip, uint32_t arg)
+{
+    //Log(Info, "[Virtual8086] Making call to %x", cs);
+
+    // Current state of the scheduler
+    bool curSchedulerState = false;
+
+    // Avoid task switches during VM86 calls
+    if(System::scheduler) {
+        curSchedulerState = System::scheduler->Enabled;
+        System::scheduler->Enabled = false;
+    }
+
+    // Allow access to PAGE 0 (needed for BIOS stuff)
+    ((PageTable*)VirtualMemoryManager::GetPageTableAddress(0))->entries[0].present = 1;
+    invlpg((void*)0);
+
+    // Now make the call
+    cpuEnterV86Int(0, ss, sp, cs, ip, arg);
+
+    // Remove access from PAGE 0 again
+    ((PageTable*)VirtualMemoryManager::GetPageTableAddress(0))->entries[0].present = 0;
+    invlpg((void*)0);
+
+    // And enable the scheduler again
+    if(System::scheduler) System::scheduler->Enabled = curSchedulerState;
+}
+
+void Virtual8086Manager::CallInterrupt(uint8_t intNumber, VM86Arguments* regs)
+{
+    MemoryOperations::memcpy((uint8_t*)((codeSegment << 4) + 0x8000), (uint8_t*)regs, sizeof(VM86Arguments));
+    vm86Enter(stackSegment, 0x0000, codeSegment, &Int86 - &VM86CodeStart, intNumber);
+    MemoryOperations::memcpy((uint8_t*)regs, (uint8_t*)((codeSegment << 4) + 0x8000), sizeof(VM86Arguments));
+}
+
+void Virtual8086Manager::ExecuteCode(uint32_t instructionStart, uint32_t args)
+{
+    vm86Enter(stackSegment, 0x0000, codeSegment, instructionStart - (uint32_t)&VM86CodeStart, args);
+}
\ No newline at end of file
diff --git a/kernelz/src/system/virtual8086/VM8086Monitor.cpp b/kernelz/src/system/virtual8086/VM8086Monitor.cpp
new file mode 100644
index 0000000..e743561
--- /dev/null
+++ b/kernelz/src/system/virtual8086/VM8086Monitor.cpp
@@ -0,0 +1,221 @@
+#include <system/virtual8086/VM86Monitor.h>
+#include <common/memoryoperations.h>
+#include <system/log.h>
+
+using namespace CactusOS;
+using namespace CactusOS::common;
+using namespace CactusOS::system;
+using namespace CactusOS::core;
+
+extern CPUState vm86CPUState;
+
+Virtual8086Monitor::Virtual8086Monitor()
+: InterruptHandler(0xD)
+{ }
+
+static uint8_t peekb(uint16_t seg, uint16_t offs)
+{
+    return *(uint8_t *)((seg << 4) + offs);
+}
+
+static uint16_t peekw(uint16_t seg, uint16_t offs)
+{
+    return *(uint16_t *)((seg << 4) + offs);
+}
+
+static uint32_t peekl(uint16_t seg, uint16_t offs)
+{
+    return *(uint32_t *)((seg << 4) + offs);
+}
+
+static void pokeb(uint16_t seg, uint16_t offs, uint8_t val)
+{
+    *(uint8_t *)((seg << 4) + offs) = val;
+}
+
+static void pokew(uint16_t seg, uint16_t offs, uint16_t val)
+{
+    *(uint16_t *)((seg << 4) + offs) = val;
+}
+
+static void pokel(uint16_t seg, uint16_t offs, uint32_t val)
+{
+    *(uint32_t *)((seg << 4) + offs) = val;
+}
+
+static void pushw(CPUState* state, uint16_t val)
+{
+    state->UserSP -= 2;
+    pokew(state->UserSS, state->UserSP, val);
+}
+
+static void pushl(CPUState* state, uint32_t val)
+{
+    state->UserSP -= 4;
+    pokel(state->UserSS, state->UserSP, val);
+}
+
+static uint16_t popw(CPUState* state)
+{
+    uint16_t res = peekw(state->UserSS, state->UserSP);
+    state->UserSP += 2;
+    return res;
+}
+
+static uint32_t popl(CPUState* state)
+{
+    uint32_t res = peekl(state->UserSS, state->UserSP);
+    state->UserSP += 4;
+    return res;
+}
+
+uint32_t Virtual8086Monitor::HandleInterrupt(uint32_t esp)
+{
+    CPUState* state = (CPUState*)esp;
+    bool is32Bit = false;
+
+    uint8_t opcode = peekb(state->CS, state->IP);
+    switch(opcode) 
+    {
+        case 0x66: //32-bit prefix
+            is32Bit = true;
+            ++state->IP;
+            opcode = peekb(state->CS, state->IP);
+            //Log(Info, "32-Bit Opcode %b", opcode);
+            break;
+        case 0x67: //A32
+            ++state->IP;
+            opcode = peekb(state->CS, state->IP);
+            break;
+        default:
+            break;
+    }
+
+    switch(opcode)
+    {
+        case 0xEE:
+        {
+            outportb(state->DX, state->AL);
+            ++state->IP;
+            return esp;
+        }
+        case 0xEF:
+        {
+            if(is32Bit)
+                outportl(state->DX, state->EAX);
+            else
+                outportw(state->DX, state->AX);
+            ++state->IP;
+            return esp;
+        }
+        case 0xEC:
+        {
+            state->AL = inportb(state->DX);
+            ++state->IP;
+            return esp;
+        }
+        case 0xED:
+        {
+            if(is32Bit)
+                state->EAX = inportl(state->DX);
+            else
+                state->AX = inportw(state->DX);
+            ++state->IP;
+            return esp;
+        }
+        case 0xE6:
+        {
+            uint8_t port = peekb(state->CS, ++state->IP);
+            outportb(port, state->AL);
+            ++state->IP;
+            return esp;
+        }
+        case 0xE7:
+        {
+            uint8_t port = peekb(state->CS, ++state->IP);
+            if(is32Bit)
+                outportl(port, state->EAX);
+            else
+                outportw(port, state->AX);
+            ++state->IP;
+            return esp;
+        }
+        case 0xE4:
+        {
+            uint8_t port = peekb(state->CS, ++state->IP);
+            state->AL = inportb(port);
+            ++state->IP;
+            return esp;
+        }
+        case 0xE5:
+        {
+            uint8_t port = peekb(state->CS, ++state->IP);
+            if(is32Bit)
+                state->EAX = inportl(port);
+            else
+                state->AX = inportw(port);
+            ++state->IP;
+            return esp;
+        }
+        case 0xCD:
+        { // int n
+            uint8_t intNo = peekb(state->CS, ++state->IP);
+            if(intNo == 0xFE)
+            { // special interrupt
+                MemoryOperations::memcpy(state, &vm86CPUState, sizeof(CPUState));
+                return esp;
+            }
+            pushw(state, state->FLAGS);
+            state->EFLAGS &= ~((1 << 8) | (1 << 9) | (1 << 18));
+            pushw(state, state->CS);
+            pushw(state, ++state->IP);
+            state->CS = peekw(0x0000, 4 * intNo + 2);
+            state->IP = peekw(0x0000, 4 * intNo);
+            return esp;
+        }
+        case 0xCF:
+        { // iret
+            state->IP = popw(state);
+            state->CS = popw(state);
+            state->FLAGS = popw(state);
+            return esp;
+        }
+        case 0x9C:
+        { // pushf
+            if(is32Bit)
+                pushl(state, state->EFLAGS);
+            else
+                pushw(state, state->FLAGS);
+            
+            ++state->IP;
+            return esp;
+        }
+        case 0x9D:
+        { // popf
+            if(is32Bit)
+                state->EFLAGS = popl(state);
+            else
+                state->FLAGS = popw(state);
+            
+            ++state->IP;
+            return esp;;
+        }
+        case 0xFA:
+        { // cli
+            state->FLAGS &= ~(1 << 9);
+            ++state->IP;
+            return esp;
+        }
+        case 0xFB:
+        { // sti
+            state->FLAGS |= 1 << 9;
+            ++state->IP;
+            return esp;
+        }
+        default:
+            Log(Error, "[vm86] Unknown instruction %b", opcode);
+            ++state->IP;
+            return esp;
+    }
+    return esp;
+}
-- 
2.43.0

